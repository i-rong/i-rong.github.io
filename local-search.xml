<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL_allocator</title>
    <link href="/2023/12/06/STL_allocator/"/>
    <url>/2023/12/06/STL_allocator/</url>
    
    <content type="html"><![CDATA[<h1 id="空间配置器——allocator"><a href="#空间配置器——allocator" class="headerlink" title="空间配置器——allocator"></a>空间配置器——allocator</h1><h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><p>根据 STL 的规范，以下是 allocator 的必要接口：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs txt">allocator::value_type<br>allocator::pointer<br>allocator::const_pointer<br>allocator::reference<br>allocator::const_reference<br>allocator::size_type<br>allocator::difference_type<br>allocator::rebind<br>    一个嵌套的 (nested) class template。 class rebind&lt;U&gt; 拥有唯一成员 other，那是一个 typedef，代表 allocator&lt;U&gt;<br>allocator::allocator()<br>default constructor<br>allocator::allocator(const allocator&amp;)<br>copy constructor<br>template &lt;class U&gt;allocator::allocator(const allocator&lt;U&gt;&amp;)<br>泛化的 copy constructor<br>allocator::~allocator()<br>default deconstructor<br>pointer allocator::address(reference x) const<br>返回某个对象的地址。算式 a.address(x) 等同于 &amp;x<br>const_pointer allocator::address(const_reference x) const<br>返回某个 const 对象的地址。算式 a.address(x) 等同于 &amp;x<br>pointer allocator::allocate(size_type n, const void* = 0)<br>配置空间，足以存储 n 个 T 对象。第二个参数是一个提示。实现上可能会利用它来增进区域性(locality)，或者完全忽略之<br>void allocator::deallocate(pointer p, size_type n)<br>归还先前配置的空间<br>size_type allocator::max_size() const<br>返回可成功配置的最大量<br>void allocator::construct(pointer p, const T&amp; x)<br>等同于 new(const void* p) T(x)<br>void allocator::destory(pointer p)<br>等同于 p-&gt;~T()<br></code></pre></td></tr></table></figure><h3 id="设计一个简单的空间配置器，JJ-allocator"><a href="#设计一个简单的空间配置器，JJ-allocator" class="headerlink" title="设计一个简单的空间配置器，JJ::allocator"></a>设计一个简单的空间配置器，JJ::allocator</h3><p>根据前述的标准接口，我们可以自行完成一个功能简单、接口不怎么齐全的 allocator 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _JJALLOC_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _JJALLOC_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;scstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> JJ<br>&#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">inline</span> T* _allocate(<span class="hljs-type">ptrdiff_t</span> size, T*) &#123;<br>        <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<br>        T* tmp = (T*)(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>((<span class="hljs-type">size_t</span>)(size * <span class="hljs-built_in">sizeof</span>(T))));<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) &#123;<br>            cerr &lt;&lt; <span class="hljs-string">&quot;out of memory&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>STL源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>情景设计_统计海量数据中出现次数最多的前10个IP</title>
    <link href="/2023/12/06/%E6%83%85%E6%99%AF%E8%AE%BE%E8%AE%A1-%E7%BB%9F%E8%AE%A1%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D10%E4%B8%AAIP/"/>
    <url>/2023/12/06/%E6%83%85%E6%99%AF%E8%AE%BE%E8%AE%A1-%E7%BB%9F%E8%AE%A1%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D10%E4%B8%AAIP/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>127.0.0.1 这是一个 IPv4地址</p><p>假设有 100 亿个这样的 ip 地址存在文件中，这个文件的大小大约是 100 GB</p><p><strong>问题：要统计出 100 亿个 ip 中，重复出现次数最多的前 10 个</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>100GB 几乎不可能一次加载进内存进行操作，所以必须要拆分。</p><p>可以利用分治的思想，把规模大的问题化小，然后解决各个小的问题，最后得出结果。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>IPv4 是一个 32 位的整数，可以用 uint 保存</li><li>先设计一个哈希函数，把 100 个 G 的文件分成 10000 份，每份大约是 10 MB，可以转载进内存了。</li></ul><blockquote><p>例如：设计一个简单的哈希函数 <code>f(ip) = ip % 10000</code> (ip 是一个 32 位整数)</p><p>那么 5 % 10000 &#x3D; 5，无论 5 在哪一个地方，5 % 10000 的结果都是 5，这就保证了相同的 ip 会被放在同一个子文件中，方便统计。相同的元素经过同一个哈希函数，得出的哈希值是一样的，</p><p>那么将 100 亿个 ip，都进行 ip % 10000 的操作，就完成了 100 GB 文件分解成 10000 个子文件的任务。实际中哈希函数的选取很重要，尽量使得元素分布均匀，哈希冲突少的函数才是更好的。</p></blockquote><p>​将上述这个分解的过程称为 Map，由一台叫 Master 的计算机完成这个工作。</p><ul><li>10 MB 的小文件加进内存，统计出出现次数最多的前 10 个 ip</li></ul><blockquote><p>10MB 的小文件里面存着很多 ip，他们虽然是乱序的，但是相同的 ip 会映射到同一个文件中来！<br>那么可以用 unordered_map 统计出现次数，key 是 ip，value 是出现次数，把所有 ip 插入到 unordered_map 中，如果这个 ip 不存在，那么新建一个 key_value 对，count 标记 1，如果有，那么把 count++，最终遍历一遍 unordered_map，将出现次数前 10 大的 ip 取出。</p></blockquote><p>​把这个过程称为 Reduce，由很多台称为 Worker 的计算机来完成。</p><p>​每个 worker 至少要找出最大的前 10 个 ip 返回给 master，master 最后会收集到 10000 * 10 个 ip，大约 400 KB，然后再找出最大的前 10 个 ip 就可以了。</p><p>​最简单的遍历 10 遍，每次拿一个最大值出来就可以了，或者使用快速排序，堆排序，归并排序等等方法，找出最大的前 k 个数也可以。</p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>刚刚除了介绍了一种海量数据的哈希分治算法之外，还穿插了一个谷歌的 MapReduce 分布式并行编程模型，原理就是上面说的那些了，有兴趣的可以去详细了解。MIT 6.5840 可以学习一下，详细地介绍了这个算法，并使用 go 语言完成了一个 MapReduce 的简单 Demo。</p>]]></content>
    
    
    
    <tags>
      
      <tag>情景设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Characterizing_Off-path_SmartNIC_for_Accelerating_Distributed_Systems论文翻译</title>
    <link href="/2023/12/05/Characterizing-Off-path-SmartNIC-for-Accelerating-Distributed-Systems%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/12/05/Characterizing-Off-path-SmartNIC-for-Accelerating-Distributed-Systems%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="描述用于加速分布式系统的-off-path-SNIC"><a href="#描述用于加速分布式系统的-off-path-SNIC" class="headerlink" title="描述用于加速分布式系统的 off-path SNIC"></a>描述用于加速分布式系统的 off-path SNIC</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>SmartNIC 最近已成为加速分布式系统的有吸引力的设备。 然而，SmartNIC 尚未得到全面的表征，并且现有设计通常仅利用单个通信路径来减轻工作负载。 本文从通信路径的角度首次对代表性的路径外 SmartNIC（特别是 Bluefield-2）进行全面研究。 我们的实验研究系统地探索了客户端、板载 SoC 和主机之间通信的关键性能特征，并为设计人员提供了富有洞察力的发现和建议。 此外，我们建议同时使用 SmartNIC 的多个通信路径，并提出开创性指南，为各种分布式系统提供新的优化机会。 为了证明我们方法的有效性，我们对基于 SmartNIC 的分布式文件系统 (LineFS) 和基于 RDMA 的分类键值存储 (DrTM-KV) 进行了案例研究。 我们的实验结果表明，LineFS 和 DrTM-KV 分别提高了 30% 和 25%。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>远程直接内存访问 (RDMA) 已在现代数据中心中广泛采用，将网络带宽（推向 400 Gbps）和分布式系统性能推向新的水平。 然而，高速网络需要更多的CPU资源来使支持 RDMA 的快速NIC（RNIC）饱和，这给分布式系统带来了巨大的CPU负担。 单向 RDMA 可以通过让 RNIC 以 CPU 旁路的方式直接读写主机内存来缓解 CPU 压力。 然而，有限的卸载能力可能会导致网络放大，从而降低系统性能。<br>RDMA 以及 CPU 的基本功率和内存墙的不断改进导致了 SmartNIC（具有可编程功能的 RNIC）的出现。 这些 NIC 为系统提供了将更复杂的计算卸载到 NIC 的机会。 目前，SmartNIC 主要有两种类型。 第一个是 on-path SmartNIC，它直接向系统公开用于处理 RDMA 数据包的处理单元（NIC 核心）。 不幸的是，使用固件对低级 NIC 核心进行编程以及将卸载的程序与正常 RDMA 请求隔离，给开发人员带来了巨大的负担。 为了简化系统开发，off-path SmartNIC在 RNIC 核心旁边附加了一个可编程多核 SoC（带有 DRAM），这远离了 RDMA 的关键路径。 由于这种分离，SoC 独立于正常的 RDMA 请求，并且可以进一步部署成熟的操作系统以使开发变得更加容易。 具体来说，开发人员可以将 SoC 视为单独的服务器。 在本文中，我们重点关注 off-path SmartNIC，因为它具有通用性和可编程性。<br>关于表征 off-path SmartNIC进行了有价值的研究，重点是它们卸载计算的能力。 一个重要的发现是，旁路 SmartNIC 的计算能力弱于主机。 这意味着 off-path SmartNIC 不会提高单个网络路径（例如 NIC 和主机之间的网络路径）的速度。 例如，iPipe发现，由于支持对开发人员更友好的 RDMA，主机和 SoC 之间的路径具有相对较高的延迟。<br>尽管之前的工作在将 SmartNIC 用于分布式系统方面很有价值，但它主要集中于将计算卸载到 SmartNIC 的 SoC。 然而，令人惊讶的是，尽管 SmartNIC 对整体性能有重大影响，但其基本功能（即网络）却被忽视了。 事实上，SmartNIC 上的组网非常复杂，因为它提供了多种通信路径。 例如，SmartNIC 支持使用 RDMA 访问主机或 SoC 的内存，以及在主机和 SoC 之间交换数据。<br>为此，本文对 SmartNIC 通信路径的性能表征进行了首次系统研究。与之前简单报告基本性能数据的研究不同，我们系统地分析了 SmartNIC 架构在不同路径上的性能影响。 具体来说，我们调查一条路径为何以及何时可能比另一条路径更快，识别每条路径的瓶颈，检查 SoC 的异构性如何在与 SoC 相关的路径中带来性能异常，并最终探索路径如何相互交互。 我们结果的主要亮点是：</p><ul><li>_不同的路径表现出不同的性能特征。_从 NIC 到 SoC 的 RDMA 路径比到主机的路径快 1.48 倍。</li><li><em>SoC 向与其相关的路径引入了新的性能异常。</em> SoC 的低级硬件细节（包括内存访问路径和 PCIe MTU）与功能更强大的主机 CPU 不同。 如果不考虑这些因素，涉及 SoC 的 RDMA 请求会遭受高达 48% 的带宽下降。</li><li>_SoC 和主机之间的路径可能未充分利用 PCIe_。 从 SoC 到主机（反之亦然）的 RDMA 两次穿过 NIC 内部 PCIe。 它只能利用一半的 PCIe 带宽，并且需要处理比其他方法多 6 倍的 PCIe 数据包。 DMA 仅通过 PCIe 一次，但由于 SoC DMA 引擎较弱（与 RNIC 上的引擎相比），它并不总是比 RDMA 更快，并且还会受到数据包放大的影响。</li></ul><p>根据我们的性能表征，我们发现先前的方法主要针对分布式系统的特定功能优化单个路径，无法充分利用 SmartNIC。 这是因为单一路径无法利用 SmartNIC 的计算和网络功能。 此外，仅考虑单个路径可能会忽略不同路径（例如，PCIe和PCIe交换机）之间的资源干扰。 因此，LineFS 只能在 200 Gbps SmartNIC 上利用高达 117 Gbps 的带宽。 基于 SmartNIC 的分解键值存储中也存在类似的问题：虽然选择将所有键值 (KV) 存储操作卸载到 SmartNIC SoC 的路径可以消除现有基于 RDMA 的键值存储中的网络放大，但 SmartNIC SoC 的计算能力限制了其整体吞吐量。<br>根据我们研究的观察结果，我们进一步提出了优化指南，以帮助设计人员巧妙地利用 SmartNIC 的多条路径。 它不是沿着单一路径优化分布式系统，而是全面利用具有不同特征的功能的多条路径，并仔细考虑交叉路径干扰。 为了证明我们指南的有效性，我们通过优化两个最先进的系统（即 LineFS 和 DrTM-KV）进行了两个案例研究。 由于暴露了新的优化空间，遵循我们的指南可以将 LineFS 和 DrTM-KV 的性能相应提高高达 30% 和 25%。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>我们的贡献总结如下：</p><ul><li>一个代表性的 off-path SmartNIC 的综合性能表征，特别关注各种通信路径。</li><li>第一个优化指南，用于智能地利用 SmartNIC 的多路径并管理跨路径资源干扰。</li><li>关于 SmartNIC 加速的分布式系统（即文件系统和键值存储）的两个案例研究具有显着的性能改进，证明了我们指南的有效性。</li></ul><h3 id="我们工作的假设和普遍性"><a href="#我们工作的假设和普遍性" class="headerlink" title="我们工作的假设和普遍性"></a>我们工作的假设和普遍性</h3><p>我们假设一个 off-path SmartNIC 具有以下架构：SoC 通过 PCIe 交换机与 NIC 核心连接，并且 SoC 和主机 CPU 之间存在异构性。 我们相信这是一个具有代表性的架构，就像许多较旧的架构（例如 NVIDIA Bluefield-、Broadcom Stingray）、当前的架构（例如 NVIDIA Innova2、Bluefield-2）和即将推出的 SmartNIC 一样 （例如，Bluefield-3、Marvell OCTEON 10 DPU）使用类似的设置。 我们在 Bluefield-2（采用这种架构的最先进的 SmartNIC）上进行了实验。 同时，我们还证实我们的结果对于 Bluefield-1 来说也是成立的。<br>然而，我们承认重大的架构变化（例如 on-path SmartNIC）可能会影响我们的发现。 尽管如此，我们认为我们的方法（首先研究每个通信路径的性能影响，然后巧妙地利用 SmartNIC 的多个路径）可以推广到其他 SmartNIC。 我们的基准测试代码、工具和系统可在 <a href="https://github.com/smartnickit-project">https://github.com/smartnickit-project</a> 上找到。</p><h2 id="背景和上下文"><a href="#背景和上下文" class="headerlink" title="背景和上下文"></a>背景和上下文</h2><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317486.png" alt="image.png"></p><h3 id="RDMA-capable-网卡-RNICs"><a href="#RDMA-capable-网卡-RNICs" class="headerlink" title="RDMA-capable 网卡 (RNICs)"></a>RDMA-capable 网卡 (RNICs)</h3><p>RDMA (远程直接内存访问) 是现代数据中心广泛采用的低延迟 (2us) 和高带宽 (200Gbps) 网络。利用 RDMA 的一种直观方法是使用其双向原语 (SEND&#x2F;RECV) 加速消息传递，例如基于 RDMA 的RPC。或者，单向原语 (READ&#x2F;WRITE) 允许 RNIC 绕过主机 CPU 访问主机内存。具体来说， NIC 内核内部使用 PCIe 链路的直接内存访问 (DMA) 特征来访问主机内存。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051318332.png" alt="image.png"><br>尽管 RDMA 提高了许多分布式系统的性能，通常是数量级的提升，它仍然存在以下两个问题，尤其是当 RNIC 扩展到更高的性能时。</p><h4 id="问题1-主机-CPU-占用"><a href="#问题1-主机-CPU-占用" class="headerlink" title="问题1 主机 CPU 占用"></a>问题1 主机 CPU 占用</h4><p>对于双向原语，分布式系统需要非平凡的 CPU 来饱和强大的 NIC。我们的测量表明，24 核服务器只能在 200 Gbps RNIC (ConnectX-6) 上每秒饱和 8700 万个数据包，而 NIC 内核可以处理超过 195 个 Mpps。最近的一项工作进一步表明，当网络带宽从 25 Gbps 扩展到 100 Gbps 时，分布式文件系统需要 2.27 倍的 CPU 核来处理网络数据包。尽管部署更多强力的 CPU 可以减轻这个问题，RNIC 的带宽也在快速地增长，目前已经达到了 400 Gbps。</p><h4 id="问题2-网络放大"><a href="#问题2-网络放大" class="headerlink" title="问题2 网络放大"></a>问题2 网络放大</h4><p>使用单向 RDMA 原语通过允许系统将内存访问卸载到 RNIC 来减轻主机 CPU 的压力。然而，有限的卸载能力约束了系统的性能，因为单个请求可能涉及多次往返 READs&#x2F;WRITE 来完成 (通常称为网络放大)。图2(a) 举例说明了在具有单向 RDMA READ 段分布式内存键值存储上执行 get request。客户端首先使用一个(或多个) READs 来查询给定键的索引。根据先前 READs 返回的索引，发出额外的 READ 来检索值。</p><h3 id="从-RNICs-到-SmartNICs"><a href="#从-RNICs-到-SmartNICs" class="headerlink" title="从 RNICs 到 SmartNICs"></a>从 RNICs 到 SmartNICs</h3><p>为了解决 RNIC 的局限性，SmartNIC 将板载内存(4-64GB)与各种计算单元(例如 SoC)添加到 NIC。通过将它们暴露给开发人员，SmartNIC 能够将定制的计算卸载到它自己身上。具体来说，SmartNIC 可以分为以下几类。</p><h4 id="On-path-SmartNIC"><a href="#On-path-SmartNIC" class="headerlink" title="On-path SmartNIC"></a>On-path SmartNIC</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317420.png" alt="image.png"><br>如图1(b)所示，on-path SmartNIC 将 NIC 内核暴露给具有低级可编程接口的系统，允许它们直接操作原始数据包。顾名思义，卸载的代码就<strong>位于</strong>网络处理管道的关键路径上。示例 NIC 包括 Marvell LiquidIO 和 Netronome Agilio。这样做的好处是卸载的代码更接近网络数据包。因此，仅与 NIC 交互的内联请求，例如写入板载内存是非常有效的。<br>然而，on-path SmartNIC 有两个局限。第一，卸载的代码与发送到主机的网络请求竞争 NIC 内核。如果将套多的计算卸载到它身上，那么发送到主机的正常网络请求就会遭受显著的退化。第二，由于 on-path SmartNIC 的低级接口，在它上面编程是比较困难的。</p><h4 id="Off-path-SmartNIC"><a href="#Off-path-SmartNIC" class="headerlink" title="Off-path SmartNIC"></a>Off-path SmartNIC</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317416.png" alt="image.png"><br>如图1(c) 所示，Off-path SmartNIC 提供了一种备选方案：它在 NIC 核心旁边的单独 SoC 中打包额外的计算内核和内存。这样一来，卸载的代码就脱离了网络处理管道的关键路径。从 NIC 的角度来看，SoC 可以被视为具有独占网络接口的第二个成熟的主机。为了将 NIC 核心、SoC 和主机连接在一起，SmartNIC 内部集成了 PCIe 交换机，用以正确地调度网络数据包。示例 NIC 包括 NVIDIA Bluefield 和 Broadcom Stingray。<br>和 on-path 的做法相比，卸载的代码不影响主机的网络性能，只要不涉及网络通信。多亏了这种清晰的分离，SoC 可以使用全网络堆栈 (即 RDMA) 运行成熟的内核 (例如 Linux)。简化系统开发和允许卸载复杂任务。然而，使用 off-path SmartNIC 加速分布式系统通常比使用 on-path 的方法更具挑战性。这是因为 PCIe 交换机延长了所有的通信路径，这导致了潜在的性能下降。</p><h3 id="Target-SmartNIC-NVIDIA-Bluefield-2"><a href="#Target-SmartNIC-NVIDIA-Bluefield-2" class="headerlink" title="Target SmartNIC: NVIDIA Bluefield-2"></a>Target SmartNIC: NVIDIA Bluefield-2</h3><p>我们对 Bluefield-2 进行了研究，一个典型的 off-path SmartNIC，用于卸载通用计算。图1(c)说明了它的整体硬件架构，详细的硬件配置如表1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317432.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317465.png" alt="image.png"></p><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><p>Bluefield-2 装配了成熟的 RNIC (ConnectX6) 作为其用于高速网络的 NIC 内核。这些内核支持所有 RDMA 操作。其可编程性来自于一块集成的板载 SoC，该 SoC 具有16GB DRAM 和 ARM Cortex-A72(8核，2.75 GHz)。PCIe 4.0 交换机将 NIC 核心、SoC和主机连接在一起，使得双向数据传输带宽高达256 Gbps。请注意，SoC 通过内部链接链接到 PCIe 交换机，而不是通过 PCIe。具体来说，Bluefield 提供的硬件计数器也意味着它只有两个 PCIe 链接：一个将 RNIC 与交换机链接 (PCIe1)，另一个将交换机与主机链接 (PCIe0)。</p><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>SoC 运行成熟的Linux，允许开发人员将其视为正常的ARM服务器。内核还托管一个完整的 RDMA 堆栈，便于启用基于 RDMA 的通信。此外，Bluefield 为高级使用提供 DOCA SDK，例如 DMA。</p><h4 id="通信原语-RDMA和DMA"><a href="#通信原语-RDMA和DMA" class="headerlink" title="通信原语:RDMA和DMA"></a>通信原语:RDMA和DMA</h4><p>使用 RDMA 进行与 SoC 相关的所有通信路径以简化系统开发。如图 1(c)所示，客户端可以向 SoC 发出单向或双向 RDMA 请求，类似于主机上的孪生服务器。与此同时，SoC 同样可以通过 RDMA 和主机交互，反之亦然。然而，在 SoC 和主机之间交换数据必须通过 RNIC (PCIe1和NIC核心) 进行 RDMA 支持，它为这条路径添加了一个隐藏的瓶颈。幸运的是，我们发现 Bluefield 进一步提供了带有 DOCA 的 DMA 支持，允许 SoC 使用 DMA 访问主机内存(反之亦然)，绕过 RNIC。</p><h4 id="探索-Bluefield-的现有状态"><a href="#探索-Bluefield-的现有状态" class="headerlink" title="探索 Bluefield 的现有状态"></a>探索 Bluefield 的现有状态</h4><p>以前的研究主要集中在 Bluefield 的计算能力和在执行卸载任务和发送网络请求方面揭示 SoC 核心的相对弱点。这是因为核心的频率和数量不如主机 CPU。由于 SmartNIC 的功率限制，NIC 和主机 CPU 之间的相对性能比较不太可能发生变化。因此，我们在调查期间将其作为前提。<br>相比之下，很少有研究考虑 Bluefield 中的各种通信模式，这是我们工作的主要焦点。Thostrup 等人发现，使用 READ 访问 <strong>SoC 内存</strong>比以相同的方式访问<strong>内存</strong>更快。iPipe 表明，由于支持 RDMA 的软件开销，使用 RDMA 在主机和 SoC 之间通信具有很高的延迟。本文系统地探讨了 Bluefield 的性能特征，总结了蔚来系统开发人员的深刻教训和建议。</p><h3 id="符号和测试平台"><a href="#符号和测试平台" class="headerlink" title="符号和测试平台"></a>符号和测试平台</h3><h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>本文在描述与Bluefield-2相关的底层硬件细节时遵循 Bluefield 的硬件规范。如图1(c)所示，“PCIe1”是指连接 NIC 核心到 PCIe 交换机的 PCIe 链路，“PCIe0”是指连接交换机和主机 PCIe 控制器的链接。ARM 核心以及 Bluefield-2 的片上存储器统称为“SoC”。托管 Bluefield-2 的机器称为“主机”。此外，我们使用术语“请求者”和“响应者”来指代分别发出 RDMA 请求和目标硬件组件的机器。例如，在图 1(c) 中，路径 ① 和 ② 的请求者是任何支持 RDMA 的机器(也称为客户端)，响应者分别是主机和 SoC。对于路径 ③，请求者和响应者分别是主机和 SoC，反之亦然。</p><h4 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h4><p>表 2 显示了我们测试平台中的机器配置。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317121.png" alt="image.png"><br>为了最好地利用 SmartNIC，我们默认在服务器 (SRV) 上部署 Bluefield-2，并匹配 PCIe 链路 (PCIe4.0)。这些机器可以将 Bluefield-2 替换为 200 Gbps ConnectX-6 (RNIC) 进行比较。其他机器 (CLI) 作为向服务器发出 RDMA 请求的客户端。SRV 和 CLIM 中的所有机器都通过 Mellanox SB7890 100 Gbps InfiniBand Switch 连接。请注意，评估的 200 Gbps NIC 的网络性能不受限制，因为它们连接到具有两个 100 Gbps 端口的交换机。</p><h2 id="描述-SmartNIC-的性能"><a href="#描述-SmartNIC-的性能" class="headerlink" title="描述 SmartNIC 的性能"></a>描述 SmartNIC 的性能</h2><p>如第 2.3 节所述，众所周知，NIC 的计算能力比主机 CPU 的计算能力更弱。因此，我们专注于分析 SmartNIC 的通信效率。图 3 显示了通过不同通信路径使用 RNIC 或 SmartRNIC 发送不同RDMA请求的端到端延迟和峰值吞吐量(例如，READ，WRITE，SEND&#x2F;RECV)。<br><strong>评估设置</strong><br>我们使用最先进的 RDMA 通信框架对表 2 中描述的集群进行了实验。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317890.png" alt="image.png"><br>对于单向操作 (READ&#x2F;WRITE)，请求者使用 RDMA 的可靠连接 (RC) 队列对 (QPs) 与一个响应器通信。响应器地址默认从 10 GB 地址空间中随机选取。对于双向操作 (SEND&#x2F;RECV)，响应器实现了一个回声服务器，它利用所有可用的核心来处理消息，请求者通过不可靠的数据报 (UD) QPs 与它通信以获得更好的性能。对于端到端延迟，我们部署了一个请求者机器来防止排队效应的干扰。对于峰值吞吐量，我们使用多达 11 个请求者机器来饱和响应器。最后，我们启用了所有众所周知的优化，包括地址对齐，无信号请求和巨大的页面，以防止误用 RDMA 的副作用。</p><h3 id="从客户端到主机的通信-路径-①"><a href="#从客户端到主机的通信-路径-①" class="headerlink" title="从客户端到主机的通信 (路径 ①)"></a>从客户端到主机的通信 (路径 ①)</h3><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>为了将通信与主机进行比较，我们对 Bluefield-2 (SNIC) 和 ConnectX-6 (RNIC)进行了比较，因为它们共享相同的 NIC 核心。它们的性能差距最好地说明了 SmartNIC 架构支付的“性能税”。如图 3 所示，SNIC ① 相较于 RNIC 在READ，WRITE，SEND&#x2F;RECV上分别有 15%-30%，15%-21% 和 6%-9% 的更高的延迟，在 SNIC 上增加的延迟主要来自于 PCIe 交换机以及主机和 NIC 内核之间的的 PCIe1。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317981.png" alt="image.png"><br>单向PCIe延迟约为300 ns，这对于小型 RDMA 请求来说并非易事(1-2 μs)。请注意，结果是间接测量的。具体来说，SNIC 和 RNIC 上的端到端读取延迟分别为 2.6 μs 和 2.0 μs。与 RNIC 相比，SNIC 上的 READ 通过两次 PCIe 交换机(见图 4)。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317752.png" alt="image.png"><br>因此，每次传递的成本约为 300 ns，这与最近文献中报道的数字相匹配。此外，WRITE 在 SNIC 上的延迟增加低于 READ，因为它的完成省略了一次通过 PCIe 交换机。SEND&#x2F;RECV 在 SNIC 上的延迟也会增加，但主要是由于响应者的 CPU 成本更大；SNIC 上发布请求（通过 MMIO）的延迟高于 RNIC（399 个循环与 279 个循环）。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>如图 3 所示，对于 READ，WRITE 以及 SEND&#x2F;RECV，对于小于 512 字节的有效负载，SNIC ① 的吞吐量分别比 RNIC ① 低 19-26%、15-22% 和 3-36%。我们怀疑较低的吞吐量是由于处理由 PCIe 交换机引起的 RDMA 请求的延迟更长。然而，对于较大的请求，结果与使用 RNIC 相似，因为两者都受到网络带宽的瓶颈。</p><h4 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h4><p>NIC、PCIe1 和 PCIe0 的最低带宽限制首先将成为从客户端到主机通信的瓶颈。在我们的测试平台上，瓶颈是网络：200 Gbps。在另一方面，我们发现了一个有趣的现象：请求者的总入站带宽可以达到限制的两倍——400 Gps——因为链接是双向的。具体来说，如果数据包以相反的方向流动，例如，图 5(a) 中的 READ 和 WRITE 数据包，它们可以在同一链路上多路复用。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317405.png" alt="image.png">为了说明这一点，我们使用两个请求者（每个都有 12 个线程来饱和单向带宽）来发出 4 KB 数据包。如图5(b) 所示，如果两个客户端分别发送 READ 和 WRITE 请求，在 200 Gbps 网卡上测量了总共 364 Gbps 的带宽(参见 SNIC ① 的 READ + WRITE)。相比之下，如果两个客户端发送相同类型的请求（要么发送 READ 要么发送 WRITE），只能测量到约 190 Gbps。请注意，尽管这种现象在传统的网络（即消息）中广为人知，其中消息通常是双向的，但许多基于 RDMA 的系统在很大程度上忽略了它，因为 RDMA 请求可以是单向的。</p><h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p>作为“智能”会导致与主机通信以进行小请求的性能下降。对于小请求，我们证明了将 RNIC(ConnectX-6) 拓展至 SNIC(Bluefield-2) 会导致吞吐量和延迟的性能下降高达 36% 和 30%。一般来说，对于仅使用路径 ① 的分布式系统，建议使用 RNIC。尽管大型请求或延迟较长的网络的开销可能可以忽略不计，RNIC 也比 SNIC 更加便宜且能效更高。</p><h3 id="从客户端到-SoC-的通信-路径-②"><a href="#从客户端到-SoC-的通信-路径-②" class="headerlink" title="从客户端到 SoC 的通信 (路径 ②)"></a>从客户端到 SoC 的通信 (路径 ②)</h3><h4 id="延迟-1"><a href="#延迟-1" class="headerlink" title="延迟"></a>延迟</h4><p>对于将请求从客户端发送到 SoC (图 3 中的 SNIC ②)，与发送到主机 (SNIC ①) 相比，READ的延迟减少了高达14%。原因是它跳过了 PCIe0。然而，它仍然比 RNIC 高 4-15%，因为请求仍然需要在 PCIe1 上通过 PCIe 交换机。对于 WRITE，由于内核的异步完成(见图 4)，SNIC ② 提供了与 SNIC ① 相似的性能。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051319504.png" alt="image.png"><br>对于 SEND&#x2F;RECV，由于 SoC 的计算能力较弱，SNIC ② 的延迟比 SNIC ① 高 21-30%。</p><h4 id="吞吐量-1"><a href="#吞吐量-1" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>SNIC ② 相比于 SNIC ① 有更好的吞吐量，对于小于 512 字节的有效负载，达到了 1.08-1.48 倍。有趣的是，在到达峰值网络带宽之前，SNIC ② 的 READ 甚至高于 RNIC ①。对于这个未文件记载的结果，我们怀疑这是由于 SoC 内存和 PCIe 交换机封装更接近。具体来说，SoC 通过内部链接链接到 PCIe 交换机，而不是通过 PCIe。请注意，自信的分析依赖于 Bluefield 的硬件细节，不幸的是现在已经不可用了。对于 WRITE，SNIC ② 仍然低于 RNIC ①。我们的假设是双重的。首先，与主机相比，SoC 的 DRAM 通道更少(1 vs. 4)，限制了写访问的并发性。然而，READ 不受影响，因为对 DRAM 的读取访问比写入访问更快。其次，SoC 只能利用一部分 NIC 内核(见第 4.1 节)。最后，SEND&#x2F;RECV 在 ② 上表现很差：它只实现了 64% 的主机性能(SNIC ①)。这是因为 SoC 的垃圾的计算能力，因为 SEND&#x2F;RECV 的吞吐量受到响应器 CPU 的瓶颈以发送回复。</p><h4 id="瓶颈-1"><a href="#瓶颈-1" class="headerlink" title="瓶颈"></a>瓶颈</h4><p>如图 1(c)所示，因为 SNIC ② 只通过 NIC 和 PCIe1 流动，瓶颈是其较低的带宽限制，这仍然是 Bluefield-2 的 200 Gbps NIC。因此，如图 5(b)所示，SNIC ② 的性能与 SNIC ① 相同，即相反方向和相同方向通信的总 400 Gbps 和 200 Gbps 带宽。<br>除了 SNIC 的基本 RDMA 性能外，我们还发现了几个因素，这些因素也可能阻止分布式系统实现上述性能。</p><h4 id="建议-1：避免倾斜的内存访问"><a href="#建议-1：避免倾斜的内存访问" class="headerlink" title="建议 #1：避免倾斜的内存访问"></a>建议 #1：避免倾斜的内存访问</h4><p>垃圾的 SoC 内核可能影响单向 RDMA 原语的内存访问表现，因为它通常比更强大的主机 CPU 内核支持更少的功能。具体来说，数据的直接 I&#x2F;O (DDIO) 由主机 CPU 广泛支持，这允许 NIC 直接 从&#x2F;向 其最后一层缓存 (LLC) 读取&#x2F;写入数据，如图 6 所示。<img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317317.png" alt="image.png"><br>SoC 内核还可以配备类似的功能（例如，ARM CCI），但是否这样做是特定于供应商的。我们的硬件 SoC 核心(Bluefield-2 中的 ARM Cortex-A72)不支持 DDIO。我们发现没有 DDIO 的单向 RDMA 容易受到倾斜内存访问的影响——请求的内存地址落在一个小范围内。这是因为 DRAM 需要一个（不是太小的范围）来同时利用所有内存模块。LLC 比 DRAM 快，因此我们怀疑它可以更好地容忍偏斜的访问。<br>图 7 显示了随着地址范围的增加，通过 SNIC 访问主机内存和 SoC 内存的峰值吞吐量。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317190.png" alt="image.png"><br>对于 WRITE，当地址范围减小到 1.5 KB（来自 48 KB）时，使用 SoC 的 SNIC ② 的吞吐量下降到 22.7 M reqs&#x2F;s（从 77.9 M reqs&#x2F;s）。相比之下，当启用 DDIO 时，使用主机 CPU 的 SNIC ① 的性能几乎没有受到影响。对于 READ，性能退化相对较小。当范围从 48 KB 降低到 1.5 KB 时，SNIC ② 的吞吐量从 85 M reqs&#x2F;s 下降到 50 M reqs&#x2F;s。这是因为 DRAM 可以比写入更快地服务于读取。最后，我们还将 RNIC 结果绘制为参考。在倾斜的工作负载下，我们可以看到，当禁用 DDIO 时，① 在 WRITE 上也有显著的性能下降。</p><h4 id="建议-2：避免大的-READ-请求"><a href="#建议-2：避免大的-READ-请求" class="headerlink" title="建议 #2：避免大的 READ 请求"></a>建议 #2：避免大的 READ 请求</h4><p>通常使用具有大有效载荷的请求来充分利用网络带宽是很常见的。例如，使用有效载荷大于 16 KB 的请求足以饱和 200 Gbps RNIC，即使只使用一些线程。不幸的是，我们观察到 SNIC ② 的 READ 性能随着请求有效负载大于 9 MB 而崩溃，如图 8(a) 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051320277.png" alt="image.png">我们怀疑在处理大型 READ 请求时，NIC 内核会受到 head-of-line 阻塞的影响。对于 READ 请求，NIC 发出一个 PCIe 读取事务以获取数据，然后将其进一步分割成多个 PCIe 数据包。PCIe 数据包的最大大小由 PCIe 最大传输单元(MTU)决定，该单元由引导过程中连接的硬件设备协商。表 4 列出了我们测试平台上的 PCIe MTU。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317317.png" alt="image.png"><br>SoC 内核（SNIC ② 的终点）由于其较弱的 CPU，使用更小的 PCIe MTU (128 B)。因此，处理发送到 SoC 内存的大型 DMA 读取的 NIC 核心 (SNIC ②) 必须等待更多的 PCIe 数据包到达，从而导致冗长的处理停顿。由于整体 NIC 包处理能力不是瓶颈：如图 8(b) 所示，有效载荷小于 9 MB 的请求仍然可以实现高处理速度，而对于大于 9 MB 的请求崩溃，因此我们怀疑一些阻塞发生在 NIC 核心。请注意，WRITE 请求不受影响，因为 DMA 不等待完成。<br>相反，主机使用更大的 PCIe MTU (512 B)，因此它不会受到带宽退化的影响(SNIC ①)。如图 8(b) 所示，NIC 每秒可以向主机发出 46.7 万个 PCIe 数据包（SNIC ①）。聚合带宽达到 191 Gbps，其瓶颈是网络。</p><h4 id="附-1"><a href="#附-1" class="headerlink" title="附"></a>附</h4><p>对于 READ 和 WRITE，将请求发送到 SoC 通常比发送到主机更快(或者甚至比通过 RNIC 更快)因为SoC“更接近”NIC(在没有 PCIe0的时候)。相比之下，由于 SoC 核心较弱，使用 SEND&#x2F;RECV 与 SoC 通信速度较慢。此外，设计人员仍然需要仔细考虑主机 CPU 内核和 SoC 内核之间的异质性，以避免性能异常。具体来说，由于缺乏 SoC 核心中的 DDIO 支持，倾斜的内存访问可能会降低性能。此外，向 SoC 发送大型 READ 请求可能无法利用带宽，因此应主动将请求分割成更小的请求。</p><h3 id="SoC-与主机之间的通信-路径-③"><a href="#SoC-与主机之间的通信-路径-③" class="headerlink" title="SoC 与主机之间的通信(路径 ③)"></a>SoC 与主机之间的通信(路径 ③)</h3><p>我们首先描述了我们对 RDMA 的测量和发现，然后将 RDMA (③) 与 DMA (③*) 进行比较。</p><h4 id="延迟-2"><a href="#延迟-2" class="headerlink" title="延迟"></a>延迟</h4><p>如图 3 所示，将请求从 SoC 发送到主机 (SNIC ③ S2H) 的延迟非常高，特别是对于 READ，因为请求者 (SoC) 需要更长的时间来向 NIC 发出 RDMA 请求。相反的方向（从主机到 SoC、SNIC ③ H2S）的延迟降低，但仍比 SNIC ② 高 4-17%。虽然机器内通信节省了一个网络往返，但它增加了额外的 PCIe 传输。具体来说，SNIC ② 发出的请求的流向是：请求者端的 PCIe(没在图 1(c)中展示)-&gt;网络-&gt;PCIe1-&gt;PCIe 交换机，而 SNIC ③(H2S)发出的请求的流向是PCIe0-&gt;PCIe 交换机-&gt;PCIe1 两次(进入一次，出去一次)-&gt;PCIe交换机(再次)。</p><h4 id="吞吐量-2"><a href="#吞吐量-2" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>对于有效载荷小于 512 字节的请求，SNIC ③（S2H 和 H2S）的吞吐量主要由请求者发布网络请求的能力决定。这是因为单个请求者机器（SoC 或主机）无法用小请求饱和 NIC，SNIC ③ 的 READ 吞吐量仅达到 29 M reqs&#x2F;s 和 51.2 M reqs&#x2F;s（分别对 S2H 和 H2S），仍然离它的限制很远。对于 WRITE 和 SEND&#x2F;RECV，结果相似。对于更大的请求，它们受到 PCIe 带宽的瓶颈，这将在下一节中更详细地讨论。</p><h4 id="瓶颈-2"><a href="#瓶颈-2" class="headerlink" title="瓶颈"></a>瓶颈</h4><p>如图 5(b) 所示，对于以单一方向流动的数据包，主机与 SoC 之间的通信受到 PCIe 带宽的瓶颈(256 Gbps)而不是未涉及的 NIC(200 Gbps)。因此，SNIC ③ 的峰值带宽略高于 SNIC ① 和 ②(204 Gbps vs. 191 Gbps)。读者可能对为什么 SNIC ③ 的结果不能接近 256 Gbps 感兴趣。我们怀疑它需要比其他数据包多得多的 PCIe 数据包。对于以相反方向流动的数据包，SNIC ③ 不能像其他的路径那样利用两次限制(即 SNIC ① 和 ②)。这是因为 RDMA 过度使用 PCIe：每个请求两次通过 PCIe1 (进入一次，出去一次)，耗尽了双向链路。</p><h4 id="建议-3：避免大型-READ-WRTIE-请求"><a href="#建议-3：避免大型-READ-WRTIE-请求" class="headerlink" title="建议 #3：避免大型 READ&#x2F;WRTIE 请求"></a>建议 #3：避免大型 READ&#x2F;WRTIE 请求</h4><p>主机和 SoC之间(SNIC ③)的通信也会受到如 SNIC ② 的大型 READ 请求的带宽退化影响，可能是由于我们之前讨论过的 head of line 阻塞。此外，这个问题出现在大型 WRITE 请求中，因为 SmartNIC 必须首先从请求者读取数据，然后将其写入响应器。如图 9(a)，SNIC ③ 的 READ&#x2F;WRITE 性能对于较大的请求崩溃到大约 100 Gbps。表 4 显示了通过不同通信路径传输 N 个字节所需的 PCIe 数据包的数量。对于 SNIC ③，由于通过 PCIe1 两次，NIC 生成更多的数据包。此外，S2H 的性能比 H2S 更早崩溃，因为它将首先通过 PCIe1。假设我们将数据以 200 Gbps 从 SoC 传输到主机。SoC 核心首先每秒传输195 M 个 PCIe 数据包到 NIC(PCIe1)，然后 NIC 再次通过 PCIe1 将数据以 49 Mpps 转发到 PCIe 交换机(主机支持 512 B MTU)，最终，交换机通过 PCIe0 转发49 Mpps 的数据。因此，SmartNIC 应该至少以 200 Gbps 的带宽处理 293 Mpps 的数据，这是 SNIC ① 的3倍，是 SNIC ② 的 2 倍。我们的硬件计数器测量进一步证实了这一点。如图 9(b) 所示，为了将 256 KB READ 请求从 SoC 发送到主机，带宽达到 204 Gbps，NIC 每秒传输大约 320 M PCIe 数据包。</p><h4 id="建议-4：小心地启用门铃批处理"><a href="#建议-4：小心地启用门铃批处理" class="headerlink" title="建议 #4：小心地启用门铃批处理"></a>建议 #4：小心地启用门铃批处理</h4><p>将每个请求发布到 NIC 的时间主要由 MemoryMapped IO(MMIO) 决定。在与主机通信时，SoC 遭受高 MMIO 延迟(见图 10(a))。已知的优化是门铃批处理 (DB)：要发送一批 B 个请求，请求者首先在内存中将它们链接在一起，然后使用一个 MMIO 要求 NIC 以 CPU 旁路方式使用 DMA 读取这些请求。DB 将需要 MMIO 的次数从 B 减少到了 1。因此，对于 RNIC ① 和 SNIC ②，DB 总是有帮助的，可以带来 2-30% 的性能提升(见图 10(b))。对于主机与 SoC 之间的通信(SNIC ③)，DB 仍然有助于 SoC 端。如图 10(b) 所示，当向主机发送一批 READ 时，DB 在批量大小为 16-80 的情况下将 SoC 性能提高了 2.7-4.6 倍。巨大的改进部分是由于 DMA 的 CPU 旁路特性，而且因为 NIC 在使用 DMA 读取存储在 SoC 内存上的请求时更快(见 3.2节)。然而，DB并不总是有助于主机端，因为它在通过 NIC DMA 读取主机内存的时候更慢了(见 3.1 节) 。对于 16、32、48 的批量大小，DB 将从 主机到 SoC 的通信的吞吐量分别降低了 9%、7% 和 6%。</p><h4 id="RDMA-③-vs-DMA-③"><a href="#RDMA-③-vs-DMA-③" class="headerlink" title="RDMA(③) vs. DMA(③*)"></a>RDMA(③) vs. DMA(③*)</h4><p>除了 RDMA 之外，SoC 还可以通过 SoC 内部的 DMA 引擎使用 DMA (➂*) 从主机读取&#x2F;写入数据（反之亦然）。与 RDMA 相比，它具有减少两次 PCIe 通道 (PCIe1) 和绕过 RNIC 的优点（见图 1），从而降低延迟，例如，64 B SoC 到主机 READ 的延迟为 1.9 μ 与 2.6 μ。然而，我们发现 SoC DMA 引擎的处理能力比 RNIC(RDMA) 弱。为简洁起见，我们只展示了SoC到主机的结果。主机到 SoC 的结果与 SoC 到主机的结果相同，因为主机 DMA 已卸载到 SoC 执行。如图 11 所示，对于 WRITE ，对于有效载荷小于 4 KB 的请求，DMA 的峰值吞吐量仅为 RDMA 的47-59%。READ 的结果相似。DMA WRITE 甚至无法在 16 KB 和 1 MB 之间饱和有效载荷的 PCIe 限制 (256 Gbps)。我们怀疑这是由于 SoC 的 DMA 引擎的处理能力较差，但我们无法在不了解 SoC 的机密内部设计的情况下确认这一点。带宽结果的另一个观察结果是 DMA 也存在 RDMA 的异常(见 建议 #3)：对于大于 1 MB 的有效负载，READ 和 WRITE 的性能都显着下降。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317513.png" alt="image.png"><br>对于带宽，③* 相较于 ③ 有着更高的理论上限：它受到 PCIe 的双向带宽的瓶颈，因为它绕过了 PCIe1。但是，图 5 显示它无法做到这一点(READ + WRITE 只有178Gbps)。这表明缓慢的 DMA 引擎首先将成为瓶颈。然而，绕过 PCIe1 仍然具有减少对其他路径干扰的好处。我们将在第 4 节中详细讨论它们。</p><h4 id="附-2"><a href="#附-2" class="headerlink" title="附"></a>附</h4><p>首先，启用门铃批处理对于 SoC 端的 SNIC ➂ 至关重要，因为 SoC 的计算能力较弱。然而，对于小批量，它在主机端受到负面影响。其次，SNIC ➂ 具有与 SNIC ➀ 和 SNIC ➁ 不同的瓶颈。它总是受到 PCIe 单向带宽的瓶颈，而其他则受到网络和 PCIe 最小双向带宽的限制。如果这个因素没有被充分考虑，分布式系统将没有充分利用 NIC 带宽（见第 5.1 节）。第三，尽管 DMA 比 RDMA 更好地利用 PCIe 进行 SoC 与主机通信，但由于 SoC 上的 DMA 引擎较弱，吞吐量较低。最后，我们应该避免在主机和 SoC 之间传输大型请求，对于 RDMA 和 DMA 以及 READ 和 WRITE。</p><h2 id="一种智能地利用-SmartNIC-多条路径的指导方针"><a href="#一种智能地利用-SmartNIC-多条路径的指导方针" class="headerlink" title="一种智能地利用 SmartNIC 多条路径的指导方针"></a>一种智能地利用 SmartNIC 多条路径的指导方针</h2><p>以前的方法主要利用 SmartNIC 的单一路径来优化分布式系统的特定功能。 然而，这并不能充分利用SmartNIC的计算和网络能力。 此外，仅考虑单个路径可能会忽略不同路径之间的资源（例如，PCIe 和 PCIe 交换机）的干扰。 因此，我们首先全面研究同时使用多路径的性能特征，然后为设计人员巧妙地使用 SmartNIC 制定优化指南。</p><h3 id="描述并发通信路径"><a href="#描述并发通信路径" class="headerlink" title="描述并发通信路径"></a>描述并发通信路径</h3><h4 id="与主机和-SoC-的并发通信-①-②"><a href="#与主机和-SoC-的并发通信-①-②" class="headerlink" title="与主机和 SoC 的并发通信(① + ②)"></a>与主机和 SoC 的并发通信(① + ②)</h4><p>我们专注于吞吐量结果(参见图 3 的下半部分)因为延迟结果大致是两条路径的平均值。我们通过分配一半的客户端向主机发送请求，而其他客户端发送到 SoC 来评估峰值吞吐量。我们可以看到，同时使用 ➀ 和 ➁ (SNIC ➀+➁) 的总峰值吞吐量通常比它们各自更快。对于 READ、WRITE 和 SEND&#x2F;RECV，SNIC ➀+➁ 的性能分别比其中较低者高出 1.45×、1.50× 和 3.3×。<br>对于 SEND&#x2F;RECV，并发路径利用主机和 SoC 来处理请求，因此性能改进很明显。然而，READ&#x2F;WRITE 性能改进是不直观且无证的，因为两条路径会竞争 NIC 内核。我们的怀疑是 SmartNIC 在内部为每个端点保留一些 NIC 内核。因此，同时向主机发送请求和 SoC 可以通过启用更多的 NIC 内核来进一步提高峰值吞吐量。为了量化这一点，我们设计了一个微基准，它首先增加请求者机器饱和 NIC，然后更改响应器，如图12所示。<img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317037.png" alt="image.png"><br>所有请求都使用 0 B 有效负载来避免 DMA 的干扰，即在通过 PCIe1 之前请求将返回。对于 READ，单独使用 SNIC ➀ 或 SNIC ➁ 时，五个请求者计算机足以使 NIC 核心饱和。因此，为了同时使用 SNIC ➀ 和 SNIC ➁，我们首先为一个响应者专用 5 台请求者机器，然后为另一个响应者添加请求者。两种情况（SNIC ➀+➁ 和 SNIC ➁+➀）提供相似的性能，与单独使用 SNIC ➀ 或 SNIC ➁ 相比，吞吐量分别提高 4–13% 和 5–10%。对于 WRTIE，所有结果都几乎相同。<br>最后，正如预期的那样，两条路径（SNIC ➀ 和 SNIC ➁）的聚合吞吐量远高于同时使用它们的吞吐量（352 Mpps vs. 195 Mpps），这表明大多数 NIC 核心仍然是共享的，即每一个 NIC 核心都可以与两个端点通信，只有少数是专用的。这也意味着同时使用 SmartNIC 的多个资源并非易事。</p><h4 id="并行机器间和机器内通信-➀-➁-➂"><a href="#并行机器间和机器内通信-➀-➁-➂" class="headerlink" title="并行机器间和机器内通信 (➀&#x2F;➁+➂)"></a>并行机器间和机器内通信 (➀&#x2F;➁+➂)</h4><p>机器间和机器内通信存在四种并发组合。为了简洁起见，我们重点关注 SNIC ➀+➂&#x2F;H2S 的结果，其他组合类似。为了研究两条路径的并发使用，我们首先部署足够的客户端（五台请求者机器）以使 SNIC ➀ 的网络饱和。然后，我们在主机（一台有 24 个线程的机器）上启动请求程序，将 RDMA 请求发送到 SoC (SNIC ➂&#x2F;H2S)。我们的测量表明，同时启用机器内通信会降低机器间通信的性能。如图 3 所示，通过比较 SNIC ➀ 和 SNIC➀ + ➂(H2S) ，对于 READ、WRITE 和 SEND&#x2F;RECV，小请求（小于 512 字节）的吞吐量下降了 7–15%、4–27% 和 9–14%。对于大请求，性能总是受到网络带宽的瓶颈，因此退化可以忽略不计。<br>SNIC ➂ 影响 SmartNIC 的其他通信路径，因为它依赖 NIC（PCIe1 和 PCIe 交换机）来支持 RDMA。相比之下，SNIC ➂* 通信可以利用 DMA 来减少此类干扰。例如，对于有效负载为 16-64 B 的 READ，在将 SNIC ➂* 添加到 ➀ 后，我们仅观察到吞吐量下降了 5-6%。</p><h4 id="瓶颈-3"><a href="#瓶颈-3" class="headerlink" title="瓶颈"></a>瓶颈</h4><p>假设每条路径只有一种类型的请求，例如 READ 或 WRITE。对于 SNIC ➀+➁，每个部分都有相同的瓶颈（NIC），因此带宽限制为 400 Gbps（双向）。对于 SNIC ➀+➂，它受到 SNIC ➂ 的瓶颈，由于它占用了 PCIe1 的两个方向，因此受到 PCIe 单向（256 Gbps）的限制（见图 5（b））。然而，如果 SNIC ➀ 以相反的方向使用（即 READ 和 WRITE），SNIC ➀+➂ 可以达到更高的限制。例如，如果我们将 SNIC ➂ 上的数据传输带宽限制为 56 Gbps，聚合带宽可以达到 456 Gbps（理论上）。这表明有选择地将一小部分数据卸载到 SoC 可能是最佳的。最后，如果可能的话，通常最好将 SNIC ➀ 或 ➁ 与 DMA (➀&#x2F;➁+➂*) 结合使用，尽管 DMA 比 RDMA 慢（参见第 3.3 节）。这是因为 DMA 具有更好的 PCIe 利用率（不通过 PCIe）和 RNIC 利用率（不使用 RNIC）。</p><h4 id="附-3"><a href="#附-3" class="headerlink" title="附"></a>附</h4><p>同时从客户端向主机和 SoC 发送请求 (SNIC ➀+➁) 可以更好地利用 NIC 内核来处理小型 RDMA 请求，特别是在相反方向使用时（例如，一个用于读取，一个用于写入）。 相反，不受控制地使用机器内（主机-SoC）通信 (SNIC ➂) 可能会损害机器间通信，而这正是使用 SmartNIC 的内在目的。 具体来说，如果 PCIe 的单向带宽小于 NIC 的双向带宽，则使用 SNIC ➂ 可能会引入隐藏的瓶颈。 因此，我们应该始终仅在有空闲资源时才考虑使用 SNIC ➂。 具体来说，如果机器建通信使 NIC 饱和，则SNIC ➂ 使用的带宽不应大于 P−N，其中 P 和 N 分别是 PCIe 和网络的限制。 例如，在我们的测试台上它应该是 56 Gbps。 使用 SNIC ➂* 可以减少路径之间的干扰，但 SNIC ➂* 也有局限性：它比 SNIC ➂ 慢。<br>最后，在现实世界的分布式系统中，单个通信路径无法完全饱和 SmartNIC 的所有资源是很常见的。 例如，SNIC ➁ 是最快的，但受到 SoC 内存较小和较弱内核的限制。 另一方面，仅使用 SNIC ➀ 作为 RNIC 会浪费 SoC 上的所有资源。 因此，我们应该同时使用 SmartNIC 提供的多条路径，但要小心避免它们之间的干扰。</p><h3 id="优化指南"><a href="#优化指南" class="headerlink" title="优化指南"></a>优化指南</h3><p>本节介绍我们的优化指南，以智能地利用 SmartNIC 的多个通信路径来提高分布式系统的性能。 具体来说，考虑到需要通过 SmartNIC 加速的目标分布式系统的功能（例如分布式文件系统中的文件复制），我们建议设计人员考虑以下步骤：</p><ol><li>设计 SmartNIC 的潜在替代方案来支持给定的功能，并根据我们研究发现的性能特征对其进行优化。</li><li>根据系统特定标准对备选方案进行评估和排名。</li><li>依次选择和组合替代方案，直到 SmartNIC 的资源饱和。</li></ol><h4 id="系统特定的标准"><a href="#系统特定的标准" class="headerlink" title="系统特定的标准"></a>系统特定的标准</h4><p>标准可以是系统设计者想要实现的理想属性，也可以是系统的限制。对于分布式文件系统中的复制，其属性包括低主机 CPU 开销和高网络带宽利用率。对于分解的键值存储，其属性包括较少的网络放大、低延迟和高吞吐量。主机只有很少或没有CPU可供我们使用的限制。</p><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>我们目前仅以贪婪的方式考虑替代方案的组合，这对于现实世界的分布式系统中的大多数网络功能来说已经足够了。此外，SmartNIC 通常提供有限数量的可用选项。请注意，有效地组合替代方案具有挑战性。对于不同的系统，不同的替代方案可能会消耗 SmartNIC 上的不同资源，而它们的组合可能会涉及不同级别的资源争用。我们之前的分析（包括不同通信路径的瓶颈以及同时利用 SmartNIC 上的多个路径）将指导设计人员避免大多数性能争用。然而，如何系统地选择和组合不同的路径是我们未来的工作。</p><h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><p>为了证明我们的研究和优化指南的有效性，本节介绍了两个详细的案例研究。</p><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>文件复制是分布式文件系统中容错的关键支柱。随着 RDMA 和非易失性存储器（NVM）的出现，一个吸引人的趋势是使用 RDMA 直接复制远程 NVM 上的文件更新以获得更好的性能，即 RDMA 原语可以直接写入 NVM 就像 DRAM 一样，网络和 NVM 带宽得到充分利用。</p><h4 id="制定替代方案"><a href="#制定替代方案" class="headerlink" title="制定替代方案"></a>制定替代方案</h4><p>文件复制的理想特性是高性能、高网络利用率和低主机 CPU 开销。在我们的 SmartNIC 上实现文件复制有三种替代方案，如图 14 所示。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317194.png" alt="image.png"></p><ol><li>替代方案1</li></ol><p>它来自 SmartNIC 上最先进的分布式文件系统 LineFS，它将文件复制完全卸载到 SoC。SoC 将压缩并复制文件，以减少通过网络传输的数据，同时主机 CPU 使用率较低。收到复制请求后，主 SoC 从主机读取文件 (➂)，对其进行压缩 (➃)，然后通过链式复制将文件写入远程备份。具体来说，如果有多个备份，第二个备份会进一步将日志重新复制到链上的下一个备份，以此类推。</p><ol start="2"><li>替代方案2</li></ol><p>根据我们的研究，我们可以将 A1 中的 ➂ 替换为 ➂*，以减少对 PCIe 带宽（特别是 SmartNIC 上的 PCIe1）的干扰。</p><ol start="3"><li>替代方案3</li></ol><p>主机可以使用 WRITE (➀)直接将文件从主机写入远程备份。 请注意，此方法通常会跳过文件压缩，以防止产生不小的主机 CPU 开销（参见图 13 (a)）。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317272.png" alt="image.png"></p><h4 id="基线"><a href="#基线" class="headerlink" title="基线"></a>基线</h4><p>LineFS 是一个基于 NVM 和 SmartNIC 的最先进的分布式文件系统。 它采用 A1来复制文件。 我们在其开源代码库上进一步实现了 A2 和 A3，并使用更高效的 RDMA 实现重写其后端，以扩展到 200 Gbps 网络的网络带宽，例如使用异步和批量 RDMA 操作。</p><h4 id="对每个替代方案进行优化"><a href="#对每个替代方案进行优化" class="headerlink" title="对每个替代方案进行优化"></a>对每个替代方案进行优化</h4><p>默认情况下，LineFS 在 A1 的开源代码库中采用 16 MB 的块大小。根据第 3.3 节中描述的建议#3，我们将其缩小到 256 KB，以获得比 ➂ 更好的性能。该优化进一步适用于 A2 和 A3。</p><h4 id="分析替代方案"><a href="#分析替代方案" class="headerlink" title="分析替代方案"></a>分析替代方案</h4><p>A1 是卸载文件复制的最直接方法，减少了通过网络传输的数据(d vs. d x ratio)。因此，理想的峰值带宽是 N&#x2F;ratio，其中 N 是 SmartNIC 的带宽限制。 然而，A1 没有考虑 ➂（第3.3节）昂贵的 PCIe 占用，甚至无法使文件传输的网络带宽饱和。将主设备的 PCIe 限制 (uni) 表示为 P 。A1 的文件传输带宽 d 受到 $\frac{p}{1 + ratio}$ 的限制，因为每个数据包必须经过 PCIe1 out 链路两次。如图 14 所示，一个是从 SoC 到 RNIC（d 字节），另一个是从 SoC 到远程（d × ratio 字节）。在我们的平台上（p &#x3D; 256 Gbps），因此当压缩率低于 28% 时，A1 仅比文件未压缩（其性能受到网络瓶颈 N &#x3D; 200 Gbps）更好。更糟糕的是，当遇到不好的压缩率（≥28%）时， A1 无法使 SmartNIC 的网络带宽饱和。例如，在不压缩的情况下（ratio &#x3D; 1），A1 的峰值仅为 128 Gbps。<br>图 13 (b) 展示了 A1 在 LineFS 文件写入基准测试上的结果。此基准测试不压缩文件。我们可以看到，当主机空闲时，A1 仅使用 8 个客户端实现了 117 Gbps。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317549.png" alt="image.png"><br>A2 通过将 ➂ 替换为 ➂* 解决了 A1 较差的 PCIe 利用率问题。如图 13 (b) 所示，在不同客户端数量下，A2 比 A1 快 1.01–1.13 倍。然而，由于以下两个原因，A2 未能达到接近 200 Gbps 的结果（峰值为 133 Gbps）。首先，➂* 的 WRITE 无法充分利用我们平台上的全部 PCIe 带宽（见图 11）。<img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317876.png" alt="image.png"><br>其次，SoC 计算能力较差也可能成为文件复制的性能瓶颈。A3 绕过了 A1 的 PCIe 占用问题，以及 A2 的 DMA  WRITE 慢和 SoC 弱的问题。同时，其数据路径较短（见图14）。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051321414.png" alt="image.png">如图13(a)所示，与 A2 相比，A3 等待日志确认的时间缩短了 40%。结果，在不同的客户端设置下，A3 的复制带宽比 A2 快 5–41%。缺点是即使不考虑压缩（文件系统），A3 也会占用更多 CPU 周期，见图 13(a)。这是因为 A1 和 A2 能够消化 SoC 上的文件日志。因此，与 A2 相比，A3 的总体处理时间减少了 8%（A3 等待日志确认的时间缩短了 40%，总体看上去减少了 8%）。</p><h4 id="选择并组合替代方案"><a href="#选择并组合替代方案" class="headerlink" title="选择并组合替代方案"></a>选择并组合替代方案</h4><p>由于 A2 总是比 A1 好，所以我们只会考虑将 A2 与 A3 结合起来。 正如我们之前分析过的，A3 比 A2 更快。 因此，增加组合路径 (A2 + A3) 中 A3 的比率始终会提高性能，如图 15 所示。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317677.png" alt="image.png"><br>但是，如果启用高网络利用率的文件压缩，则主机 CPU 利用率很高，如图 13 (a) 所示。禁用 A3 压缩将降低网络利用率，同样展示在图 15 中。具体来说，当增加客户端中路径 A3 的百分比时，考虑到固定的 50% 压缩比，网络利用率从 50% 降低到 0%。<br>考虑到 A2 具有更好的网络利用率，我们采用贪心的方法，首先用 A2 使 SoC 饱和，以获得更好的网络利用率。之后，客户端使用 A3 进行文件复制。这种方法可以实现两全其美：组合路径比 A2 更快，网络利用率比 A3 更好。</p><h4 id="评估结果"><a href="#评估结果" class="headerlink" title="评估结果"></a>评估结果</h4><p>图 13 (b) 和 (c) 分别进一步展示了主机 CPU 空闲和繁忙时 A2 + A3 的文件复制基准测试结果。我们遵循与 LineFS 基准测试相同的设置，并向主机 CPU 添加 CPU 密集型工作负载（streamcluster）以模拟繁忙的实验设置。当 CPU 空闲和繁忙时，A2 + A3 分别比原始 LineFS 快 7–30% 和 4–21%，得益于 SmartNIC 的更高效使用以及多个执行路径的智能利用。</p><h3 id="分解的键值存储"><a href="#分解的键值存储" class="headerlink" title="分解的键值存储"></a>分解的键值存储</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>基于 RDMA 的分类键值存储 (R-KVS) 在现代数据中心中很普遍。在 R-KVS 中，一个或多个内存服务器存储索引（通常是哈希表）和值。其他机器上的客户端使用 READ 来遍历索引并检索相应的值来处理请求（即 get），请参见图 16 中的 A1。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317361.png" alt="image.png"></p><h4 id="制定替代方案-1"><a href="#制定替代方案-1" class="headerlink" title="制定替代方案"></a>制定替代方案</h4><p>期望的特性是高吞吐量、低延迟和最小的网络放大。限制是我们几乎不能使用主机 CPU（即禁用路径 ➀ 的 SEND&#x2F;RECV）。SmartNIC 为 R-KVS 提供了五种替代方案，如图 16 所示。</p><ol><li>替代方案1</li></ol><p>客户端将 SmartNIC 视为普通 RNIC，并使用 READ 来处理获取请求 (➀)。 这种方法会受到网络放大的影响。</p><ol start="2"><li>替代方案2</li></ol><p>一种直观的卸载方法是使用 SEND&#x2F;RECV (➁) 将获取请求发送到 SoC。 然后，SoC 可以遍历索引并通过 RDMA 或 DMA READ 读取主机上的值。 这种方法有效地消除了网络放大。</p><ol start="3"><li>替代方案3</li></ol><p>A2 的一个缺点是从 SoC 读取数据到主机比从主机本地内存读取数据要慢。一种优化是将索引卸载到 SoC 内存 (➃)。这种方法类似于客户端的索引缓存，但在 SmartNIC 缓存索引更有效。每个客户端都有一个较小的内存，只能缓存分解设置中的数百个条目，而 SmartNIC 具有相对较大的 SoC 内存（例如 Bluefield-2 上的 16 GB），可以缓存所有索引。</p><ol start="4"><li>替代方案4</li></ol><p>使用 SEND&#x2F;RECV (➁) 访问 SoC 上的索引无法充分利用 SmartNIC 的 NIC 内核，因为 SEND&#x2F;RECV 的峰值吞吐量仅为 21.6 M reqs&#x2F;s。因此，我们可以使用 READs 来遍历 SoC 上的索引 (➁)，并使用另一个 READ 来检索主机上的值 (➀)。这种方法仍然具有网络放大的效果，但可以利用快速路径 (➁) 来提高性能（参见 3.2 节）。</p><ol start="5"><li>替代方案5</li></ol><p>与索引缓存类似，SoC 内存可以进一步缓存一部分值（例如热键的值）。这种方法避免了使用先前替代方案中昂贵的通信路径 (➂)。</p><h4 id="基线-1"><a href="#基线-1" class="headerlink" title="基线"></a>基线</h4><p>DrTM-KV 是针对 RDMA 优化的最先进的 KV 存储：它采用簇链接哈希索引，这样客户端通常可以在一次读取中找到给定键的值位置。具体来说，对于一个 get 请求，客户端首先读取一个 64B 的 bucket（基于 key 的 hash ），找到其中对应值的远程地址，然后用另一个READ来获取该值。DrTM-KV 支持客户端索引缓存以跳过第一个 READ，但由于内存限制，它在分解的环境中可能并不总是可行，因此我们禁用它。</p><h4 id="对每个替代方案进行优化-1"><a href="#对每个替代方案进行优化-1" class="headerlink" title="对每个替代方案进行优化"></a>对每个替代方案进行优化</h4><p>我们根据我们的研究 (第 3 节) 在 DrTM-KV 上实施 A1–A5。具体来说，我们仔细地为与 SoC CPU（A2、A3 和 A5）相关的替代方案启用了门铃批处理。此外，我们对 A4 和 A5 应用建议 #1，将一些热键复制到多个副本中以抑制偏差。我们使用 DMA (➂*) 而不是 RDMA (➂) 来实现 A2 和 A3，因为它由于较低的延迟而总是更快。例如，使用 ➂*，A2 吞吐量提高了 79%。 A2 和 A3 不会受到第 3.3 节中发现的低 DMA 吞吐量的影响，因为 SoC 将首先成为瓶颈。</p><h4 id="分析替代方案-1"><a href="#分析替代方案-1" class="headerlink" title="分析替代方案"></a>分析替代方案</h4><p>我们在所有实验中使用 YCSB C（100% get）和默认 Zipfian 请求分布（θ &#x3D; 0.99）。键和值的有效负载大小分别为 8 B 和 64 B，与之前的工作类似。在微基准设置之后，我们使用一台客户端计算机来测量延迟，并部署多达 11 台客户端计算机来测量峰值吞吐量。<br>图 17 表明没有任何路径可以同时实现高吞吐量和低延迟。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317396.png" alt="image.png"><br>A5 (SEND&#x2F;RECV) 实现了最低延迟 (4.6 μs)，因为它完全消除了网络放大问题和昂贵的主机 SoC 通信 (➂)。然而，其峰值吞吐量（17.6 M req&#x2F;s）明显低于其他一些替代方案。具体来说，A5（READ）和A4的峰值吞吐量分别达到70M reqs&#x2F;s和58.3M reqs&#x2F;s。它们具有更高的吞吐量，因为到 SoC 的 RDMA (➀) 路径更快（第 3.2 节）。请注意，A5 并不总是可以实现，这需要在 SoC 内存中缓存所有键值。因此，如果 SoC 内核成为瓶颈，A4 是合适的设计 (➃)。A1 比 A4 具有更高的延迟和更低的吞吐量，因为到主机的RDMA (➀) 相对较慢。A2 和 A3 受到缓慢的主机-SoC 通信的瓶颈（➂，请参阅第 3.3 节），这不适合卸载 KV 存储请求。</p><h4 id="选择并组合替代方案-1"><a href="#选择并组合替代方案-1" class="headerlink" title="选择并组合替代方案"></a>选择并组合替代方案</h4><p>我们的分析表明最佳组合是 A4 和 A5。最初，前几个客户端使用 A5，而后面的客户端则使用 A4。准确的切换点可以通过使用排队理论来对 SoC 的容量和 RNIC 的功能进行建模来估计，如之前的工作一样。<br>此外，使用 A5 也带来了挑战，因为客户端不知道 SoC 中缓存了哪些值。尽管 A3 可以用作缓存未命中的后备路径，但它会导致性能显着下降（参见图 17）。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312051317837.png" alt="image.png"><br>为了解决这个问题，我们提供了一个简单的解决方案：当发生缓存未命中时，SoC 将值的地址返回给客户端，然后客户端发出 READ 指令来检索相应的值，类似于 A4。在现实世界的倾斜工作负载中（例如，YCSB），缓存未命中的情况很少见。</p><h4 id="评估结果-1"><a href="#评估结果-1" class="headerlink" title="评估结果"></a>评估结果</h4><p>图 18 显示了 YCSB C 上的延迟和吞吐量结果。我们通过增加客户端计算机的数量来绘制图表。A4 + A5 的组合实现了 68M reqs&#x2F;s 的峰值吞吐量，分别比 RNIC、A1 和 A4 高 25%、36% 和 12%。请注意，我们省略了 A2 和 A3，因为它们受到 SoC 内核的瓶颈，并且峰值吞吐量极低。A4 + A5 的优势主要来自于利用更快的 SoC RDMA 和 SoC 内核来减少网络放大。</p><h2 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h2><h3 id="概括性"><a href="#概括性" class="headerlink" title="概括性"></a>概括性</h3><p>尽管我们的研究主要集中于一种特定的 SmartNIC，Bluefield-2，但我们相信我们的研究结果和建议可以应用于类似硬件架构的其他 off-path SmartNIC。这些 SmartNIC 通过连接异构 SoC 并使用 PCIe 交换机将 SoC 和 RNIC 桥接在一起，扩展了支持 RDMA 的 NIC，例如 Stingray PS225（扩展了 NetXtreme 100 Gbps RNIC）。我们已经确认我们的所有结果都适用于 Bluefield-1。而且，下一代 Bluefield（Bluefield-3）仍然遵循相同的架构，除了使用更快的 RNIC（400 Gbps ConnectX-7）、PCIe（5.0）和 SoC（ARMv8.2+ A78）之外。尽管其他 SmartNIC 的参数可能与 Bluefield-2 不同，但我们的方法、分析工具（开源）和性能模型（例如表 4）也适用于它们。<br>此外，DPDK 是另一种基于 SmartNIC 的流行通信原语。从 NIC 的角度来看，DPDK 类似于 UD 上的 SEND&#x2F;RECV。因此，我们相信我们的大部分发现仍然适用于 DPDK。 不幸的是，我们没有基于以太网的测试平台来进一步证实这一点。</p><h3 id="对硬件供应商的建议"><a href="#对硬件供应商的建议" class="headerlink" title="对硬件供应商的建议"></a>对硬件供应商的建议</h3><p>我们的研究发现了一些可以通过硬件改进来缓解的异常情况，我们建议供应商考虑这些问题。例如，当前主机到 SoC DMA 必须卸载到 SoC 来执行，而支持 CXL 可以利用更强大的主机 CPU DMA 引擎。然而，以程序员友好的方式做到这一点将需要 SoC 操作系统和主机操作系统之间的强有力的合作。据我们所知，目前还没有 SmartNIC 支持 CXL。此外，供应商可以支持 CCI，以缓解第 3.2 节中提到的写入偏差问题。此外，将 SoC PCIe MTU 与主机对齐可能会在传输大负载时提高 PCIe 性能。最后，我们鼓励供应商披露更多 SmartNIC 的硬件细节，以帮助解释和证实我们的研究结果。</p><h2 id="其他相关工作"><a href="#其他相关工作" class="headerlink" title="其他相关工作"></a>其他相关工作</h2><h3 id="SmartNIC-卸载"><a href="#SmartNIC-卸载" class="headerlink" title="SmartNIC 卸载"></a>SmartNIC 卸载</h3><p>将计算卸载到 SmartNIC 引起了学术界和工业界的极大关注。 卸载的任务包括网络功能，微服务和其他的一些功能。 我们有着相同的愿景——通过将计算和通信卸载到 SmartNIC 来提高分布式系统的性能，但进一步利用 SmartNIC 的多个通信路径。 此外，大多数先前的工作都集中在利用 on-path SmartNIC 的单一路径，因此我们的工作可以启发未来对 on-path SmartNIC 的 multi-path 卸载的研究。</p><h3 id="RDMA-卸载"><a href="#RDMA-卸载" class="headerlink" title="RDMA 卸载"></a>RDMA 卸载</h3><p>在 SmartNIC 出现之前，许多分布式系统将远程内存访问卸载到单向 RDMA 原语。然而，先前的工作已经观察到单向 RDMA 的不良语义，因此利用了高级 RDMA 功能（比如 WAIT，DCT）或者引入新的 RDMA 原语。这些努力与我们的工作正交，并且在将来使用 SmartNIC 时也可以从我们的发现中受益。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 SmartNIC 设计高性能分布式系统需要深入了解底层硬件细节。 本文对路径外 SmartNIC 进行了全面的研究。 与之前的工作不同，我们探讨了 SmartNIC 架构及其计算单元的异构性如何影响与其组件相关的通信性能。 我们进一步为设计人员提出了第一个优化指南，以智能地利用分布式系统的 SmartNIC 的多个通信路径，并通过改进两个分布式系统来演示我们的指南。 总的来说，我们的研究可以帮助系统设计人员在将 SmartNIC 应用到高性能分布式系统之前更好地理解它们。</p>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>DPU论文翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>毕业设计</tag>
      
      <tag>论文翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++_STL面试常见题</title>
    <link href="/2023/12/03/C++_STL/"/>
    <url>/2023/12/03/C++_STL/</url>
    
    <content type="html"><![CDATA[<h2 id="vector-简要介绍"><a href="#vector-简要介绍" class="headerlink" title="vector 简要介绍"></a>vector 简要介绍</h2><p>vector 是动态开辟的数组。元素在内存中连续存放。随机存取任何元素都能在常数时间内完成。在尾端增删元素具有较佳的性能，</p><h2 id="vector-底层原理"><a href="#vector-底层原理" class="headerlink" title="vector 底层原理"></a>vector 底层原理</h2><ul><li>数据安排及操作方式与 array 非常相似。两者唯一的差别在于空间运用的灵活性。</li><li>array 是静态空间，一旦配置好了就不能改变了，如果程序需要一个更大的 array，只能自己再申请一个更大的 array，然后将以前的 array 中的内容全部拷贝到新的 array 中。</li><li>动态开辟的空间，随着元素的加入，它的内部机制会自动扩容空间以容纳新的元素。vector 的关键技术在于对大小的控制以及重新分配时的数据移动效率。</li><li>采用的数据结构是线性的连续空间（泛型的动态类型顺序表），它以两个迭代器 start 和 finish 分别指向配置得来的连续空间中目前已经被使用的空间。迭代器 end_of_storage 指向整个连续的尾部。</li><li>在增加元素时，如果超过自身最大的容量，vector 则将自身的容量扩充为原来的两倍。扩充空间需要经过的步骤是：重新配置空间，元素移动，释放旧的内存空间。一旦 vector 空间重新配置，则指向原来 vector 的所有迭代器都失效了，因为 vector 的地址改变了。</li></ul><h2 id="vector-为什么要用加倍扩容而不是每次增加一个固定的扩容容量"><a href="#vector-为什么要用加倍扩容而不是每次增加一个固定的扩容容量" class="headerlink" title="vector 为什么要用加倍扩容而不是每次增加一个固定的扩容容量"></a>vector 为什么要用加倍扩容而不是每次增加一个固定的扩容容量</h2><ul><li>vector 的 push_back 以成倍增长可以在均摊后达到 O(1) 的时间复杂度，相对于增长指定大小的 O(n) 时间复杂度更好。</li><li>为了防止申请内存的浪费，现在使用较多的有 2 倍 与 1.5 倍的增长方式，而 1.5 倍的增长方式可以更好地实现对内存的重复利用。</li></ul><h2 id="vector-扩容的过程"><a href="#vector-扩容的过程" class="headerlink" title="vector 扩容的过程"></a>vector 扩容的过程</h2><ul><li>完全弃用现有的内存空间，重新申请更大的内存空间；</li><li>将旧内存空间中的数据，按照原有顺序移动到新的内存空间中；</li><li>最后将旧的内存空间释放。</li></ul><h2 id="vector-的扩容倍数为什么是-1-5-倍或-2-倍"><a href="#vector-的扩容倍数为什么是-1-5-倍或-2-倍" class="headerlink" title="vector 的扩容倍数为什么是 1.5 倍或 2 倍?"></a>vector 的扩容倍数为什么是 1.5 倍或 2 倍?</h2><ul><li>假如以 2 倍的扩容倍数来进行扩容(1, 2, 4, 8, 16…)，则第 i 次扩容期间所需要的空间容量是 $2^i$，假如第三次扩容时总共需要 8 个元素大小的空间，但是前 3 次已经释放的空间加起来是 7，7 &lt; 8，不足以满足第 3 次扩容时需要的新的空间大小，也就是说，如果恰好以 2 倍的扩容系数来扩容的话，那么每次扩容时前面释放的空间加起来都不足以支持本次的扩容。如果是以更高倍数的方式进行扩容，则这个空间浪费的问题会更加严重。也就是说，如果以 2 倍或更高的倍数进行扩容，会存在 2 个问题：<ul><li>空间浪费可能比较大</li><li>无法使用前面已经释放的空间</li></ul></li><li>STL 标准没有严格说明我们应该按照哪一种方式进行扩容，因此不同 STL 的实现厂商都是按照自己的方式进行扩容的。</li><li>一般情况下，在 Windows 的 VS 系列编辑器下，是按照 1.5 倍的方式进行扩容；在 Linux 的 g++ 中，是按照 2 倍的方式进行扩容的。</li></ul><h2 id="size、resize、reserve、capacity-的区别"><a href="#size、resize、reserve、capacity-的区别" class="headerlink" title="size、resize、reserve、capacity 的区别"></a>size、resize、reserve、capacity 的区别</h2><ul><li>size 表示当前 vector 中有多少元素（即 finish - start）；当前容器所存储的个数。</li><li>resize 可以改变有效空间的大小，也有改变默认值的功能。capacity 的大小也会随着改变。可以有多个参数。创建指定数量的元素并指定 vector 的存储空间。既分配空间又创建对象。</li><li>reserver 是直接扩容到已经确定的大小，可以减少多次开辟、释放空间的问题（优化 push_back），从而达到提高效率的目的，其次还可以减少多次要拷贝数据的问题。reserve 只是保证 vector 中的空间大小（capacity）最少达到参数所指定的大小 n。并且它只有一个参数。指定 vector 的元素总数，不创建对象。</li><li>capacity 函数表示它已经分配的内存中可以容纳多少元素（即 end_of_storage - start）。即容器在分配新的存储空间能存储的元素总数。返回 vector 中能存储元素的最大值。</li></ul><h2 id="vector-迭代器失效的问题"><a href="#vector-迭代器失效的问题" class="headerlink" title="vector 迭代器失效的问题"></a>vector 迭代器失效的问题</h2><p>迭代器的主要作用就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，或者是对指针进行了封装，比如：vector 的迭代器就是原生态指针 T*。因此迭代器失效，实际就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃（即如果继续使用已经失效的迭代器，程序可能会崩溃）</p><h2 id="对于-vector-可能导致其迭代器失效的操作有哪些"><a href="#对于-vector-可能导致其迭代器失效的操作有哪些" class="headerlink" title="对于 vector 可能导致其迭代器失效的操作有哪些"></a>对于 vector 可能导致其迭代器失效的操作有哪些</h2><ul><li><p>resize、reserve、insert、assign、push_back 等会引起其底层空间改变的操作，都有可能使迭代器失效。</p></li><li><p>指定位置元素的删除操作——erase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(a, a + <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))</span></span>;<br>    <span class="hljs-comment">// 使用 find 查找 3 所在位置的 iterator</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 删除 pos 位置的数据，导致 pos 迭代器失效</span><br>    v.<span class="hljs-built_in">erase</span>(pos);<br>    cout &lt;&lt; *pos &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 此处会导致非法访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>erase 删除 pos 位置元素后，pos 位置之后的元素会往前移动，没有导致底层空间的改变，理论上讲迭代器应该不会失效，但是如果 pos 刚好是最后一个元素，删完之后 pos 刚好是 end 位置，而 end 位置是没有元素的，那么 pos 就失效了。所以删除 vector 中任意位置上元素时，vs 就认为该位置迭代器失效了。</p></li></ul><h2 id="push-back-和-emplace-back-的区别"><a href="#push-back-和-emplace-back-的区别" class="headerlink" title="push_back 和 emplace_back 的区别"></a>push_back 和 emplace_back 的区别</h2><p>emplace_back 和 push_back 的区别，主要就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或移动到容器中（如果是拷贝的话，之和会自行销毁先前创建的这个元素）；而 emplace_back 在实现的时候，则是直接在容器尾部创建这个元素，省去了拷贝或者移动元素的过程。</p><h2 id="list-简单介绍"><a href="#list-简单介绍" class="headerlink" title="list 简单介绍"></a>list 简单介绍</h2><ul><li>list 是顺序容器的一种。list 是一个双向链表。使用 list 需要包含头文件 list。双向链表的每个元素中都有一个指针指向后一个元素，也有一个指针指向前一个元素。</li><li>在 list 容器中，在已经定位到要增删元素的位置的情况下，增删元素能在常数时间内完成。</li><li>list不支持根据下标随机存取元素。</li><li>在任何位置都能高效地插入和删除元素，只要改变元素的指针值，不需要拷贝元素。</li></ul><h2 id="list-的底层原理"><a href="#list-的底层原理" class="headerlink" title="list 的底层原理"></a>list 的底层原理</h2><ul><li>list的底层是一个<strong>双向链表</strong>，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。</li><li>和 vector 容器迭代器的实现方式不同，由于 list 容器的元素并不是连续存储的，所以该容器迭代器中，必须包含一个可以指向 list 容器的指针，并且该指针还可以借助重载的 *、++、–、&#x3D;&#x3D;、!&#x3D; 等运算符，实现迭代器正确的递增、递减、取值等操作。</li></ul><h2 id="list-的常见函数"><a href="#list-的常见函数" class="headerlink" title="list 的常见函数"></a>list 的常见函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list.<span class="hljs-built_in">push_back</span>(elem); <span class="hljs-comment">// 在尾部加入一个元素</span><br>list.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除尾部元素</span><br>list.<span class="hljs-built_in">push_front</span>(); <span class="hljs-comment">// 在头部插入一个数据</span><br>list.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 删除头部数据</span><br>list.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回容器中实际数据的个数</span><br>list.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// 排序，默认由小到大 </span><br>list.<span class="hljs-built_in">unique</span>(); <span class="hljs-comment">// 移除数值相同的连续元素</span><br>list.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 取尾部迭代器</span><br>list.<span class="hljs-built_in">erase</span>(iterator); <span class="hljs-comment">// 删除一个元素，参数是迭代器，返回的是删除迭代器的下一个位置</span><br></code></pre></td></tr></table></figure><h2 id="vector、list-插入问题"><a href="#vector、list-插入问题" class="headerlink" title="vector、list 插入问题"></a>vector、list 插入问题</h2><ul><li>vector 中插入大量连续的数据时，如果预知数据量大小，可以通过 resize 来调整原先 vector 的空间大小，同时利用赋值 “&#x3D;”，可以减少耗时。</li><li>list 可以通过遍历 list 然后 insert 插入，但还可以通过成员方法 splice 来进行插入，且效率较高，耗时较少。</li></ul><h2 id="vector-和-list-的优缺点"><a href="#vector-和-list-的优缺点" class="headerlink" title="vector 和 list 的优缺点"></a>vector 和 list 的优缺点</h2><ol><li><p>vector 的优点</p><ul><li><p>下标随机访问</p><p>vector 的底层是一段连续的物理空间，所以支持随机访问。</p></li><li><p>尾插尾删效率高</p><p>跟数组类似，我们能够很轻易地找到最后一个元素，并完成各种操作。</p></li><li><p>CPU 高速缓存命中率高</p><p>因为系统在底层访问数据地的时候，会将一段数据加载进 CPU，而不是只加载一个，会提前往后多加载一些，vector 的物理地址是连续的，所以我们在拿到数据的时候，CPU 访问后面的数据会更快。</p></li></ul></li><li><p>vector 的缺点</p><ul><li><p>前面部分插入删除数据效率低</p><p>如果我们要在前面的部分插入或删除数据，我们不能直接插入或者删除，需要挪动数据，去覆盖或者增加一段空间，挪动数据的效率是 O(N) 的。</p></li><li><p>扩容有消耗，可能存在一定的空间浪费</p><p>正常情况下，vector 的扩容机制是一旦达到当前空间的 capacity(容量)，那么就扩容原空间的 1.5倍 或者 2 倍(VS 一般是 1.5 倍，而 g++ 是 2 倍)，这样扩容就可能导致空间浪费，而且频繁扩容也会影响效率。</p></li></ul></li><li><p>list 的优点</p><ul><li><p>按需申请释放，不需要扩容</p><p>list 是一个带头双向循环链表，那么链表就是一个个独立的空间链接起的，需要多少，就 new 多少，不存在空间浪费。</p></li><li><p>任意位置的插入删除效率高（对比 vector）</p><p>因为 list 是双向循环链表，我们需要插入新的元素只需要改变原数据的 next 和 prev ，所以我们的插入删除效率是 O(1)。</p></li></ul></li><li><p>list 的缺点</p><ul><li><p>不支持下标随机访问</p><p>因为 list 是链表，在存放数据的物理地址并不是连续的，所以我们也就不能支持下标随机访问。</p></li><li><p>CPU 高速缓存命中率低</p><p>主要还是跟它的物理地址不连续有关，CPU 提前存的一段数据，可能跟下一个数据完全没有联系，因为它们空间不连续，所以就命中率低。</p></li></ul></li></ol><h2 id="vector-和-list-中，如果删除末尾的元素，其指针和迭代器如何变化？如果删除的是中间的元素呢？"><a href="#vector-和-list-中，如果删除末尾的元素，其指针和迭代器如何变化？如果删除的是中间的元素呢？" class="headerlink" title="vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？如果删除的是中间的元素呢？"></a>vector 和 list 中，如果删除末尾的元素，其指针和迭代器如何变化？如果删除的是中间的元素呢？</h2><ol><li><p>迭代器和指针之间的区别</p><ol><li>迭代器不是指针，是类模板，表现得像指针。它只是模拟了指针的一些功能，重载了指针的一些操作符，-&gt;、++、– 等。迭代器封装了指针，是一个“可遍历 STL 容器内全部或部分元素”的对象，<strong>本质</strong>是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，它可以根据不同类型的数据结构来实现不同的 ++、– 等操作。</li><li><strong>迭代器返回的是对象引用而不是对象的值</strong>，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ol></li><li><p>vector 和 list 特性</p><ol><li><p>vector 特性</p><p>动态数组。元素再内存中连续存放。随机存取任何元素都能在常数时间内完成。在尾端增删元素具有较大的性能(大部分情况下是常数时间)。</p></li><li><p>list 特性</p><p>双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。</p></li></ol></li><li><p>vector 和 list 增删元素</p><ol><li>对于 vector 而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase 返回下一个有效的迭代器。</li><li>对于 list 而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响。</li></ol></li></ol><h2 id="简单说说-deque"><a href="#简单说说-deque" class="headerlink" title="简单说说 deque"></a>简单说说 deque</h2><ol><li>deque 是一个双向开口的容器，所谓双向开口就是再头尾两端均可以做元素的插入和删除操作。</li><li>deque 相比于 vector 最大的差异就在于支持常数时间内对首尾两端进行插入和删除操作，而且 deque 没有容量的概念，其内部采用分段连续内存空间来存储元素，在插入元素的时候随时都可以重新增加一段新的空间并链接起来。</li><li>deque 提供了Ramdon Access Iterator，同时也支持随机访问和存取，但是它也为此付出了昂贵的代价，其复杂度不能跟 vector 的原生指针迭代器相提并论。在下面的讲解中会一一为大家介绍STL是怎样”辛苦地”维持一个随机访问迭代器的。</li></ol><h2 id="详细讲讲-deque-实现原理"><a href="#详细讲讲-deque-实现原理" class="headerlink" title="详细讲讲 deque 实现原理"></a>详细讲讲 deque 实现原理</h2><p>详见 <a href="STL_deque.md">STL源码剖析_deque</a></p><h2 id="vector、list、deque-的选择原则"><a href="#vector、list、deque-的选择原则" class="headerlink" title="vector、list、deque 的选择原则"></a>vector、list、deque 的选择原则</h2><ul><li>vector 可以随机存储元素(即可以通过公式直接计算出元素地址，而不需要挨个查找)，但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用 vector 而非 deque，因为 deque 的迭代器比 vector 迭代器复杂很多。</li><li>list 不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。</li><li>需要从首尾两端进行插入或删除操作的时候需要选择 deque。</li></ul><p>也即：</p><ul><li>需要对数据高效的随机访问(存取)，而不在乎插入和删除的效率，采用 vector。</li><li>需要大量插入、删除数据，而不关心随机访问数据，采用 list。</li><li>需要随机访问数据，而且关心头部和尾部增删数据的能力，采用 deque。</li><li>对数据中间的增删操作比较多，采用 list，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证。</li></ul><h2 id="STL-迭代器是怎么删除元素的"><a href="#STL-迭代器是怎么删除元素的" class="headerlink" title="STL 迭代器是怎么删除元素的"></a>STL 迭代器是怎么删除元素的</h2><ol><li>对于序列容器 vector，deque 来说，使用 erase 后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase 返回下一个有效的迭代器；</li><li>对于关联容器 map，set 来说，使用了 erase 后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用 erase 之前，记录下一个元素的迭代器即可；</li><li>对于 list 来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</li></ol><h2 id="STL-中的优先队列"><a href="#STL-中的优先队列" class="headerlink" title="STL 中的优先队列"></a>STL 中的优先队列</h2><p>优先队列(priority_queue)容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，队列中最大的元素总是位于队首。出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。这点类似于给队列里的元素进行了由大到小的顺序排序。元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。<strong>在优先队列中，队首元素一定是当前队列中优先级最高的那一个</strong>。</p><h2 id="STL-容器动态链接可能产生的问题"><a href="#STL-容器动态链接可能产生的问题" class="headerlink" title="STL 容器动态链接可能产生的问题"></a>STL 容器动态链接可能产生的问题</h2><ul><li><p>可能产生的问题</p><p>容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</p></li><li><p>产生问题的原因</p><p>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</p></li></ul><h2 id="map-和-unordered-map-实现原理"><a href="#map-和-unordered-map-实现原理" class="headerlink" title="map 和 unordered_map 实现原理"></a>map 和 unordered_map 实现原理</h2><ul><li>map 内部实现了一个<strong>红黑树</strong>（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡的二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li><li>unordered_map 内部实现了一个<strong>哈希表</strong>（也叫散列表，hashtable），通过把关键码值映射到 Hash 表中一个位置来访问记录，查找时间复杂度可达 O(1)，其中在海量数据处理中有着广泛应用。其元素的排列顺序是无序的。</li></ul><h2 id="map-和-unordered-map-的优缺点"><a href="#map-和-unordered-map-的优缺点" class="headerlink" title="map 和 unordered_map 的优缺点"></a>map 和 unordered_map 的优缺点</h2><ol><li><p>map</p><ol><li><p>优点</p><ul><li>有序</li><li>基于红黑树实现，查找的时间复杂度是 O(nlogn)</li></ul></li><li><p>缺点</p><ul><li>空间占用率高，虽然底层是红黑树实现的，提高了运行效率，但是每个节点都要保存父节点和孩子节点的红黑树的性质，使得每个节点都占用大量的空间。</li></ul></li><li><p>适用场景</p><p>适用于有序的结构</p></li></ol></li><li><p>unordered_map</p><ol><li>优点<ul><li>底层是用哈希表实现的，查找效率非常高，时间复杂度为 O(1)。</li></ul></li><li>缺点<ul><li>哈希表的建立比较费时</li></ul></li><li>适用场景<ul><li>对于查找问题，使用 unordered_map 更好。</li></ul></li></ol></li></ol><h2 id="为什么-map-和-set-的插入删除效率比其他序列容器高，而且每次-insert-之后，以前保存的-iterator-不会失效"><a href="#为什么-map-和-set-的插入删除效率比其他序列容器高，而且每次-insert-之后，以前保存的-iterator-不会失效" class="headerlink" title="为什么 map 和 set 的插入删除效率比其他序列容器高，而且每次 insert 之后，以前保存的 iterator 不会失效"></a>为什么 map 和 set 的插入删除效率比其他序列容器高，而且每次 insert 之后，以前保存的 iterator 不会失效</h2><p>因为存储的是节点，不需要内存拷贝和内存移动。</p><p>插入操作只是节点指针换来换去，节点内存没有改变，而 iterator 就像指向节点的指针，内存没变，指向内存的指针也不会变。</p><h2 id="map-和-set-的区别"><a href="#map-和-set-的区别" class="headerlink" title="map 和 set 的区别"></a>map 和 set 的区别</h2><ol><li>set是一种关联式容器，其特性如下：<ul><li>set 以 RBTree 作为底层容器</li><li>所得元素的只有 key 没有 value</li><li>不允许出现 key 重复</li><li>所有的元素都会被自动排序</li><li>不能通过迭代器来改变 set 的 key 值，因为 set 的值就是 key，set 的迭代器是 const 的</li></ul></li><li>map和set一样是关联式容器，其特性如下：<ul><li>map 以 RBTree 作为底层容器</li><li>所有元素都是 key + value 存在</li><li>不允许 key 重复</li><li>所有元素是通过 key 进行自动排序的</li><li>map的 key 是不能修改的，但是其 key 对应的 value 是可以修改的</li></ul></li></ol><p>综上所述，map 和 set <strong>底层实现</strong>都是红黑树；map 和 set 的<strong>区别</strong>在于 map 的值不作为键，键和值是分开的。</p><h2 id="STL-的内存优化"><a href="#STL-的内存优化" class="headerlink" title="STL 的内存优化"></a>STL 的内存优化</h2><p>STL 内存管理使用二级内存配置器</p><ol><li><p>第一级配置器</p><ul><li>第一级配置器以 malloc()、free()、realloc() 等 C 函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。一级空间配置器分配的是大于 128 字节的空间，如果分配不成功，调用句柄释放一部分内存，如果还不能分配成功，抛出异常。</li><li>第一级配置器只是对 malloc 函数和 free 函数的简单封装，在 allocate 内调用 malloc，在 deallocate 内调用 free。同时第一级配置器的 oom_malloc 函数，用来处理 malloc 失败的情况。</li></ul></li><li><p>第二级配置器</p><p>第一级配置器直接调用 malloc 和 free 带来了几个问题：</p><ul><li>内存分配&#x2F;释放的效率低。</li><li>当配置大量的小内存块时，会导致内存碎片比较严重。</li><li>配置内存时，需要额外的部分空间存储内存块信息，所以配置大量的小内存块时，还会导致额外内存负担。</li></ul><p>如果分配的区块小于 128bytes，则以内存池管理，第二级配置器维护了一个自由链表数组，每次需要分配内存时，直接从相应的链表上取出一个内存节点就完成工作，效率很高。</p><ul><li>自由链表数组：自由链表数组其实就是个指针数组，数组中的每个指针元素指向一个链表的起始节点。数组大小为 16，即维护了 16 个链表，链表的每个节点就是实际的内存块，相同链表上的内存块大小都相同，不同链表的内存块大小不同，从 8 一直到 128。</li><li>内存分配：allocate 函数内先判断要分配的内存大小，若大于 128 字节，直接调用第一级配置器，否则根据要分配的内存大小从 16 个链表中选出一个链表，取出该链表的第一个节点。若相应的链表为空，则调用 refill 函数填充该链表。默认是取出 20 个数据块。</li><li>填充链表 refill：若 allocate 函数内要取出节点的链表为空，则会调用 refill 函数填充该链表。refill 函数内会先调用 chunk_alloc 函数从内存池分配一大块内存，该内存大小默认为 20 个链表节点大小，当内存池的内存也不足时，返回的内存块节点数目会不足 20 个。接着 refill 的工作就是将这一大块内存分成20份相同大小的内存块，并将各内存块连接起来形成一个链表。</li></ul></li><li><p>内存池：chunk_alloc 函数内管理了一块内存池，当 refill 函数要填充链表时，就会调用 chunk_alloc 函数，从内存池取出相应的内存。</p><ul><li>在 chunk_alloc 函数内首先判断内存池大小是否足够填充一个有 20 个节点的链表，若内存池足够大，则直接返回20 个内存节点大小的内存块给 refill；</li><li>若内存池大小无法满足 20 个内存节点的大小，但至少满足 1 个内存节点，则直接返回相应的内存节点大小的内存块给 refill；</li><li>若内存池连 1 个内存节点大小的内存块都无法提供，则 chunk_alloc 函数会将内存池中那一点点的内存大小分配给其他合适的链表，然后去调用 malloc 函数分配的内存大小为所需的两倍。若 malloc 成功，则返回相应的内存大小给 refill；若 malloc 失败，会先搜寻其他链表的可用的内存块，添加到内存池，然后递归调用 chunk_alloc 函数来分配内存，若其他链表也无内存块可用，则只能调用第一级空间配置器。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL_sort</title>
    <link href="/2023/12/03/STL_sort/"/>
    <url>/2023/12/03/STL_sort/</url>
    
    <content type="html"><![CDATA[<p>STL 的 sort 算法，数据量大时采用快速排序，分段递归排序。一旦分段后的数据量小于某个门槛，为了避免快速排序带来过大的额外负荷(overhead)，就改用插入排序。如果递归层次过深，还会改用堆排序。</p>]]></content>
    
    
    <categories>
      
      <category>STL源码剖析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
      <tag>C++ 基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写实现智能指针类_SharedPtr</title>
    <link href="/2023/11/30/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB-SharedPtr/"/>
    <url>/2023/11/30/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB-SharedPtr/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedPtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">size_t</span>* m_count_;<br>T* m_ptr_;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">SharedPtr</span>(): <span class="hljs-built_in">m_ptr_</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">m_count_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">size_t</span>) &#123;&#125;<br><span class="hljs-built_in">SharedPtr</span>(T* ptr) : <span class="hljs-built_in">m_ptr_</span>(ptr), <span class="hljs-built_in">m_count_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">size_t</span>) &#123; m_count_ = <span class="hljs-number">1</span>; &#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">SharedPtr</span>() &#123;<br>--(*m_count_);<br><span class="hljs-keyword">if</span> (*m_count_ == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">delete</span> m_ptr_;<br><span class="hljs-keyword">delete</span> m_count_;<br>m_ptr_ = <span class="hljs-literal">nullptr</span>;<br>m_count_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">SharedPtr</span>(<span class="hljs-type">const</span> SharedPtr&amp; ptr) &#123;<br>m_count_ = ptr.m_count_;<br>m_ptr_ = ptr.m_ptr_;<br>++(*m_count_);<br>&#125;<br><span class="hljs-comment">// 拷贝赋值运算</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SharedPtr&amp; ptr) &#123; <span class="hljs-built_in">SharedPtr</span>(std::<span class="hljs-built_in">move</span>(ptr)); &#125;<br><span class="hljs-comment">// 移动构造函数</span><br><span class="hljs-built_in">SharedPtr</span>(SharedPtr&amp;&amp; ptr) : <span class="hljs-built_in">m_ptr_</span>(ptr.m_ptr_), <span class="hljs-built_in">m_count_</span>(ptr.m_count_) &#123; ++(*m_count_); &#125;<br><span class="hljs-comment">// 移动赋值运算</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SharedPtr&amp;&amp; ptr) &#123; <span class="hljs-built_in">SharedPtr</span>(std::<span class="hljs-built_in">move</span>(ptr)); &#125;<br><span class="hljs-comment">// 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *m_ptr_; &#125;<br><span class="hljs-comment">// 箭头运算</span><br>T* <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> m_ptr_; &#125;<br><span class="hljs-comment">// 重载 bool 操作符</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_ptr_ == <span class="hljs-literal">nullptr</span>; &#125;<br><span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> m_ptr_; &#125;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_count_; &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_count == <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(SharedPtr&amp; ptr)</span> </span>&#123; std::<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, ptr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>情景设计题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft共识算法学习笔记</title>
    <link href="/2023/11/21/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/21/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这一部分会简单介绍 Raft 的一些基本概念。</p><h3 id="子问题"><a href="#子问题" class="headerlink" title="子问题"></a>子问题</h3><p>Raft 将共识算法这个难解决的问题拆分成了多个易解决，相对独立的子问题，这些问题都会在接下来的章节中进行介绍。</p><ul><li><code>Leader election:</code> 选出集群的 leader 来统筹全局。</li><li><code>Log replication</code>: leader 负责从客户端接收请求，并且在集群中扩散同步。</li><li><code>Safety</code>: 各节点间状态机的一致性保证。</li></ul><p>在博士论文和实际生产系统中，还有更多可以探讨的模块或细节功能：</p><ul><li><code>Log compaction</code>: 压缩以节约磁盘空间；加速重启后节点恢复速率；加速新节点 catch up 速率。</li><li><code>Leader transfer</code>: 能够将 leader 禅让另一个 follower，便于平滑的负载均衡。</li><li><code>Pre vote</code>: 在竞选开始时先进行一轮预备竞选，若被允许再转变为 candidate，这样有助于防止某些异常节点扰乱整个集群的正常工作。</li><li><code>Membership change</code>: 集群动态增删节点。</li><li><code>Client interaction</code>: 客户端交互。</li><li><code>Linearizable read</code>: 线性一致性读。</li><li><code>Optimization</code>: 业界常见优化。</li><li>…</li></ul><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>Raft 将所有节点分为三个身份：</p><ul><li><code>Leader</code>: 集群内最多只会有一个 leader，负责发起心跳，响应客户端，创建日志，同步日志。</li><li><code>Candidate</code>: leader 选举过程中的临时角色，由 follower 转化而来，发起投票参与竞选。</li><li><code>Follower</code>: 接受 leader 的心跳和日志同步数据，投票给 candidate。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311211546404.png" alt="image-20231121154650320"></p><p>上图可以看出 Raft 中节点状态之间变迁的条件。</p><p>在博士论文和实际生产系统中，其实又增加了两种身份：</p><ul><li><code>Learner</code>: 不具有选举权，参与日志复制过程但不计数的节点。可以作为新节点加入集群时的过渡状态以提升可用性，也可以作为一种类似于 binlog 的对 leader 日志流进行订阅的角色，比如可以参考 PingCAP 公司 tikv 和 tiflash 的架构。</li><li><code>Pre candidate</code>: 刚刚发起竞选，还在等待 <code>Pre-Vote</code> 结果的临时状态，取决于 <code>Pre-Vote</code> 的结果，可能进化为 candidate，可能退化为 follower。</li></ul><h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><p>每一个节点都应该有的持久化状态：</p><ul><li><code>currentTerm</code>: 当前任期，保证重启会任期不丢失。</li><li><code>votedFor</code>: 在当前 term，给哪个节点投了票，值为 null 或 <code>candidate id</code>。即使节点重启，Raft 算法也能保证每个任期最多只有一个 leader。</li><li><code>log[]</code>: 已经 committed 的日志，保证状态机可恢复。</li></ul><p>每个节点都应该有的非持久化状态：</p><ul><li><code>commitIndex</code>: 已经提交的最大 index。leader 节点重启后可以通过 appendEntries rpc 逐渐得到不同节点的 matchIndex，从而确认 commitIndex，follower 只需等待 leader 传递过来的 commitIndex 即可。</li><li><code>lastApplied</code>: 已被状态机应用的最大 index。Raft 算法假设了状态机本身是易失的，所以重启状态机后状态机的状态可以通过 log[] (部分 log[] 可以压缩为 snapshot)来恢复。</li></ul><p>leader 的非持久化状态：</p><ul><li><code>nextIndex[]</code>: 为每一个 follower 保存的，应该发送的下一份 <code>entry index</code>; 初始化为本地的 last index + 1。</li><li><code>matchIndex[]</code>: 已确认的，已经同步到每一个 follower 的 <code>entry index</code>。初始化为0，根据复制状态不断递增。</li></ul><p>(注：每次选举后，leader 的此两个数组都应该立刻重新初始化并开始探测)</p><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311211602079.png" alt="image-20231121160234038"></p><p>Raft 将时间划分成为任意不同长度的 term。term 用连续的数字进行表示。每一个 term 的开始都是一次选举，一个或多个 candidate 会试图成为 leader。如果一个 candidate 赢得了选举，它就会在该 term 担任 leader。在某些情况下，选票会被均分，即 <code>split vote</code> (例如总数为偶数节点时两个 candidate 节点个获得了两票)，此时无法选出该 term 的 leader，那么在该 term 的选举超时后将会开始另一个 term 的选举。</p><p>不同的服务器节点可能多次观察到 term 之间的切换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个 term 全程。term 在 Raft 算法中充当逻辑时钟 (类似于 Lamport timestamp) 的作用，这会允许服务器节点查明一些过期的信息比如过期的 leader。</p><p>每个节点都会存储当前的 term 号，这一编号在整个时间内单调增长。当服务器之间通信的时候会交换当前 term 号；如果一个服务器的当前 term 号比其他服务器小，那么它会更新自己的 term 到较大的 term 值。如果一个 candidate 或者 leader 发现自己的 term 过期了，那么它会立刻退回 follower。如果一个节点接收到一个包含过期 term 号的请求，那么它会拒绝或忽略这个请求。这实际上就是一个 Lamport 逻辑时钟的具体实现。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li><code>entry</code>: Raft 中，将每一个事件都称为一个 entry，每一个 entry 都有一个表明它在 log 中位置的 index (之所以从1开始是为了方便 <code>prevLogIndex</code> 从0开始)。只有 leader 可以创建 entry。entry 的内容为 <code>&lt;term, index, cmd&gt;</code>，其中 cmd 是可以被应用到状态机的操作。在 Raft 组大部分节点接收到这条 entry 后， entry 可以被称为是 committed 的。</li><li><code>log</code>: 由 entry 构成的数组，只有 leader 可以改变其他节点的 log。entry 总是先被 leader 添加进本地的 log 数组中去，然后才发起共识请求，获得 quorum 同意后才会被 leader 提交给状态机。follower 只能从 leader 获取新日志和当前的 commitIndex，然后应用对应的 entry 到自己的状态机。</li></ul><h3 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h3><ul><li><code>Election Safety</code>: 每个 term 最多只会有一个 leader；集群同时只会有一个可以读写的 leader。</li><li><code>Leader Append-Only</code>: Leader 的日志是只增的。</li><li><code>Log Matching</code>: 如果两个节点的日志中有两个 entry 有相同的 index 和 term，那么它们就是相同的 entry。</li><li><code>Leader Compleness</code>: 一旦一个操作被提交了，那么在之后的 term 中，该操作都会存在于日志中。</li><li><code>State Machine Safety</code>: 一致性，一旦一个节点应用了某个 index 的 entry 到状态机，那么其他所有节点应用该 index 的操作都是一致的。</li></ul><h2 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h2><p>Raft 使用心跳来维持 leader 的身份。任何节点都以 follower 的身份启动。leader 会定期地发送心跳给所有的 follower 以确保自己的身份。每当 follower 收到心跳后，就刷新自己的 electionElapsed，重新计时。</p><p>(后文中，会将预设的选举超时称为 electionTimeout，而将当前经过的选举耗时称为 electionElapsed)</p><p>一旦一个 follower 在指定的时间内没有收到任何 RPC (称为 electionTimeout)，则会发起一次选举。当 follower 试图发起选举后，其身份转变为 candidate，在增加自己的 term 后，会向所有节点发起 RequestVoteRPC 请求，candidate 状态会一直持续直到：</p><ul><li>赢得选举</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>选举的方式非常简单，谁能获取到多数投票 <code>N / 2 + 1</code>，谁就成为 leader。在一个 candidate 节点等待投票响应的时候，它有可能会收到其他节点声明自己是 leader 的心跳，此时有两种情况：</p><ul><li>该请求的 term 和自己一样或更大：说明对方已经成为 leader，自己立刻退为 follower。</li><li>该请求的 term 小于自己：拒绝请求并返回当前 term 以让请求节点更新 term。</li></ul><p>为了防止在同一时间有太多的 follower 转变为 candidate 导致无法选出绝对多数，Raft 采用了随机选举超时 (<code>randomized election timeoits</code>) 的机制，每一个 candidate 在发起选举后，都会随机化一个新的选举超时时间，一旦超时后仍然没有完成选举，则增加自己的 term，然后发起新一轮选举。在这种情况下，应该能在较短的时间内确认出 leader。(因为 term 较大的有更大的概率压倒其他节点)</p><p>ectd 中间随机选举超时设置为 [<code>electiontimeout, 2 * electiontimeout - 1</code>] 。</p><p>通过一个节点在一个 term 只能给一个节点投票，Raft 保证了对于给定的一个 term 最多只有一个 leader，从而避免了选举导致的 <code>split brain</code> 以确保 safety；通过不同节点每次随机化选举超时时间，Raft 在实践中(注意，并没有在理论上)避免了活锁以确保 liveness。</p><h2 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h2><p>leader 被选举后，则负责所有的客户端请求。每一个客户端请求都包含一个命令，该命令可以被作用到 RSM。</p><p>leader 收到客户端请求后，会生成一个 entry，包含 <code>&lt;index, term, cmd&gt;</code>，再将 这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry。</p><p>follower 如果同意该 entry，则在将 entry 添加到自己的日志后，返回同意。</p><p>如果 leader 收到了多数的成功答复，则将该 entry 添加到自己的 RSM，之后可以称该 entry 是 committed 的。该 committed 信息会随着随后的 AppendEntries 或 Heartbeat RPC 被传送到其他节点。 </p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311272239669.png" alt="image-20231127223951552"></p><p>Raft 保证以下两个性质：</p><ul><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd；</li><li>如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同。</li></ul><p>通过“仅有 leader 可以生成 entry”来确保第一个性质，第二个性质则通过一致性检查（consistency check）来保证，该检查包含几个步骤：</p><p>leader 在通过 AppendEntriesRPC 和 follower 通讯时，会带上一块 entry 的信息，而 follower 在收到后会对比自己的日志，如果发现这个 entry 的信息（index、term）和自己日志内的不符，则会拒绝该请求。一旦 leader 发现有 follower 拒绝了请求，则会与该 follower 再进行一致性检查 ，找到双方的最大共识点，然后用 leader 的 entries 记录覆盖 follower 所有在最大共识点之后的数据。</p><p>寻找共识点时，leader 还是通过 AppendEntriesRPC 和 follower 进行一致性检查，方法是发送再上一块的 entry，如果 follower 依然拒绝，则 leader 再尝试发送更前面的一块，直到找到双方的共识点。因为分歧发生的概率较低，而且一般很快能够得到纠正，所以这里的逐块确认一般不会造成性能问题。当然，这里进行二分查找或者某些规则的查找可能也能够在理论上得到收益。</p><p>每个 leader 都会为每一个 follower 保存一个 nextIndex 的变量，标志了下一个需要发送给该 follower 的 entry 的 index。在 leader 刚当选时，该值初始化为该 leader 的 log 的 index + 1。一旦 follower 拒绝了 entry，则 leader 会执行 nextIndex -&#x3D; 1，然后再次发送。直到 follower 接收后将 matchIndex 设置为此时的 nextIndex - 1，然后开始正常的复制。这里还可以做一些更细粒度的优化，比如再正常复制时可以批量复制日志以减少系统调用的开销；在寻找共识点时可以只携带一条日志以减少不必要的流量传输。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>因为 leader 的强势地位，所以 Raft 在投票阶段就确保选举出的 leader 一定包含了整个集群中目前已 committed 的所有日志。</p><p>当 candidate 发送 RequestVoteRPC 时，会带上最后一个 entry 的信息。所有的节点收到该请求后，都会对比自己的日志，如果发现自己的日志更新一点，则会拒绝投票给该 candidate。（Pre-Vote 同理，如果 follower 认为 Pre-Candidate 没有资格的话，会拒绝 PreVote）</p><p>判断日志新旧的方法：获取请求的 entry 后，比对自己日志中的最后一个 entry。首先比对 term，如果自己的 term 更大，则拒绝请求。如果 term 一样，则比对 index，如果自己的 index 更大（说明自己的日志更长），则拒绝请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// used by RequestVote Handler to judge which log is newer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> isLogUpToDate(term, index <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    lastLog := rf.getLastLog()<br>    <span class="hljs-keyword">return</span> term &gt; lastLog.Term || (term == lastLog.term &amp;&amp; index &gt;= lastLog.Index)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311272315722.png" alt="image-20231127231556193"></p><p>在上图中，Raft 为了避免出现一致性问题，要求 leader 绝不会提交过去的 term 的 entry（即使该 entry 已经被复制到了多数节点上）。leader 永远只提交当前 term 的 entry，过去的 entry 只会随着当前的 entry 被一并提交。（上图中的 c，term2 只会跟随 term4 被提交）</p><p>如果一个 candidate 能取得多数同意，说明它的日志已经是多数节点中最完备的，那么也就可以认为该 candiate 已经包含了整个集群中所有的 committed entries。</p><p>因此 leader 当选后，应当立刻发起 AppendEntriesRPC 提交一个 no-op entry。注意，这是一个 <code>Must</code>，不是一个 <code>Should</code>，否则会有许多 corner case 存在问题。比如：</p><ul><li>读请求：leader 此时的状态机可能并不是最新的，若服务读请求可能会违反线性一致性，即出现 safety 的问题；若不服务读请求则可能会有 liveness 的问题。</li><li>配置变更：可能会导致数据丢失，具体原因和例子可以参考此 <a href="https://zhuanlan.zhihu.com/p/359206808">博客</a></li></ul><p>实际上，leader 当选后提交一个 no-op entry 日志的做法就是 Raft 算法解决“幽灵复现”问题的解法，感兴趣的可以看看此 <a href="https://mp.weixin.qq.com/s/jzx05Q781ytMXrZ2wrm2Vg">博客</a> </p><h3 id="节点崩溃"><a href="#节点崩溃" class="headerlink" title="节点崩溃"></a>节点崩溃</h3><p>如果 leader 崩溃，集群中的所有节点在 electionTimeout 时间内没有收到 leader 的心跳信息就会触发新一轮的选主。总而言之，最终集群总会选出唯一的 leader。按论文中的说法，计算一次 RPC 耗时高达 <code>30~40ms</code> 时，<code>99.9%</code> 的选举依然可以在 <code>3s</code> 内完成，但一般一个机房内一次 RPC 只需 1ms。当然，选主期间整个集群对外是不可用的。</p><p>如果 follower 和 candidate 奔溃相对而言就简单很多， 因为 Raft 所有的 RPC 都是幂等的，所以 Raft 中所有的请求，只要超时，就会无限的重试。follower 和 candidate 崩溃恢复后，可以收到新的请求，然后按照上面谈论过的追加或拒绝 entry 的方式处理请求。</p><h3 id="时间与可用性"><a href="#时间与可用性" class="headerlink" title="时间与可用性"></a>时间与可用性</h3><p>Raft 原则上可以在绝大部分延迟情况下保证一致性， 不过为了保证选择和 leader 的正常工作，最好能满足下列时间条件：<code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p><ul><li><code>broadcastTime</code> : 向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code> : follower 判定 leader 已经故障的时间（heartbeat 的最长容忍间隔）；</li><li><code>MTBF(mean time between failures)</code> : 单台机器的平均健康时间；</li></ul><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>Raft 的日志在正常运行期间会增长以合并更多的客户请求，但是在实际的系统中，Raft 的日志无法不受限制地增长。随着日志的增长，日志会占用更多空间，并且需要花费更多时间进行重放。如果没有某种机制可以丢弃日志中累积的过时信息，这最终将导致可用性问题。因此需要定时去做 snapshot。</p><p>snapshot 会包括：</p><ul><li>状态机当前的状态。</li><li>状态机最后一条应用的 entry 对应的 index 和 term。</li><li>集群最新配置信息。</li><li>为了保证 exactly-once 线性化语义的去重表（之后会介绍到）。</li></ul><p>各个节点自行择机完成自己的 snapshot 即可，如果 leader 发现需要发给某一个 follower 的 nextIndex 已经被做成了 snapshot，则需要将 snapshot 发送给该 follower。注意 follower 拿到非过期的 snapshot 之后直接覆盖本地所有状态即可，不需要留有部分 entry，也不会出现 snapshot 之后还存在有效的 entry。因此 follower 只需要判断 <code>InstallSnapshot RPC</code> 是否过期即可。过期则直接丢弃，否则直接替换全部状态即可。</p><p>snapshot 可能会带来两个问题：</p><ol><li>做 snapshot 的策略？<br>一般为定时或者定大小，达到阈值即做 snapshot，做完后对状态机和 raft log 进行原子性替换即可。</li><li>做 snapshot 时是否还可继续提供写请求？<br>一般情况下，做 snapshot 期间需要保证状态机不发生变化，也就是需要保证 snapshot 期间状态机不处理写请求。当然 raft 层依然可以去同步，只是状态机不能变化，即不能 apply 新提交的日志到状态机中而已。要想做的更好，可以对状态机采用 <code>copy-on-write</code> 的复制来不阻塞写请求。</li></ol><h2 id="禅让"><a href="#禅让" class="headerlink" title="禅让"></a>禅让</h2><p>有时候，会希望取消当前 leader 的管理权，比如：</p><ul><li>leader 节点因为运维原因需要重启；</li><li>有其他更适合当 leader 的节点；</li></ul><p>直接将 leader 节点停机的话，其他节点会等待 electionTimeout 后进入选举状态， 这期间会集群会停止响应。为了避免这一段不可用的时间，可以采用禅让机制（<code>leadership transfer</code>）。</p><p>禅让的步骤为：</p><ol><li>leader 停止响应客户端请求；</li><li>leader 向 target 节点发起一次日志同步；</li><li>leader 向 target 发起一次 TimeoutNowRPC，target 收到该请求后立刻发起一轮投票。</li></ol><p>etcd 中实现了更多的细节（也有一些改动）：</p><ol><li>leader 先检查禅让对象（leadTransferee）的身份，如果是 follower，直接忽略；</li><li>leader 检查是否有正在进行的禅让，如果有，则中止之前的禅让状态，开始处理最新的请求；</li><li>检查禅让对象是否是自己，如果是，忽略；</li><li>将禅让状态信息计入 leader 的状态，并且重置 electionElapsed（因为禅让应该在 electionTimeout 内完成）；</li><li>检查禅让对象的日志是否是最新的</li><li>如果禅让对象已经是最新，则直接发送 TimeoutNowRPC</li><li>如果不是，则发送 AppendEntriesRPC，待节点响应成功后，再发送 TimeoutNowRPC</li></ol><p>可以看出，在 etcd 中，leader 除了重置 electionElapsed 外，不会改动自己的状态。 既不会停止对客户端的响应，同时还会继续发送心跳。</p><p>因为 target 机器会更新自己的 term，而且率先发起投票，其有很大的概率赢得选举。 需要注意的是，target 发起的 RequestVoteRPC 中的 <code>isLeaderTransfer=true</code>， 以防止被其他节点忽略。</p><p>如果 target 机器没能在一次 electionTimeout 内完成选举，那么 leader 认为本次禅让失败， 立刻恢复响应客户端的请求。（这时可以再次重新发起一次禅让请求）</p><p>在 etcd&#x2F;raft 中，RequestVoteRPC.context 会被设置为 campaignTransfer, 表明本次投票请求来源于 leader transfer，可以强行打断 follower 的租约发起选举。</p><h2 id="预投票"><a href="#预投票" class="headerlink" title="预投票"></a>预投票</h2><p>一个暂时脱离集群网络的节点，在重新加入集群后会干扰到集群的运行。</p><p>因为当一个节点和集群失去联系后，在等待 electionTimeout 后，它就会增加自己的 term 并发起选举， 因为联系不上其他节点，所以在 electionTimeout 后，它会继续增加自己的 term 并继续发起选举。</p><p>一段时间以后，它的 term 就会显著的高于原集群的 term。如果此后该节点重新和集群恢复了联络， 它的高 term 会导致 leader 立刻退位，并重新举行选举。</p><p>为了避免这一情形，引入了 Pre-Vote 的机制。在该机制下，一个 candidate 必须在获得了多数赞同的情形下， 才会增加自己的 term。一个节点在满足下述条件时，才会赞同一个 candidate：</p><ul><li>该 candidate 的日志足够新；</li><li>当前节点已经和 leader 失联（electionTimeout）。</li></ul><p>也就是说，candidate 会先发起一轮 Pre-Vote，获得多数同意后，更新自己的 term， 再发起一轮 RequestVoteRPC。</p><p>这种情形下，脱离集群的节点，只会不断的发起 Pre-Vote，而不会更新自己的 term。</p><p>在 etcd 的实现中，如果某个节点赞同了某个 candidate， 是不需要更新自己的状态的，它依然可以赞同其他 candidate。 而且，即使收到的 PreVote 的 term 大于自己，也不会更新自己的 term。 也就是说，PreVote 不会改变其他节点的任何状态。</p><p>etcd 中还有一个设计是，当发起 PreVote 的时候，针对的是下一轮的 term， 所以会向所有的节点发送一个 term+1 的 PreVoteReq。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *raft)</span></span> campaign(t CampaignType) &#123;<br><span class="hljs-keyword">var</span> term <span class="hljs-type">uint64</span><br><span class="hljs-keyword">var</span> voteMsg pb.MessageType<br><span class="hljs-keyword">if</span> t == campaignPreElection &#123;<br>r.becomePreCandidate()<br>voteMsg = pb.MsgPreVote<br><span class="hljs-comment">// 这里需要注意的是，PreVote 会针对“下一轮 term”发起投票，</span><br><span class="hljs-comment">// 而 Vote 则是针对当前 term</span><br><span class="hljs-comment">// PreVote RPCs are sent for the next term before we&#x27;ve incremented r.Term.</span><br>term = r.Term + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r.becomeCandidate()<br>voteMsg = pb.MsgVote<br>term = r.Term<br>&#125;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 发送投票请求</span><br>    r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;)<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h2><p>raft 的配置变更一般分为两种方式：一次变更一个和一次变更多个，前者实现相对简单（谬误，其实并不简单，感兴趣可以参考该 <a href="https://zhuanlan.zhihu.com/p/342319702">博客</a>），改动多个节点的配置变更可以被分成多个一次变更一个来执行；后者相对复杂，并且在某些场景下可用性更强，具体可参考 TiDB 5.0 的 <a href="https://mp.weixin.qq.com/s/nLWbEEBBVYuNGde0IbE3XQ">介绍</a>。</p><p>以下仅会简单介绍两种成员变更方式，具体可以参考 raft 作者博士论文的 <a href="https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md#4-%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E6%9B%B4%E6%94%B9">第四章</a> 和 <a href="https://zhuanlan.zhihu.com/p/359206808">Raft 成员变更的工程实践</a>。</p><h3 id="一次变更一台"><a href="#一次变更一台" class="headerlink" title="一次变更一台"></a>一次变更一台</h3><p>因为在 Raft 算法中，集群中每一个节点都存有整个集群的信息，而集群的成员有可能会发生变更（节点增删、替换节点等）。 Raft 限制一次性只能增／删一个节点，在一次变更结束后，才能继续进行下一次变更。</p><p>如果一次性只变更一个节点，那么只需要简单的要求“在新／旧集群中，都必须取得多数（N&#x2F;2+1）”， 那么这两个多数中必然会出现交集，这样就可以保证不会因为配置不一致而导致脑裂。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312121545863.png" alt="4_3"></p><p>当 leader 收到集群变更的请求后，就会生成一个特殊的 entry 项用来保存配置， 在将配置项添加到 log 后，该配置立刻生效（也就是说任何节点在收到新配置后，就立刻启用新配置）。 然后 leader 将该 entry 扩散至多数节点，成功后则提交该 entry。 一旦一个新配置项被 committed，则视为该次变更已结束，可以继续处理下一次变更了。</p><p>为了保证可用性，需要新增一项规则，节点在响应 RPC 时，不考虑来源节点是否在自己的配置文件之中。 也就是说，即使收到了一个并不在自己配置文件之中的节点发来的 RPC， 也需要正常处理和响应，包括 AppendEntriesRPC 和 RequestVoteRPC。</p><h3 id="一次变更多台"><a href="#一次变更多台" class="headerlink" title="一次变更多台"></a>一次变更多台</h3><p>这种变更方式可以一次性变更多个节点（arbitrary configuration）。</p><p>当集群成员在变更时，为了保证服务的可用性（不发生中断），以及避免因为节点变更导致的一致性问题， Raft 提出了两阶段变更，当接收到新的配置文件后，集群会首先进入 joint consensus 状态， 待新的配置文件提交成功后，再回到普通状态。</p><p>更具体的，joint consensus 指的是包含新／旧配置文件全部节点的中间状态：</p><ul><li>entries 会被复制到新／旧配置文件中的所有节点；</li><li>新／旧配置文件中的任何一个节点都有可能被选为 leader；</li><li>共识（选举或提交）需要同时在新／旧配置文件中分别获取到多数同意（<code>separate majorities</code>）</li></ul><p>（注：<code>separate majorities</code>的意思是需要新／旧集群中的多数都同意。比如如果是从 3 节点切换为全新的 9 节点， 那么要求旧配置中的 2 个节点，和新配置中的 5 个节点都同意，才被认为达成了一次共识）</p><p>所以，在一次配置变更中，一共有三个状态：</p><ul><li><code>C_old</code>：使用旧的配置文件；</li><li><code>C_old,new</code>：同时使用新旧配置文件，也就是新／旧节点的并集；</li><li><code>C_new</code>：使用新的配置文件。</li></ul><p>配置文件使用特殊的 entries 进行存储，一个节点一旦获取到新的配置文件， 即使该配置 entry 并没有 committed，也会立刻使用该配置。 所以一次完整的配置变更可以表示为下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312121551577.png" alt="4_8"></p><ol><li>C_old,new 被创建，集群进入 joint consensus，leader 开始传播该 entry；</li><li>C_old,new 被 committed，也就是说此时多数节点都拥有了 C_old,new，此后 C_old 已经不再可能被选为 leader；</li><li>leader 创建并传播 C_new；</li><li>C_new 被提交，此后不在 C_new 内的节点不允许被选为 leader，如有 leader 不在 C_new 则自行退位。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>不在 C_new 的节点可能会干扰集群。</p><p>当 C_new 开始生效后，被移除的节点就会收不到 heartbeat，所以在 electionTimeout 后， 这些节点会更新自己的 term 然后开始尝试竞选，这会导致目前的 leader 被迫退回 follower 并启动一轮投票。 这会反复发生，严重影响效率。</p><p>解决办法是，每一个 follower 增加一个机制，当节点处于 minimum election timeout 之内时， 也就是当一个节点认为自己的 leader 依然存活时，将会拒绝 RequestVoteRPC，既不会同意投票， 也不会根据 RequestVoteRPC 更新自己的 term。</p><p>但如果此时集群正好处于选举之中，那么 C_old 集群的节点可能还是会造成干扰， 所以结合 PreVote 更为可靠。</p><p>这一机制会干扰到 leader transfer 机制，因为在 leader transfer 中，即使 electionTimeout 未到， RequestVoteRPC 也应该打断所有的节点，要求立刻开始进行选举。 所以需要给 RequestVoteRPC 增加一个 flag 来表明是否来自于 leader transfer。</p><p>etcd 中也是增加了一个 flag campaignTransfer 来做特殊标记，见上面的「禅让」一节。</p><h2 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h2><p>虽然说 raft 算法只是一个 RSM，其只需要保证不同节点上的日志相同即可，其他的事情它都不需要关心。但是要想保证线性一致性语义，对于基于 raft 的 KV 往往还需要额外做一些事情，比如即使客户端会超时重试，也要保证日志的 exactly-once 执行。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202312121553701.png" alt="client"></p><p>考虑这样一个场景，客户端向服务端提交了一条日志，服务端将其在 raft 组中进行了同步并成功 commit，接着在 apply 后返回给客户端执行结果。然而不幸的是，该 rpc 在传输中发生了丢失，客户端并没有收到写入成功的回复。因此，客户端只能进行重试直到明确地写入成功或失败为止，这就可能会导致相同地命令被执行多次，从而违背线性一致性。</p><p>有人可能认为，只要写请求是幂等的，那重复执行多次也是可以满足线性一致性的，实际上则不然。考虑这样一个例子：对于一个仅支持 put 和 get 接口的 raftKV 系统，其每个请求都具有幂等性。设 x 的初始值为 0，此时有两个并发客户端，客户端 1 执行 put(x,1)，客户端 2 执行 get(x) 再执行 put(x,2)，问（客户端 2 读到的值，x 的最终值）是多少。对于线性一致的系统，答案可以是 (0,1)，(0,2) 或 (1,2)。然而，如果客户端 1 执行 put 请求时发生了上段描述的情况，然后客户端 2 读到 x 的值为 1 并将 x 置为了 2，最后客户端 1 超时重试且再次将 x 置为 1。对于这种场景，答案是 (1,1)，这就违背了线性一致性。归根究底还是由于幂等的 put(x,1) 请求在状态机上执行了两次，有两个 LZ 点。因此，即使写请求的业务语义能够保证幂等，不进行额外的处理让其重复执行多次也会破坏线性一致性。当然，读请求由于不改变系统的状态，重复执行多次是没问题的。</p><p>对于这个问题，raft 作者介绍了想要实现线性化语义，就需要保证日志仅被执行一次，即它可以被 commit 多次，但一定只能 apply 一次。其解决方案原文如下：</p><blockquote><p>The solution is for clients to assign unique serial numbers to every command. Then, the state machine tracks the latest serial number processed for each client, along with the associated response. If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.</p></blockquote><p>基本思路便是：</p><ul><li>每个 client 都需要一个唯一的标识符，它的每个不同命令需要有一个顺序递增的 commandId，clientId 和这个 commandId，clientId 可以唯一确定一个不同的命令，从而使得各个 raft 节点可以记录保存各命令是否已应用以及应用以后的结果。</li></ul><p>为什么要记录应用的结果？因为通过这种方式同一个命令的多次 apply 最终只会实际应用到状态机上一次，之后相同命令 apply 的时候实际上是不应用到状态机上的而是直接返回的，那么这时候应该返回什么呢？直接返回成功吗？不行，如果第一次应用时状态机报了什么例如 key not exist 等业务上的错而没有被记录，之后就很难捕捉到这个执行结果了，所以也需要将应用结果保存下来。</p><p>如果默认一个客户端只能串行执行请求的话，服务端这边只需要记录一个 map，其 key 是 clientId，其 value 是该 clientId 执行的最后一条日志的 commandId 和状态机的输出即可。</p><p>raft 论文中还考虑了对这个 map 进行一定大小的限制，防止其无线增长。这就带来了两个问题：</p><ul><li>集群间的不同节点如何就某个 clientId 过期达成共识。</li><li>不小心驱逐了活跃的 clientId 怎么办，其之后不论是新建一个 clientId 还是复用之前的 clientId 都可能导致命令的重执行。</li></ul><p>这些问题在工程实现上都较为麻烦。比如后者如果业务上是事务那直接 abort 就行，但如果不是事务就很难办了。</p><p>实际上，个人感觉 clientId 是与 session 绑定的，其生命周期应该与 session 一致，开启 session 时从 map 中保存该 clientId，关闭 session 时从 map 中删除该 clientId 及其对应的 value 即可。map 中一个 clientId 对应的内存占用可能都不足 30 字节，相比携带更多业务语义的 session 其实很小，所以感觉没太大必要去严格控制该 map 的内存占用，还不如考虑下怎么控制 session 更大地内存占用呢。这样就不用去纠结前面提到的两个问题了。</p><p>感兴趣的可以参照 raft 博士论文第六章-<a href="https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md#6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92">客户端交互</a> 和 dragonboat 作者在知乎上对其的 <a href="https://www.zhihu.com/question/278551592">讨论</a>。</p><h2 id="线性一致性读"><a href="#线性一致性读" class="headerlink" title="线性一致性读"></a>线性一致性读</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>业界的实践很多，可以参考 tikv 的 <a href="https://zhuanlan.zhihu.com/p/25735592">优化</a> 和 dragonboat 的 <a href="https://zhuanlan.zhihu.com/p/52620657">优化</a>。</p><p>以下简单列举几种：</p><ul><li>batching：降低 system call 的开销。</li><li>pipeline：提升 leader 向 follower 同步的吞吐量。</li><li>异步 apply：提升 raft 算法吞吐量。无法降低延迟，但能增加吞吐量。</li><li>并行同步日志与刷盘：并行 IO，提升 raft 算法吞吐量。</li><li>…</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>所有节点间仅通过三种类型的 RPC 进行通信：</p><ul><li><code>AppendEntriesRPC</code>：最常用的，leader 向 follower 发送心跳或同步日志。</li><li><code>RequestVoteRPC</code>：选举时，candidate 发起的竞选请求。</li><li><code>InstallsnapshotRPC</code>：用于 leader 下发 snapshot。</li></ul><p>在 Diego 后续的博士论文中，又增加了一些 RPCs：</p><ul><li><code>AddServerRPC</code>：添加单台节点。</li><li><code>RemoveServerRPC</code>：移除一个节点。</li><li><code>TimeoutNowRPC</code>：立刻发起竞选。<br>（实际上 etcd 的实现中定义了几十种消息类型，甚至把内部事件也封装为消息一并处理。）</li></ul><h3 id="AppendEntriesRPC"><a href="#AppendEntriesRPC" class="headerlink" title="AppendEntriesRPC"></a>AppendEntriesRPC</h3><p>参数：</p><ul><li><code>term</code>：leader 当前的 term；</li><li><code>leaderId</code>：leader 的 节点 id，让 follower 可以重定向客户端的连接；</li><li><code>prevLogIndex</code>：前一块 entry 的 index；</li><li><code>prevlogterm</code>：前一块 entry 的 term；</li><li><code>entries[]</code>：给 follower 发送的 entry，可以一次发送多个，heartbeat 时该项可缺省；</li><li><code>leaderCommit</code>：leader 当前的 <code>committed index</code>，follower 收到后可用于自己的状态机。</li></ul><p>返回：</p><ul><li><code>term</code>：响应者自己的 term；</li><li><code>success</code>：bool，是否接受请求。<br>该请求通过 leaderCommit 通知 follower 提交相应的 entries 到。通过 entries[] 复制 leader 的日志到所有的 follower。</li></ul><p>实现细节：</p><ol><li>如果 <code>term &lt; currentTerm</code>，立刻返回 false</li><li>如果 prevLogIndex 不匹配，返回 false</li><li>如果自己有块 entry 和新的 entry 不匹配（在相同的 index 上有不同的 term）， 删除自己的那一块以及之后的所有 entry；</li><li>把新的 entries 添加到自己的 log；</li><li>如果 <code>leaderCommit &gt; commitindex</code>，将 commitIndex 设置为 <code>min(leaderCommit, last index)</code>， 并且提交相应的 entries。</li></ol><h3 id="RequestVoteRPC"><a href="#RequestVoteRPC" class="headerlink" title="RequestVoteRPC"></a>RequestVoteRPC</h3><p>参数：</p><ul><li><code>term</code>：candidate 当前的 term；</li><li><code>candidateId</code>：candidate 的节点 id</li><li><code>lastlogindex</code>：candidate 最后一个 entry 的 index；</li><li><code>lastlogterm</code>：candidate 最后一个 entry 的 term。</li><li><code>isleaderTransfer</code>：用于表明该请求来自于禅让，无需等待 electionTimeout，必须立刻响应。</li><li><code>isPreVote</code>：用来表明当前是 PreVote 还是真实投票</li></ul><p>返回：</p><ul><li><code>term</code>：响应者当前的 term；</li><li><code>voteGranted</code>：bool，是否同意投票。</li></ul><p>实现细节：</p><ol><li>如果 <code>term &lt; currentTerm</code>，返回 false；</li><li>如果 votedFor 为空或者为该 <code>candidated id</code>，且日志项不落后于自己，则同意投票。</li></ol><h3 id="InstallsnapshotRPC"><a href="#InstallsnapshotRPC" class="headerlink" title="InstallsnapshotRPC"></a>InstallsnapshotRPC</h3><p>参数：</p><ul><li><code>term</code>：leader 的 term</li><li><code>leaderId</code>：leader 的 节点 id</li><li><code>lastIncludedindex</code>：snapshot 中最后一块 entry 的 index；</li><li><code>lastIncludedterm</code>：snapshot 中最后一块 entry 的 term；</li><li><code>offset</code>：该份 chunk 的 offset；</li><li><code>data[]</code>：二进制数据；</li><li><code>done</code>：是否是最后一块 chunk</li></ul><p>返回：</p><ul><li><code>term</code>：follower 当前的 term</li></ul><p>实现细节：</p><ol><li>如果 <code>term &lt; currentTerm</code> 就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃索引值小于快照的日志</li><li>如果现存的日志拥有相同的最后任期号和索引值，则后面的数据继续保持</li><li>丢弃整个日志</li><li>使用快照重置状态机</li></ol><h3 id="AddServerRPC"><a href="#AddServerRPC" class="headerlink" title="AddServerRPC"></a>AddServerRPC</h3><p>参数：</p><ul><li><code>newServer</code>：新节点地址</li></ul><p>返回：</p><ul><li><code>status</code>：bool，是否添加成功；</li><li><code>leaderHint</code>：当前 leader 的信息。</li></ul><p>实现细节：</p><ol><li>如果节点不是 leader，返回 NOT_LEADER；</li><li>如果没有在 electionTimeout 内处理，则返回 TIMEOUT；</li><li>等待上一次配置变更完成后，再处理当前变更；</li><li>将新的配置项加入 log，然后发起多数共识，通过后再提交；</li><li>返回 OK。</li></ol><h3 id="RemoveServerRPC"><a href="#RemoveServerRPC" class="headerlink" title="RemoveServerRPC"></a>RemoveServerRPC</h3><p>参数：</p><ul><li><code>oldServer</code>：要删除的节点的地址</li></ul><p>返回：</p><ul><li><code>status</code>：bool，是否删除成功；</li><li><code>leaderHint</code>：当前 leader 的信息。</li></ul><p>实现细节：</p><ol><li>如果节点不是 leader，返回 NOT_LEADER；</li><li>等待上一次配置变更完成后，再处理当前变更；</li><li>将新的配置项加入 log，然后发起多数共识，通过后再提交；</li><li>返回 OK。</li></ol><h3 id="TimeoutNowRPC"><a href="#TimeoutNowRPC" class="headerlink" title="TimeoutNowRPC"></a>TimeoutNowRPC</h3><p>由 leader 发起，告知 target 节点立刻发起竞选，无视 electionTimeout。主要用于禅让。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇博客较为详细的介绍了 raft 算法的实现，希望能对读者理解 raft 算法有所帮助。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://raft.github.io/">raft 官网</a></li><li><a href="http://thesecretlivesofdata.com/raft/">raft 动画教程</a></li><li><a href="https://raft.github.io/raft.pdf">raft 会议论文</a></li><li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">raft 博士论文</a></li><li><a href="https://blog.laisky.com/p/raft/#%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%8F%98%E6%9B%B4-ohtdR">raft 论文笔记</a></li><li><a href="http://nil.csail.mit.edu/6.824/2020/notes/l-raft.txt">6.824 Raft 讲义 1</a></li><li><a href="http://nil.csail.mit.edu/6.824/2020/notes/l-raft2.txt">6.824 Raft 讲义 2</a></li></ul><p>本文转载自 <a href="https://tanxinyu.work/raft/">谭新宇学长的博客</a> </p>]]></content>
    
    
    <categories>
      
      <category>Raft</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft共识算法</tag>
      
      <tag>MIT6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存雪崩、击穿与穿透</title>
    <link href="/2023/11/19/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E4%B8%8E%E7%A9%BF%E9%80%8F/"/>
    <url>/2023/11/19/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E4%B8%8E%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311211526588.png" alt="图片"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>为了保证缓存中的数据与数据库中的数据一致，会给缓存中的数据设置数据的过期时间，当缓存数据过期后，用户访问的数据无法从缓存中得到，就需要重新生成缓存，因此就会访问数据库，并将数据库中的数据更新到 Redis 缓存中，这样后续的请求都可以直接命中缓存。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311191358521.png" alt="图片"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311191359944.png" alt="图片"></p><p>发生缓存雪崩主要有两个原因：</p><ul><li>大量数据同时过期</li><li>Redis 故障宕机</li></ul><p>针对不同的原因，有不同的应对措施。</p><h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><ul><li>设置不同的过期时间，为数据的过期时间加上一个随机数</li><li>互斥锁</li><li>后台更新数据</li></ul><h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><ul><li>服务熔断或请求限流机制</li><li>构建 Redis 缓存高可靠集群</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>如果缓存中的<strong>某个热点数据</strong>过期了，此时大量的请求同时访问这个热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311191413682.png" alt="图片"></p><p>缓存击穿是缓存雪崩的一个子集，可以用处理缓存雪崩的后两个方法来处理：</p><ul><li>互斥锁：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等锁释放后重新读取缓存，要么就返回空值或默认值。</li><li>不给热点数据设置过期时间：由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux写时复制原理</title>
    <link href="/2023/11/19/Linux%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/19/Linux%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，调用 <code>fork</code> 系统调用创建子进程时，并不会把父进程所占用的内存页复制一份，而是与父进程共用相同的内存页，而当子进程或父进程对内存页进行修改时才会进行复制——这就是著名的 <code>写时复制</code> 机制。</p><p>下面我们将分析 Linux <code>写时复制(Copy on Write)</code> 机制的原理。</p><h3 id="写时复制原理"><a href="#写时复制原理" class="headerlink" title="写时复制原理"></a>写时复制原理</h3><p>虚拟内存需要与物理内存进行映射才能使用，如果不同进程的虚拟内存映射到了相同的物理内存，那么就实现了共享内存的机制。</p><p>Linux 为了加速创建子进程的过程，节省内存使用，实现了<strong>写时复制</strong>机制。</p><p>写时复制原理：</p><ul><li>创建子进程时，将父进程的<strong>虚拟内存</strong>与<strong>物理内存</strong>映射关系复制到子进程中，并将内存设置为<strong>只读</strong>（设置为只读时为了当对内存进行写操作时触发<strong>缺页异常</strong>）</li><li>当子进程或父进程对内存数据进行修改时，便会触发写时复制机制：将原来的内存页复制一份新的，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311191338577.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311191339006.png" alt="img"></p><p>当创建子进程时，父子进程指向<strong>相同的物理内存</strong>，而不是将父进程所占用的物理内存复制一份，这样的好处有两个：</p><ul><li>加速创建子进程的速度</li><li>减少进程对物理内存的使用</li></ul><p>当父进程调用 <code>fork</code> 创建子进程时，父进程的虚拟内存页与子进程的虚拟内存页映射到相同的物理内存页，并把父进程和子进程的虚拟内存页都设置为<strong>只读</strong>。当父进程或子进程对虚拟内存页进程写操作时，便会触发缺页异常。在缺页异常处理函数中，对物理内存页进行复制一份新的物理内存页，并且将子进程的虚拟内存页映射到新复制的物理内存页，同时将父子进程的虚拟内存页都设置为可读写。</p>]]></content>
    
    
    <categories>
      
      <category>Linux内核</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Day1_HTTP基础</title>
    <link href="/2023/11/15/Day1-HTTP%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/11/15/Day1-HTTP%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>目标</p><ul><li>简单介绍 <code>net/http</code> 库以及 <code>http.Handler</code> 接口。</li><li>搭建 <code>Gee</code> 框架的雏形，<strong>代码约50行。</strong></li></ul></blockquote><h2 id="标准库启动-Web-服务"><a href="#标准库启动-Web-服务" class="headerlink" title="标准库启动 Web 服务"></a>标准库启动 Web 服务</h2><p>Go语言内置了 <code>net/http</code> 库，封装了 HTTP 网络编程的基础的接口，我们需要实现的 <code>Gee</code> 就是基于 <code>net/http</code> 框架的。接下来通过一个例子，简单介绍下这个库的使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, indexHandler)<br>http.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>, helloHandler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里设置了两个路由，<code>/</code> 和 <code>/hello</code>， 分别绑定 indexHandler 和 helloHandler，根据不同的 HTTP 请求会调用不同的处理函数。访问 <code>/</code>，响应是 <code>URL.Path = /</code>，而 <code>/hello</code> 的响应则是请求头(header)中的键值对信息。<br>在浏览器中查看：<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311151343266.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311151343647.png" alt="image.png"><br>main 函数的最后一行，是用来启动 Web 服务的，第一个参数是地址，<code>:9999</code> 表示在9999端口监听。而第二个参数则表示处理所有的 HTTP 请求的实例，<code>nil</code> 代表使用标准库中的实例处理。第二个参数，则是我们基于 <code>net/http</code> 标准库实现 Web 框架的入口。</p><h2 id="实现-http-Handler-接口"><a href="#实现-http-Handler-接口" class="headerlink" title="实现 http.Handler 接口"></a>实现 http.Handler 接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>第二个参数类型是什么？通过查看 <code>net/http</code> 的源码可以发现，<code>Handler</code> 是一个接口，需要实现方法 <code>ServeHTTP</code> 接口的实例，所有的 HTTP 请求，就都交给了该实例处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">switch</span> req.URL.Path &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/hello&quot;</span>:<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)<br>&#125;<br><span class="hljs-keyword">default</span>:<br>fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>engine := <span class="hljs-built_in">new</span>(Engine)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:9999&quot;</span>, engine))<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们定义了一个空的结构体 <code>Engine</code> ，实现了方法 <code>ServeHTTP</code>。这个方法有2个参数，第二个参数是 Request，该对象包含了该 HTTP 请求的所有的信息，比如请求地址、Header 和 Body 等信息；第一个参数是 ResponseWriter，利用 ResponseWriter 可以构造针对该请求的响应。</li><li>在 main 函数中，我们给 ListenAndServe 方法的第二个参数闯入了刚才创建的 <code>engine</code> 实例。至此，我们走出了实现 Web 框架的第一步，即，将所有的 HTTP 请求转向了我们自己的处理逻辑。在[第一步中](#标准库启动 Web 服务)中，我们调用 http.HandleFunc 实现了路由和 Handler 的映射，也就是只能针对具体的路由写处理逻辑。比如 <code>/hello</code>。但是在实现 <code>Engine</code> 之后，我们拦截了我也的 HTTP 请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。</li><li>代码的运行结果和之前是一致的。</li></ul><h2 id="Gee-框架的雏形"><a href="#Gee-框架的雏形" class="headerlink" title="Gee 框架的雏形"></a>Gee 框架的雏形</h2><p>接下来重新组织上面的代码，搭建出整个框架的雏形。<br>最终的代码目录结构是这样的。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">gee/<br>  |--gee.<span class="hljs-built_in">go</span><br>  |--<span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>main.<span class="hljs-built_in">go</span><br><span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br></code></pre></td></tr></table></figure><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">module example<br><br><span class="hljs-keyword">go</span> <span class="hljs-number">1.21</span><br><br>require (<br>gee v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>)<br><br>replace gee =&gt; ./gee<br></code></pre></td></tr></table></figure><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gee&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gee.New()                                              <span class="hljs-comment">// 创建 gee 的实例</span><br>r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123; <span class="hljs-comment">// 使用 GET() 方法添加路由</span><br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)<br>&#125;)<br><br>r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)<br>&#125;<br>&#125;)<br><br>r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>New()</code> 创建 gee 的实例，使用 <code>GET()</code> 方法添加路由，最后使用 <code>Run()</code> 启动 Web 服务器。这里的路由，只是静态路由，不支持 <code>/hello/:name</code> 这样的动态路由，动态路由之后实现。</p><h3 id="gee-go"><a href="#gee-go" class="headerlink" title="gee.go"></a>gee.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><br><br><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<br><span class="hljs-keyword">return</span> &amp;Engine&#123;router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>engine.router[key] = handler<br>&#125;<br><br><span class="hljs-comment">// GET defines the method to add GET request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>engine.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-comment">// POST defines the method to add POST request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>engine.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>key := req.Method + <span class="hljs-string">&quot;-&quot;</span> + req.URL.Path<br><span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok &#123;<br>handler(w, req)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>gee.go</code> 是重头戏，接下来重点介绍这一部分的实现。</p><ul><li>首先定义了类型 <code>HandlerFunc</code>， 这是提供给框架用户的，用来定义路由映射的处理方法。我们在 <code>Engine</code> 中，添加了一种路由映射表 <code>router</code>，key 由请求方法和静态路由地址构成，例如 <code>GET-/</code>、<code>GET-/hello</code>、<code>POST-/hello</code>，这样针对相同的路由，如果请求方法不同，可以映射不同的处理方法(Handler)，value 是用户映射的处理方法。</li><li>当用户调用 <code>(*Engine).GET()</code> 方法时，会将路由和处理方法注册到映射表 router 中，<code>(*Engine).Run()</code> 方法，是 ListenAndServe 的包装。</li><li><code>Engine</code> 实现的 ServeHTTP 方法的作用就是解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND。</li></ul><p>执行 <code>go run main.go</code>，再在浏览器中访问，结果与最开始的一致。</p><p>至此，整个 <code>Gee</code> 框架的原型就已经出来了。实现了路由表映射，提供了用户注册静态路由的方法，包装了启动服务的函数。到目前为止，我们还没有实现比 <code>net/http</code> 标准库更强大的能力，但是我们很快就会间动态路由、中间件等功能添加上去了。</p>]]></content>
    
    
    <categories>
      
      <category>七天用Go从零实现系列</category>
      
      <category>Web框架-Gee</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>Web框架-Gee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go实现原理</title>
    <link href="/2023/11/08/Go%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/11/08/Go%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="init-函数是什么时候执行的？"><a href="#init-函数是什么时候执行的？" class="headerlink" title="init()函数是什么时候执行的？"></a>init()函数是什么时候执行的？</h3><p><code>init()</code>函数是 Go 程序初始化的一部分。Go 程序初始化先于 main函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。<br>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。<br>一句话总结： import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init1:&quot;</span>, a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;init2:&quot;</span>, a)<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, a)<br>&#125;<br><br><span class="hljs-comment">// 执行结果</span><br><span class="hljs-comment">// init1: 10</span><br><span class="hljs-comment">// init2: 10</span><br><span class="hljs-comment">// main: 10</span><br></code></pre></td></tr></table></figure><h3 id="Go语言的局部变量分配在栈上还是堆上？"><a href="#Go语言的局部变量分配在栈上还是堆上？" class="headerlink" title="Go语言的局部变量分配在栈上还是堆上？"></a>Go语言的局部变量分配在栈上还是堆上？</h3><p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>    v := <span class="hljs-number">11</span><br>    <span class="hljs-keyword">return</span> &amp;v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    m := foo()<br>    <span class="hljs-built_in">println</span>(*m) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>foo()</code>函数中，如果v分配在栈上，foo函数返回时，<code>&amp;v</code>就不存在了，但是这段函数时能够正常运行的。Go编译器发现v的引用脱离了foo的作用域，会将其分配在堆上，因此，main函数仍能够正常访问该值。</p><h3 id="2个interface可以比较吗？"><a href="#2个interface可以比较吗？" class="headerlink" title="2个interface可以比较吗？"></a>2个interface可以比较吗？</h3><p>Go语言中，interface的内部实现包含2个字段，类型<code>T</code>和值<code>V</code>，interface可以使用<code>==</code>或<code>!=</code>比较。2个interface相等有以下两种情况</p><ol><li>两个interface均等于nil（此时V和T都处于unset状态）</li><li>类型T相同，且对应的值V相等</li></ol><p>看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StuInt <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> stu1, stu2 StuInt = &amp;Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;, &amp;Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;<br><span class="hljs-keyword">var</span> stu3, stu4 StuInt = Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;<br>fmt.Println(stu1 == stu2) <span class="hljs-comment">// false</span><br>fmt.Println(stu3 == stu4) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>stu1</code>和<code>stu2</code>对应的类型是<code>*Stu</code>，值是<code>Stu</code>结构体的地址，两个地址不同，因此结果为<code>false</code>。<br><code>stu3</code>和<code>stu4</code>对应的类型是<code>Stu</code>，值是Stu结构体，且各字段相等，因此结果为true。</p><h3 id="两个nil可能不相等吗？"><a href="#两个nil可能不相等吗？" class="headerlink" title="两个nil可能不相等吗？"></a>两个nil可能不相等吗？</h3><p>可能。<br>接口(interface)是对非接口值(例如指针，struct等)的封装，内部实现包含2个字段，类型<code>T</code>和值<code>V</code>。一个接口等于nil，当且仅当T和V处于unset状态(T&#x3D;nil，V is unset)。</p><ul><li>两个接口值比较时，会先比较T，再比较V。</li><li>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = p<br>    fmt.Println(i == p) <span class="hljs-comment">// true</span><br>    fmt.Println(p == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>    fmt.Println(i == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，将一个nil非接口值p赋值给接口i，此时，i的内部字段为<code>(T = *int, V = nil)</code>，i与p作比较时，将p转换为接口后再比较，因此<code>i == p</code>，p与nil比较，直接比较值，所以<code>p == nil</code>。<br>但是当i与nil比较时，会将nil转换为接口<code>(T = nil, V = nil)</code>，与i<code>(T = *int, V = nil)</code>不相等，因此<code>i != nil</code>。因此V为nil，但T不为nil的接口不等于nil。</p><h3 id="简述Go语言GC-垃圾回收-的工作原理"><a href="#简述Go语言GC-垃圾回收-的工作原理" class="headerlink" title="简述Go语言GC(垃圾回收)的工作原理"></a>简述Go语言GC(垃圾回收)的工作原理</h3><p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。<br>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。<br>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象</li><li>灰色：存活对象，子对象待处理</li><li>黑色：存活对象</li></ul><p>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即为需要清理的对象，而黑色对象均为根可达的对象，不能被清理。<br>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。<br>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">A <span class="hljs-function"><span class="hljs-params">(黑)</span> -&gt;</span> B <span class="hljs-function"><span class="hljs-params">(灰)</span> -&gt;</span> C <span class="hljs-function"><span class="hljs-params">(白)</span> -&gt;</span> D (白)<br></code></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">A <span class="hljs-function"><span class="hljs-params">(黑)</span> -&gt;</span> B <span class="hljs-function"><span class="hljs-params">(灰)</span> -&gt;</span> C (白) <br>  ↓<br>D (白)<br></code></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。<br>一次完整的 GC 分为四个阶段：</p><ul><li>标记准备(Mark Setup，需STW)，打开写屏障(Write Barrier)</li><li>使用三色标记法标记(Marking，并发)</li><li>标记结束(Mark Termination，需STW)，关闭写屏障</li><li>清理(Sweeping，并发)</li></ul><h3 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h3><p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行<strong>逃逸分析</strong>。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p><h3 id="非接口的任意类型T-都能够调用-T的方法吗？反过来呢？"><a href="#非接口的任意类型T-都能够调用-T的方法吗？反过来呢？" class="headerlink" title="非接口的任意类型T()都能够调用*T的方法吗？反过来呢？"></a>非接口的任意类型T()都能够调用<code>*T</code>的方法吗？反过来呢？</h3><ul><li>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值时可寻址(addressable)的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法。</li><li>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型T声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p>哪些值是不可寻址的呢？</p><ul><li>字符串中的字节；</li><li>map对象中的元素(slice对象中的元素是可寻址的，slice的底层是数组)；</li><li>常量；</li><li>包级别的函数等。</li></ul><p>举一个例子，定义类型T，并为类型<code>*T</code>声明一个方法<code>hello()</code>，变量t1可以调用该方法，但是常量t2调用该方法时，会产生编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> hello() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> t1 T = <span class="hljs-string">&quot;ABC&quot;</span><br>    t1.hello() <span class="hljs-comment">// hello</span><br>    <span class="hljs-keyword">const</span> t2 T = <span class="hljs-string">&quot;ABC&quot;</span> <span class="hljs-comment">// 常量 不可寻址</span><br>    t2.hello() <span class="hljs-comment">// 会产生编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础知识</title>
    <link href="/2023/11/08/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/11/08/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="=和:=的区别"></a><code>=</code>和<code>:=</code>的区别</h3><p><code>:=</code>声明+赋值<br><code>=</code>仅赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> foo <span class="hljs-type">int</span><br>foo = <span class="hljs-number">10</span><br><span class="hljs-comment">// 等价于</span><br>foo := <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h3><p>指针用来保存变量的地址。<br>例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = &amp;x<br>fmt.Printf(<span class="hljs-string">&quot;x = %d&quot;</span>, *p) <span class="hljs-comment">// x可以用*p访问</span><br></code></pre></td></tr></table></figure><ul><li><code>*</code>运算符，也称为解引用运算符，用于访问地址中的值。</li><li><code>&amp;</code>运算符，也称为地址运算符，同于返回变量的地址。</li></ul><h3 id="Go允许多个返回值吗？"><a href="#Go允许多个返回值吗？" class="headerlink" title="Go允许多个返回值吗？"></a>Go允许多个返回值吗？</h3><p>允许</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a, b := swap(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>)<br>    fmt.Println(a, b) <span class="hljs-comment">// B A</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Go有异常类型吗？"><a href="#Go有异常类型吗？" class="headerlink" title="Go有异常类型吗？"></a>Go有异常类型吗？</h3><p>Go没有异常类型，只有错误类型(Error)，通常使用返回值来表示异常状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err := os.Open(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是协程-Goroutine"><a href="#什么是协程-Goroutine" class="headerlink" title="什么是协程(Goroutine)"></a>什么是协程(Goroutine)</h3><p>Goroutine是与其他函数或方法同时运行的函数或方法。Goroutines可以被认为是轻量级的线程。与线程相比，创建Goroutine的开销很小。Go应用程序同时运行数千个Goroutine是非常常见的做法。</p><h3 id="如何高效地凭借字符串"><a href="#如何高效地凭借字符串" class="headerlink" title="如何高效地凭借字符串"></a>如何高效地凭借字符串</h3><p>Go语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用<code>string.Builder</code>，最小化内存拷贝次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span>.Builder<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>    str.WriteString(<span class="hljs-string">&quot;a&quot;</span>)<br>&#125;<br>fmt.Println(str.String())<br></code></pre></td></tr></table></figure><h3 id="什么是rune类型"><a href="#什么是rune类型" class="headerlink" title="什么是rune类型"></a>什么是rune类型</h3><p>ASCII码只需要7bit就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了Unicode，它是ASCII码的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号(称为Unicode CodePoint)，再Go语言中称之为rune，是int32类型的别名。<br>Go语言中，字符串的底层是byte(8bit)序列，而非rune(32bit)序列。下面例子中的<code>语</code>和<code>言</code>使用UTF-8编码后各占3个byte，因此<code>len(&quot;Go语言&quot;)</code>等于8。当然我们也可以将字符串转换为rune序列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Go语言&quot;</span>)) <span class="hljs-comment">// 8</span><br>fmt.Println([]<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;Go语言&quot;</span>)) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="如何判断map中是否包含某个key"><a href="#如何判断map中是否包含某个key" class="headerlink" title="如何判断map中是否包含某个key?"></a>如何判断map中是否包含某个key?</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> val, ok := dict[<span class="hljs-string">&quot;foo&quot;</span>]; ok &#123;<br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>dict[&quot;foo&quot;]</code>有两个返回值，val和ok，如果ok等于<code>true</code>，则说明dict包含key<code>&quot;foo&quot;</code>，val将被赋予<code>&quot;foo&quot;</code>对应的值。</p><h3 id="Go支持默认参数或可选参数吗？"><a href="#Go支持默认参数或可选参数吗？" class="headerlink" title="Go支持默认参数或可选参数吗？"></a>Go支持默认参数或可选参数吗？</h3><p>Go 语言不支持可选参数（python 支持），也不支持方法重载（java支持）。</p><h3 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h3><ul><li>多个defer语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的defer语句，最先得到执行。</li><li>defer在return语句之后执行，但在函数退出之前，defer可以修改返回值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer1&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        i += <span class="hljs-number">1</span><br>        fmt.Println(<span class="hljs-string">&quot;defer2&quot;</span>)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, test())<br>&#125;<br><span class="hljs-comment">// defer2</span><br><span class="hljs-comment">// defer1</span><br><span class="hljs-comment">// return 0</span><br></code></pre></td></tr></table></figure><p>这个例子中，可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。那如果是有名的返回值呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i += <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;defer2&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, test())<br>&#125;<br><span class="hljs-comment">// defer2</span><br><span class="hljs-comment">// return 1</span><br></code></pre></td></tr></table></figure><p>这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。</p><h3 id="交换2个变量的值"><a href="#交换2个变量的值" class="headerlink" title="交换2个变量的值"></a>交换2个变量的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a, b := <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span><br>a, b = b, a<br>fmt.Println(a, b) <span class="hljs-comment">// B A</span><br></code></pre></td></tr></table></figure><h3 id="Go语言tag的用处"><a href="#Go语言tag的用处" class="headerlink" title="Go语言tag的用处"></a>Go语言tag的用处</h3><p>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架&#x2F;工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;encoding/json&quot;</span><br><br><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stu_name&quot;`</span><br>ID   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stu_id&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>buf, _ := json.Marshal(Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;t001&quot;</span>, <span class="hljs-number">18</span>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, buf)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; <code>stu_name</code>, ID -&gt; <code>stu_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。</p><h3 id="如何判断-2-个字符串切片（slice-是相等的？"><a href="#如何判断-2-个字符串切片（slice-是相等的？" class="headerlink" title="如何判断 2 个字符串切片（slice) 是相等的？"></a>如何判断 2 个字符串切片（slice) 是相等的？</h3><p>go 语言中可以使用反射 <code>reflect.DeepEqual(a, b)</code> 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。<br>通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StringSliceEqualBCE</span><span class="hljs-params">(a, b []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) != <span class="hljs-built_in">len</span>(b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">nil</span>) != (b == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    b = b[:<span class="hljs-built_in">len</span>(a)]<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>        <span class="hljs-keyword">if</span> v != b[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串打印时，-v和-v的区别"><a href="#字符串打印时，-v和-v的区别" class="headerlink" title="字符串打印时，%v和%+v的区别"></a>字符串打印时，<code>%v</code>和<code>%+v</code>的区别</h3><p><code>%v</code> 和 <code>%+v</code> 都可以用来打印 struct 的值，区别在于 <code>%v</code> 仅打印各个字段的值，<code>%+v</code> 还会打印各个字段的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;) <span class="hljs-comment">// &#123;Tom&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;) <span class="hljs-comment">// &#123;Name:Tom&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但如果结构体定义了 <code>String()</code> 方法，<code>%v</code> 和 <code>%+v</code> 都会调用 <code>String()</code> 覆盖默认值。</p><h3 id="Go语言中如何表示枚举值-enums"><a href="#Go语言中如何表示枚举值-enums" class="headerlink" title="Go语言中如何表示枚举值(enums)"></a>Go语言中如何表示枚举值(enums)</h3><p>通常使用常量(const) 来表示枚举值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StuType <span class="hljs-type">int32</span><br><br><span class="hljs-keyword">const</span> (<br>Type1 StuType = <span class="hljs-literal">iota</span><br>Type2<br>Type3<br>Type4<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Type1, Type2, Type3, Type4) <span class="hljs-comment">// 0, 1, 2, 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 struct{} 的用途</h3><p>使用空结构体 struct{} 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(unsafe.Sizeof(<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>set := <span class="hljs-built_in">make</span>(Set)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125; &#123;<br>set[item] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>fmt.Println(<span class="hljs-built_in">len</span>(set)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">if</span> _, ok := set[<span class="hljs-string">&quot;A&quot;</span>]; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;A exists&quot;</span>) <span class="hljs-comment">// A exists</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-ch<br><span class="hljs-comment">// do something</span><br>&#125;()<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，声明只包含方法的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Lamp <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> On() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;On&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> Off() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Off&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础知识</title>
    <link href="/2023/11/07/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/11/07/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="C和CPP的区别"><a href="#C和CPP的区别" class="headerlink" title="C和CPP的区别"></a>C和CPP的区别</h2><ul><li><strong>C是面向过程的语言，而C++是面向对象的语言</strong>，因此C++语言中有类和对象以及继承多态这样的OOP语言必备的内容，此外C++支持模板，运算符重载，异常处理机制，以及一个非常强大的C++标准模板库STL，另外一个Boost库现在也归属C++标准库，提供了很多强大的功能。</li><li><strong>C只能写面向过程的代码，而C++既可以写面向过程的代码，也可以实现面向对象的代码</strong>；既然C++是面向对象的OOP语言，因此它还有非常强大的设计模式，比如单例，工厂，观察者模式等等，这些在C语言当中都是不支持的。</li><li><strong>C和C++一个典型的区别就在动态内存管理上了</strong>，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的（至于new&#x2F;malloc有什么区别，delete&#x2F;free有什么区别，你等面试官来继续深入问你，先从大方向上罗列区别）</li><li><strong>另外强制类型转换上也不一样</strong>，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast</li><li><strong>C和C++的输入输出方式也不一样</strong>，printf&#x2F;scanf，和C++的cout&#x2F;cin的对别，前面一组是C的库函数，后面是ostream和istream类型的对象。</li><li><strong>C++还支持带有默认值的函数</strong>，函数的重载，inline内联函数，这些C语言都不支持，当然还有const这个关键字，C和C++也是有区别的，但是这都是目前最常用的C89标准的C内容，在C99标准里面，C语言借鉴了C++的const和inline关键字，这两方面就和C++一样了。</li><li><strong>由于C++多了一个类，因此和C语言的作用域比起来，就多了一个类作用域</strong>，此外，C++还支持namespace名字空间，可以让用户自己定义新的名字空间作用域出来，避免全局的名字冲突问题。</li><li><strong>C++不仅支持指针，还支持更安全的引用，不过在汇编代码上，指针和引用的操作是一样的</strong></li><li><strong>由于C++是面向对象的语言，支持类对象，类和类之间的代理，组合，继承，多态等等面向对象的设计，有很多的设计模式可以直接使用</strong>，因此在设计大型软件的时候，通常都会采用面向对象语言，而不会采用面向过程语言，可以更好的进行模块化设计，做到软件设计的准则：高内聚，低耦合！</li><li><strong>在C++中，struct关键字不仅可以用来定义结构体，它也可以用来定义类</strong>（至于C++中struct和class的区别，请大家自行翻阅资料）</li><li><strong>C和C++的内存分布有什么区别？</strong><br>C和C++程序运行时的内存分布是一样的，但是他们管理堆内存的方式是有区别的，自己先想想new&#x2F;malloc有什么区别，delete&#x2F;free有什么区别这两个问题，另外，new分配内存失败是抛出异常的，而不是通过返回值和NULL比较进行判断的，请注意！</li></ul><h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。</p><p><strong>面向对象编程的特性</strong>：三大基本特性：封装，继承，多态</p><h2 id="如何实现多态？"><a href="#如何实现多态？" class="headerlink" title="如何实现多态？"></a>如何实现多态？</h2><h3 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><ul><li>在类的定义中，前面有<code>virtual</code>关键字的成员函数称为虚函数；</li><li><code>virtual</code>关键字只用在类定义里的函数声明中，写函数体时不用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Base::Fun</span><span class="hljs-params">()</span> <span class="hljs-comment">// virtual字段不用在函数体时定义</span></span><br><span class="hljs-function"></span>&#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="多态的表现形式一"><a href="#多态的表现形式一" class="headerlink" title="多态的表现形式一"></a>多态的表现形式一</h4><ul><li>[派生类的指针]可以赋值给[基类指针]；</li><li>通过基类指针调用基类和派生类中的同名[虚函数]时:<ul><li>若该指针指向一个基类的对象，那么被调用是 <strong>基类的虚函数</strong>；</li><li>若该指针指向一个派生类的对象，那么被调用是 <strong>派生类的虚函数</strong>。</li></ul></li></ul><p>这种机制就叫做“多态”，说白点就是<strong>调用哪个虚函数，取决于指针指向哪种类型的对象</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;CFather virtual fun&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;CSon virtual fun&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>CSon son; <span class="hljs-comment">// 一个CSon对象</span><br>CFather* p = &amp;son; <span class="hljs-comment">// 一个CFather指针指向一个CSon类型的对象</span><br>p-&gt;<span class="hljs-built_in">Fun</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例子中的<code>p</code>指针对象指向的是<code>CSon</code>类对象，所以<code>p-&gt;Fun()</code>调用的是<code>CSon</code>类里的<code>Fun</code>成员函数。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137487.png" alt="image.png"></p><h4 id="多态的表现形式二"><a href="#多态的表现形式二" class="headerlink" title="多态的表现形式二"></a>多态的表现形式二</h4><ul><li>派生类的对象可以赋给基类[引用]</li><li>通过基类引用调用基类和派生类中的同名[虚函数]时:<ul><li>若该引用引用的是一个基类的对象，那么被调用是 <strong>基类的虚函数</strong>；</li><li>若该引用引用的是一个派生类的对象，那么被调用的是 <strong>派生类的虚函数</strong>。</li></ul></li></ul><p>这种机制也叫做“多态”，说白点就是<strong>调用哪个虚函数，取决于引用的对象是哪种类型的对象</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;CFather virtual fun&quot;</span> &lt;&lt; endl; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;CSon virtual fun&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>CSon son; <span class="hljs-comment">// 一个CSon对象</span><br>CFather &amp;r = son; <br>r.<span class="hljs-built_in">Fun</span>();  <span class="hljs-comment">//调用哪个虚函数取决于 r 引用哪种类型的对象</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子中的<code>r</code>引用的对象是CSon类对象，所以<code>r.Fun()</code>调用的是<code>CSon</code>类里的<code>Fun</code>成员函数。</p><h4 id="多态的简单示例"><a href="#多态的简单示例" class="headerlink" title="多态的简单示例"></a>多态的简单示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 继承A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 继承A类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 继承B类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;E::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>A类、B类、E类、D类的关系如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072138190.png" alt="类关系"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a; B b; E e; D d;<br><br>    A* pa = &amp;a;<br>    B* pb = &amp;b;<br>    D* pd = &amp;d;<br>    E* pe = &amp;e;<br><br>    pa-&gt;<span class="hljs-built_in">Print</span>();  <span class="hljs-comment">// a.Print()被调用，输出：A::Print</span><br><br>    pa = pb;<br>    pa-&gt;<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// b.Print()被调用，输出：B::Print</span><br><br>    pa = pd;<br>    pa-&gt;<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// d.Print()被调用，输出：D::Print</span><br><br>    pa = pe;<br>    pa-&gt;<span class="hljs-built_in">Print</span>(); <span class="hljs-comment">// e.Print()被调用，输出：E::Print</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h4><p>在面向对象的程序设计中使用[多态]，能够增强程序的<strong>可扩充性</strong>，即程序需要修改或增加功能的时候，需要<strong>改动和增加的代码较少</strong>。</p><h3 id="LOL-英雄联盟游戏例子"><a href="#LOL-英雄联盟游戏例子" class="headerlink" title="LOL 英雄联盟游戏例子"></a>LOL 英雄联盟游戏例子</h3><p>下面我们用设计 LOL 英雄联盟游戏的英雄的例子，说明多态为什么可以在修改或增加功能的时候，可以较少的改动代码。<br>LOL 英雄联盟是 5v5 竞技游戏，游戏中有很多英雄，每种英雄都有一个「类」与之对应，每个英雄就是一个「对象」。<br>英雄之间能够互相攻击，攻击敌人和被攻击时都有相应的动作，动作是通过对象的成员函数实现的。<br>下面挑了五个英雄：</p><ul><li>探险家 CEzreal</li><li>盖楼 CGaren</li><li>盲僧 CLeesin</li><li>无极剑圣 CYi</li><li>瑞兹 CRyze</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072138086.png" alt="五个英雄类"></p><p>基本思路：</p><ol><li>为每个英雄类编写 <code>Attack</code>、<code>FightBack</code> 和 <code>Hurted </code>成员函数。</li></ol><ul><li><code>Attack </code>函数表示攻击动作；</li><li><code>FightBack </code>函数表示反击动作；</li><li><code>Hurted </code>函数表示减少自身生命值，并表现受伤动作。</li></ul><ol><li>设置基类<code>CHero</code>，每个英雄类都继承此基类</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137498.png" alt="英雄类关系"></p><h4 id="非多态的实现方法"><a href="#非多态的实现方法" class="headerlink" title="非多态的实现方法"></a>非多态的实现方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CHero</span> <br>&#123;<br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-type">int</span> m_nPower ; <span class="hljs-comment">//代表攻击力</span><br>    <span class="hljs-type">int</span> m_nLifeValue ; <span class="hljs-comment">//代表生命值</span><br>&#125;;<br><br><br><span class="hljs-comment">// 无极剑圣类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CYi</span> : <span class="hljs-keyword">public</span> CHero <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 攻击盖伦的攻击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">(CGaren * pGaren)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        .... <span class="hljs-comment">// 表现攻击动作的代码</span><br>        pGaren-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower);<br>        pGaren-&gt;<span class="hljs-built_in">FightBack</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 攻击瑞兹的攻击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">(CRyze * pRyze)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        .... <span class="hljs-comment">// 表现攻击动作的代码</span><br>        pRyze-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower);<br>        pRyze-&gt;<span class="hljs-built_in">FightBack</span>( <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 减少自身生命值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hurted</span><span class="hljs-params">(<span class="hljs-type">int</span> nPower)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ... <span class="hljs-comment">// 表现受伤动作的代码</span><br>        m_nLifeValue -= nPower;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 反击盖伦的反击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FightBack</span><span class="hljs-params">(CGaren * pGaren)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ...．<span class="hljs-comment">// 表现反击动作的代码</span><br>        pGaren-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower/<span class="hljs-number">2</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 反击瑞兹的反击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FightBack</span><span class="hljs-params">(CRyze * pRyze)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ...．<span class="hljs-comment">// 表现反击动作的代码</span><br>        pRyze-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有 n 种英雄，<code>CYi </code>类中就会有 n 个 <code>Attack</code>成员函数，以及 n 个 <code>FightBack</code>成员函数。对于其他类也如此。<br>如果游戏版本升级，增加了新的英雄寒冰艾希 <code>CAshe</code>，则程序改动较大。所有的类都需要增加两个成员函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">(CAshe * pAshe)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FightBack</span><span class="hljs-params">(CAshe * pAshe)</span></span>;<br></code></pre></td></tr></table></figure><p>这样工作量是非常大的！！非常的不人性，所以这种设计方式是非常的不好！</p><h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><p>用多态的方式去实现，就能得知多态的优势了，那么上面的栗子改成多态的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CHero</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">(CHero *pHero)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">voidFightBack</span><span class="hljs-params">(CHero *pHero)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Hurted</span><span class="hljs-params">(<span class="hljs-type">int</span> nPower)</span></span>&#123;&#125;<br><br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-type">int</span> m_nPower ; <span class="hljs-comment">//代表攻击力</span><br>    <span class="hljs-type">int</span> m_nLifeValue ; <span class="hljs-comment">//代表生命值</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类 CYi:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CYi</span> : <span class="hljs-keyword">public</span> CHero &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 攻击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">(CHero * pHero)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        .... <span class="hljs-comment">// 表现攻击动作的代码</span><br>        pHero-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower); <span class="hljs-comment">// 多态</span><br>        pHero-&gt;<span class="hljs-built_in">FightBack</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 多态</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 减少自身生命值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hurted</span><span class="hljs-params">(<span class="hljs-type">int</span> nPower)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ... <span class="hljs-comment">// 表现受伤动作的代码</span><br>        m_nLifeValue -= nPower;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 反击函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FightBack</span><span class="hljs-params">(CHero * pHero)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ...．<span class="hljs-comment">// 表现反击动作的代码</span><br>        pHero-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower/<span class="hljs-number">2</span>); <span class="hljs-comment">// 多态</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果增加了新的英雄寒冰艾希 CAshe，只需要编写新类CAshe，不再需要在已有的类里专门为新英雄增加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Attack</span><span class="hljs-params">( CAshe * pAshe)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FightBack</span><span class="hljs-params">(CAshe * pAshe)</span></span>;<br></code></pre></td></tr></table></figure><p>所以已有的类可以原封不动，那么使用多态的特性新增英雄的时候，可见改动量是非常少的。<br>多态使用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CYi::Attack</span><span class="hljs-params">(CHero * pHero)</span> </span><br><span class="hljs-function"></span>&#123;<br>    pHero-&gt;<span class="hljs-built_in">Hurted</span>(m_nPower); <span class="hljs-comment">// 多态</span><br>    pHero-&gt;<span class="hljs-built_in">FightBack</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 多态</span><br>&#125;<br><br>CYi yi; <br>CGaren garen; <br>CLeesin leesin; <br>CEzreal ezreal;<br><br>yi.<span class="hljs-built_in">Attack</span>( &amp;garen );  <span class="hljs-comment">//(1)</span><br>yi.<span class="hljs-built_in">Attack</span>( &amp;leesin ); <span class="hljs-comment">//(2)</span><br>yi.<span class="hljs-built_in">Attack</span>( &amp;ezreal ); <span class="hljs-comment">//(3)</span><br></code></pre></td></tr></table></figure><p>根据多态的规则，上面的(1)，(2)，(3)进入到 CYi::Attack 函数后 ，分别调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CGaren::Hurted<br>CLeesin::Hurted<br>CEzreal::Hurted<br></code></pre></td></tr></table></figure><h3 id="多态的又一例子"><a href="#多态的又一例子" class="headerlink" title="多态的又一例子"></a>多态的又一例子</h3><p>下面的代码，<code>pBase-&gt;fun1()</code>输出结果是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">fun2</span>(); <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived:fun2()&quot;</span> &lt;&lt; endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Derived d;<br>    Base * pBase = &amp; d;<br>    pBase-&gt;<span class="hljs-built_in">fun1</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072139341.png" alt="image.png"><br>调用的是子类的<code>fun2()</code>虚函数。原因：<br>我们将上面的代码转换一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">fun2</span>();  <span class="hljs-comment">// this是基类指针，fun2是虚函数，所以是多态</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code>指针的作用就是指向该成员函数所作用的对象，所以非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针。<br><code>pBase</code>指针对象指向的是派生类对象，派生类里没有 <code>fun1</code>成员函数，所以就会调用基类的 <code>fun1</code>成员函数，在<code>Base::fun1()</code>成员函数体里执行<code>this-&gt;fun2()</code>时，实际上指向的是派生类对象的 <code>fun2</code>成员函数。<br>所以正确的输出结果是：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Derived:fu<span class="hljs-symbol">n2</span><span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>所以我们需要注意：<strong>在非构造函数，非析构函数的成员函数中调用「虚函数」，是多态!!!</strong></p><h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><p>「多态」的关键在于通过<strong>基类指针或引用</strong>调用一个<strong>虚函数</strong>时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。<br>我们用 <code>sizeof</code>来运算有虚函数的类和没虚函数的类的大小，会是什么结果呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(B);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在64位机子，执行的结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">16</span>,<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>从上面的结果，可以发现有虚函数的类，多出了 8 个字节，在 64 位机子上指针类型大小正好是 8 个字节，这多出 8 个字节的指针有什么作用呢？<br>为什么是多出8个字节，这里是字节对齐的原因。</p><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着<strong>虚函数表的指针</strong>。「虚函数表」中列出了该类的「虚函数」地址。<br><strong>多出来的 8 个字节就是用来放「虚函数表」的地址。</strong><br><strong>总结：</strong>类中放的是<strong>虚函数表的地址</strong>，对象中放的是<strong>指向虚函数表的指针(也就是指向类中放的那个虚函数表的地址)<strong>，虚函数表中放的是</strong>这个类中的所有虚函数的地址。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面 Derived 类继承了 Base类，两个类都有「虚函数」，那么它「虚函数表」的形式可以理解成下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137660.png" alt="虚函数表图"></p><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中<strong>存放的虚函数表的地址</strong>，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p><h4 id="证明虚函数指针的作用"><a href="#证明虚函数指针的作用" class="headerlink" title="证明虚函数指针的作用"></a>证明虚函数指针的作用</h4><p>在上面我们用 <code>sizeof</code>运算符计算了有虚函数的类的大小，发现是多出了 8 字节大小（64位系统），这多出来的 8 个字节就是指向「虚函数表的指针」。「虚函数表」中列出了该类的「虚函数」地址。<br>下面用代码的例子，来证明「虚函数表指针」的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;A::Func&quot;</span> &lt;&lt; endl; <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A <br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;B::Func&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    <br>    A * pa = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    pa-&gt;<span class="hljs-built_in">Func</span>(); <span class="hljs-comment">// 多态</span><br>    <br>    <span class="hljs-comment">// 64位程序指针为8字节</span><br>    <span class="hljs-type">int</span> * p1 = (<span class="hljs-type">int</span> *) &amp; a;<br>    <span class="hljs-type">int</span> * p2 = (<span class="hljs-type">int</span> *) pa;<br>    <br>    * p2 = * p1;<br>    pa-&gt;<span class="hljs-built_in">Func</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">B::Func<br>A::Func<br></code></pre></td></tr></table></figure><ul><li>第 25-26 行代码中的 <code>pa</code>指针指向的是 <code>B</code>类对象，所以<code>pa-&gt;Func()</code>调用的是 <code>B</code>类对象的虚函数 <code>Func()</code>，输出内容是 <code>B::Func</code>；</li><li>第 29-30 行代码的目的是把<code>A</code>类的头 8 个字节的「虚函数表指针」存放到<code>p1</code>指针和把<code>B</code>类的头 8 个字节的「虚函数表指针」存放到<code>p2</code>指针；</li><li>第 32 行代码目的是把<code>A</code>类的「虚函数表指针」 赋值给<code>B</code>类的「虚函数表指针」，所以相当于把<code>B</code>类的「虚函数表指针」 替换 成了<code>A</code>类的「虚函数表指针」；</li><li>由于第 32 行的作用，把B<code>类</code>的「虚函数表指针」 替换 成了<code>A</code>类的「虚函数表指针」，所以第 33 行调用的是<code>A</code>类的虚函数<code>Func()</code>，输出内容是<code>A::Func</code></li></ul><p>通过上述的代码和讲解，可以有效的证明了「虚函数表的指针」的作用，「虚函数表的指针」指向的是「虚函数表」，「虚函数表」里存放的是类里的「虚函数」地址，那么在调用过程中，就能实现多态的特性。</p><h3 id="构造函数和析构函数中存在多态吗？"><a href="#构造函数和析构函数中存在多态吗？" class="headerlink" title="构造函数和析构函数中存在多态吗？"></a>构造函数和析构函数中存在多态吗？</h3><p>在构造函数和析构函数中调用「虚函数」，不是多态。编译时即可确定调用的函数是<strong>自己的类中定义的函数还是基类中定义的函数</strong>，不会等到运行时才决定调用自己的还是派生类的函数。<br>我们看如下的代码例子，来说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFather</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello from father&quot;</span>&lt;&lt;endl; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bye</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;bye from father&quot;</span>&lt;&lt;endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSon</span> : <span class="hljs-keyword">public</span> CFather<br>&#123; <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CSon</span>() <span class="hljs-comment">// 构造函数</span><br>&#123; <br>    <span class="hljs-built_in">hello</span>();<br>&#125;<br><br>~<span class="hljs-built_in">CSon</span>()  <span class="hljs-comment">// 析构函数</span><br>&#123; <br>    <span class="hljs-built_in">bye</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-comment">// 虚函数</span></span><br><span class="hljs-function"></span>&#123; <br>    cout&lt;&lt;<span class="hljs-string">&quot;hello from son&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CSon son; <span class="hljs-comment">// 构造son对象时执行构造函数 输出 hello from son</span><br>    CFather *pfather;<br>    pfather = &amp; son;<br>    pfather-&gt;<span class="hljs-built_in">hello</span>(); <span class="hljs-comment">// 多态 调用son的虚函数hello()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hello from son  <span class="hljs-comment">// 构造son对象时执行的构造函数</span><br>hello from son  <span class="hljs-comment">// 多态</span><br>bye from father <span class="hljs-comment">// son对象析构时，由于CSon类没有bye成员函数，所以调用了基类的bye成员函数</span><br></code></pre></td></tr></table></figure><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>析构函数是在删除对象或退出程序的时候，自动调用的函数，其目的是做一些资源释放。<br>那么在多态的情景下，通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数，这就会存在派生类对象的析构函数没有调用到，存在资源泄露的情况。<br>看如下的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()  <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A <br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">B</span>()  <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    ~<span class="hljs-built_in">B</span>()<span class="hljs-comment">// 析构函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    A *pa = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> pa;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">construct A<br>construct B<br>Destructor A<br></code></pre></td></tr></table></figure><p>从上面的输出结果可以看到，在删除 <code>pa</code>指针对象时，<code>B</code>类的析构函数没有被调用。<br><strong>解决办法：把基类的析构函数声明为virtual</strong></p><ul><li>派生类的析构函数可以不用<code>virtual</code>进行声明；</li><li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数，还是遵循「先构造，后析构」的规则。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">A</span>()  <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() <span class="hljs-comment">// 虚析构函数</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">construct A<br>construct B<br>Destructor B<br>Destructor A<br></code></pre></td></tr></table></figure><p>所以要养成好习惯:</p><ul><li>一个类如果定义了虚函数，则应该将析构函数也定义成虚函数;</li><li>或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</li><li>注意：不允许构造函数不能定义成虚构造函数。</li></ul><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>纯虚函数： 没有函数体的虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">( )</span> </span>= <span class="hljs-number">0</span> ; <span class="hljs-comment">//纯虚函数</span><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>包含纯虚函数的类叫抽象类</p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">A a<span class="hljs-comment">;         // 错，A 是抽象类，不能创建对象</span><br>A * pa <span class="hljs-comment">;     // ok,可以定义抽象类的指针和引用</span><br><span class="hljs-attribute">pa</span> <span class="hljs-operator">=</span> new A <span class="hljs-comment">; // 错误, A 是抽象类，不能创建对象</span><br></code></pre></td></tr></table></figure><h2 id="什么是右值引用？"><a href="#什么是右值引用？" class="headerlink" title="什么是右值引用？"></a>什么是右值引用？</h2><h3 id="左值与左值引用"><a href="#左值与左值引用" class="headerlink" title="左值与左值引用"></a>左值与左值引用</h3><p>什么是左值引用？<br><strong>左值引用，就是绑定到左值的引用，通过&amp;来获得左值引用</strong>。<br>那么，什么是左值呢？<br><strong>左值，就是在内存有确定存储地址、有变量名，表达式结束依然存在的值</strong>。<br>左值可以分为两类：非常量左值和常量左值；同理，右值也可以分为两类：非常量右值和常量左值。左值引用举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;              <span class="hljs-comment">// a是非常量左值（有确定存储地址，也有变量名）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a1=<span class="hljs-number">10</span>;       <span class="hljs-comment">// a1是常量左值（有确定存储地址，也有变量名）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a2=<span class="hljs-number">20</span>;       <span class="hljs-comment">// a2是常量左值（有确定存储地址，也有变量名）</span><br><br><span class="hljs-comment">//非常量左值引用</span><br><span class="hljs-type">int</span> &amp;b1=a;            <span class="hljs-comment">// 正确，a是一个非常量左值，可以被非常量左值引用绑定</span><br><span class="hljs-type">int</span> &amp;b2=a1;           <span class="hljs-comment">// 错误，a1是一个常量左值，不可以被非常量左值引用绑定</span><br><span class="hljs-type">int</span> &amp;b3=<span class="hljs-number">10</span>;           <span class="hljs-comment">// 错误，10是一个非常量右值，不可以被非常量左值引用绑定</span><br><span class="hljs-type">int</span> &amp;b4=a1+a2;        <span class="hljs-comment">// 错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span><br><br><span class="hljs-comment">//常量左值引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c1=a;      <span class="hljs-comment">// 正确，a是一个非常量左值，可以被常量左值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c2=a1;     <span class="hljs-comment">// 正确，a1是一个常量左值，可以被常量左值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c3=a+a1;   <span class="hljs-comment">// 正确，（a+a1）是一个非常量右值，可以被常量左值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c4=a1+a2;  <span class="hljs-comment">// 正确，（a1+a2）是一个常量右值，可以被常量左值引用绑定</span><br></code></pre></td></tr></table></figure><p>可以归纳为：<strong>非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型</strong>。</p><h3 id="右值与右值引用"><a href="#右值与右值引用" class="headerlink" title="右值与右值引用"></a>右值与右值引用</h3><p>什么是右值引用？<br><strong>右值引用，就是绑定到右值的引用，通过&amp;&amp;来获得右值引用</strong>。<br>什么是右值？<br><strong>右值，就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值</strong>。<br>右值引用举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;             <span class="hljs-comment">// a是非常量左值（有确定存储地址，也有变量名）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a1=<span class="hljs-number">20</span>;      <span class="hljs-comment">// a1是常量左值（有确定存储地址，也有变量名）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a2=<span class="hljs-number">20</span>;      <span class="hljs-comment">// a2是常量左值（有确定存储地址，也有变量名）</span><br><br><span class="hljs-comment">//非常量右值引用</span><br><span class="hljs-type">int</span> &amp;&amp;b1=a;            <span class="hljs-comment">// 错误，a是一个非常量左值，不可以被非常量右值引用绑定</span><br><span class="hljs-type">int</span> &amp;&amp;b2=a1;           <span class="hljs-comment">// 错误，a1是一个常量左值，不可以被非常量右值引用绑定</span><br><span class="hljs-type">int</span> &amp;&amp;b3=<span class="hljs-number">10</span>;           <span class="hljs-comment">// 正确，10是一个非常量右值，可以被非常量右值引用绑定</span><br><span class="hljs-type">int</span> &amp;&amp;b4=a1+a2;        <span class="hljs-comment">// 错误，（a1+a2）是一个常量右值，不可以被非常量右值引用绑定</span><br><br><span class="hljs-comment">//常量右值引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c1=a;      <span class="hljs-comment">// 错误，a是一个非常量左值，不可以被常量右值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c2=a1;     <span class="hljs-comment">// 错误，a1是一个常量左值，不可以被常量右值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c3=a+a1;   <span class="hljs-comment">// 正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c4=a1+a2;  <span class="hljs-comment">// 正确，（a1+a2）是一个常量右值，可以被常量右值引用绑定</span><br></code></pre></td></tr></table></figure><p>可以将右值引用归纳为：<strong>非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上</strong>。<br>从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？<br>C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即<strong>直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用</strong>。<br>std::move使用举例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;                 <span class="hljs-comment">// a是非常量左值（有确定存储地址，也有变量名）</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a1=<span class="hljs-number">20</span>;          <span class="hljs-comment">// a1是常量左值（有确定存储地址，也有变量名）</span><br><br><span class="hljs-comment">//非常量右值引用</span><br><span class="hljs-type">int</span> &amp;&amp;d1=std::<span class="hljs-built_in">move</span>(a);    <span class="hljs-comment">// 正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定</span><br><span class="hljs-type">int</span> &amp;&amp;d2=std::<span class="hljs-built_in">move</span>(a1);    <span class="hljs-comment">// 错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定</span><br><br><span class="hljs-comment">//常量右值引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c1=std::<span class="hljs-built_in">move</span>(a);      <span class="hljs-comment">// 正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;c2=std::<span class="hljs-built_in">move</span>(a1);     <span class="hljs-comment">// 正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定</span><br></code></pre></td></tr></table></figure><p>可以发现，编译器利用std::move将左值强制转换为相同类型的右值之后，引用情况跟右值是一模一样的。</p><h3 id="右值引用与左值引用的区别"><a href="#右值引用与左值引用的区别" class="headerlink" title="右值引用与左值引用的区别"></a>右值引用与左值引用的区别</h3><ol><li>左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象仍然存在；右值引用绑定到要求转换的表达式、字面变量、返回右值的表达式等临时对象上，赋值表达式结束后对象就会被销毁。</li><li>左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。</li></ol><h3 id="引入右值引用的原因"><a href="#引入右值引用的原因" class="headerlink" title="引入右值引用的原因"></a>引入右值引用的原因</h3><ol><li><strong>替代需要销毁对象的拷贝，提高效率</strong>：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存；引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；</li><li><strong>移动含有不能共享资源的类对象</strong>：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。</li></ol><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><h3 id="指针和引用的定义和本质区别"><a href="#指针和引用的定义和本质区别" class="headerlink" title="指针和引用的定义和本质区别"></a>指针和引用的定义和本质区别</h3><ol><li>指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是一个东西，只不过是原变量的一个别名而已。如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> *p = &amp;a;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> &amp;b = a;<br></code></pre></td></tr></table></figure><p>上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。<br>而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。</p><ol start="2"><li>可以有<strong>const指针</strong>，但是没有const引用</li><li><strong>指针可以有多级</strong>，但是<strong>引用只能是一级</strong>（<code>int **p</code>；合法 而 <code>int &amp;&amp;a</code>是不合法的，<code>int &amp;&amp;a</code>是右值引用）</li><li><strong>指针的值可以为空</strong>，但是<strong>引用</strong>的值<strong>不能为NULL</strong>，并且引用在定义的时候必须初始化；</li><li><strong>指针</strong>的值在初始化后<strong>可以改变</strong>，即指向其它的存储单元，而<strong>引用</strong>在进行初始化后就不会再改变了，<strong>从一而终</strong>。</li><li>“sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；</li><li>指针和引用的自增(++)运算意义不一样；</li></ol><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；引用时某块地址的别名。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol><li><strong>引用在语言内部用指针实现(如何实现？)</strong></li><li>对一般应用而言，把引用理解为指针，不会犯严重语义错误。<strong>引用是操作受限了的指针</strong>（仅容许取内容操作）。</li></ol><p>引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n是m的一个引用（reference），m 是被引用物（referent）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> &amp;n = m;<br></code></pre></td></tr></table></figure><p>n 相当于m 的别名（绰号），<strong>对n的任何操作就是对m的操作</strong>。<br>引用的一些规则：</p><ol><li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li><li>不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li><li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li></ol><p>以下示例，k被初始化为i的引用。语句k &#x3D; j是把k的值改变成为6，由于k是i的引用，所以i的值也变成了6.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> &amp;k = i;<br>k = j; <span class="hljs-comment">// k 和i 的值都变成了6</span><br></code></pre></td></tr></table></figure><p><strong>引用的主要功能是传递函数的参数和返回值</strong>。C++语言中，<strong>函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。</strong><br>“引用传递”的性质像“指针传递”，而书写方式像“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，<strong>为什么还要“引用”这东西</strong>？<br>答案是“用适当的工具做恰如其分的工作”。<br><strong>指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险</strong>。<br>就像一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？<br><strong>如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外</strong>。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。<br><strong>总的来说，在以下情况下你应该使用指针：</strong></p><ol><li>你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）</li><li>你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。</li></ol><p><strong>当你重载某个操作符时，你应该使用引用</strong>。<br><strong>尽可能使用引用，不得已时使用指针</strong>。<br>当你<strong>不需要“重新指向”时，引用一般优先于指针被选用</strong>。这通常意味着<strong>引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部</strong>。</p><h2 id="创建对象是先调用父类构造函数还是子类，销毁呢"><a href="#创建对象是先调用父类构造函数还是子类，销毁呢" class="headerlink" title="创建对象是先调用父类构造函数还是子类，销毁呢?"></a>创建对象是先调用父类构造函数还是子类，销毁呢?</h2><p>创建对象先调用父类构造函数，再调用子类构造函数。</p><h2 id="内存中栈区和堆区的区别"><a href="#内存中栈区和堆区的区别" class="headerlink" title="内存中栈区和堆区的区别"></a>内存中栈区和堆区的区别</h2><p>C++中，内存分为5个区：堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p><p><strong>栈</strong>：是由编译器再需要时自动分配，不需要自动清楚的变量存储区。通常存放局部变量、函数参数等。</p><p><strong>堆</strong>：是由new分配的内存块，由程序员释放(编译器不管)，一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。</p><p><strong>自由存储区</strong>：是由malloc等分配的内存块，和堆十分相似，用free来释放。</p><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中(在C语言中，全局变量又分为初始化的和未初始化的，C++中没有这一区分)。</p><p><strong>常量存储区</strong>：这是一块特殊存储区，里面存放常量，不允许修改。<br>（注意：堆和自由存储区其实不过是同一块区域，new底层实现代码中调用了malloc，new可以看成是malloc智能化的高级版本）</p><h3 id="栈与堆的讨论"><a href="#栈与堆的讨论" class="headerlink" title="栈与堆的讨论"></a>栈与堆的讨论</h3><ol><li>管理方式：堆中资源由程序员控制(容易产生memory leak)，栈资源由编译器自动管理，无需手工控制。</li><li>系统相应：对于堆，应该知道系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆节点，删除空闲节点链表的该节点，并将该节点空间分配给程序(大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中)。对于栈，只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。</li><li>空间大小：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit位机器，理论上是4G的虚拟内存），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有时1M，在编译时确定，VC中可设置）。</li><li>碎片问题：对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低。 对于栈，它是一个先进后出的队列，进出一一对应，不会产生碎片。</li><li>地址增长方向：堆向上，向高地址方向增长。栈向下，向低地址方向增长。</li><li>分配方式：堆都是动态分配（没有静态分配的堆）。栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</li><li>分配效率：堆由C&#x2F;C++函数库提供，机制很复杂。所以堆的效率比栈低很多。栈是机器系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令。</li></ol><h2 id="如何在栈上动态分配内存"><a href="#如何在栈上动态分配内存" class="headerlink" title="如何在栈上动态分配内存"></a>如何在栈上动态分配内存</h2><p>利用 <code>alloca</code> 可以在栈上动态分配内存，不需要手动释放，但是需要注意的是，<code>alloca</code> 不具有可移植性，而且在没有传统堆栈的机器上很难实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)alloca(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">free</span>(p); <span class="hljs-comment">// 此时不能用 free() 去释放，会导致错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="malloc-和-new-的区别"><a href="#malloc-和-new-的区别" class="headerlink" title="malloc 和 new 的区别"></a>malloc 和 new 的区别</h2><ol><li>malloc 和 new 都是在堆上开辟内存</li></ol><p>malloc只负责开辟内存，没有初始化功能，需要用户自己初始化；new不但开辟内存，还可以进行初始化，如<code>new int(10);</code>表示在堆上开辟了一个4字节的int整形内存，初始值时10，再如<code>new int[10] ();</code>表示在堆上开辟了一个包含了10个整形元素的数组，初始值都为0。</p><ol start="2"><li>malloc是函数，开辟内存需要传入字节数，如malloc(100)；表示在堆上开辟了100个字节的内存，返回void*，表示分配的堆内存的起始地址，因此malloc的返回值需要强转成指定类型的地址；new是运算符，开辟内存需要指定类型，返回指定类型的地址，因此不需要进行强转。</li></ol><p>如堆上开辟int整形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p1 = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 根据传入字节数开辟内存，没有初始化</span><br><br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 根据指定类型int开辟一个整形内存，初始化为0</span><br><br><span class="hljs-type">int</span> *p3 = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">100</span>); <span class="hljs-comment">//  开辟400个字节的内存，相当于包含100个整形元素的数组，没有初始化</span><br><br><span class="hljs-type">int</span> *p4 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>](); <span class="hljs-comment">// 开辟400个字节的内存，100个元素的整形数组，元素都初始化为0  </span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>malloc 开辟内存失败返回 NULL，new 开辟内存失败抛出 bad_alloc 类型的异常</strong>，需要捕获异常才能判断内存开辟成功或失败，new运算符其实是operator new函数的调用，它底层调用的也是 malloc 来开辟内存的，new 它比 malloc 多的就是初始化功能，对于类型来说，所谓初始化，就是调用相应的构造函数。</li><li><strong>malloc 开辟的内存永远是通过 free 来释放的；而 new 单个元素内存，用的是 delete，如果 new[] 数组，用的是 delete[] 来释放内存的</strong>。</li><li>malloc 开辟内存只有一种方式，而new有四种<strong>分别是普通的new（内存开辟失败抛出bad_alloc异常）, nothrow版本的 new，const new 以及定位 new</strong>。</li></ol><h2 id="i-和-i-是否为原子操作？应该如何保证它的原子性？"><a href="#i-和-i-是否为原子操作？应该如何保证它的原子性？" class="headerlink" title="++i 和 i++ 是否为原子操作？应该如何保证它的原子性？"></a>++i 和 i++ 是否为原子操作？应该如何保证它的原子性？</h2><h3 id="i-的实现原理"><a href="#i-的实现原理" class="headerlink" title="i++的实现原理"></a>i++的实现原理</h3><p>对于i++这样的操作，其实是分3步执行的，读取i的值，增加i的值，回写i的新值。这3步每一步都是原子操作，但是组合在一起就不一定是原子操作了。可以参看下图中两个线程对i的争抢示例。我们期待线程A与B中的i++可以顺序执行，最终存储器中的结果是2；但是实际上由于两个线程并行执行，结果可能得到1（当然也有可能得到2，运气好的话）。通常i++这样的操作我们称为“读-改-写”操作。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137528.png" alt="i++并发操作"></p><h3 id="如何保证其原子性？"><a href="#如何保证其原子性？" class="headerlink" title="如何保证其原子性？"></a>如何保证其原子性？</h3><ol><li>可以在临界区加锁实现原子性</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>std::mutex mt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">std::lock_gaurd&lt;std::mutex&gt; <span class="hljs-title">l</span><span class="hljs-params">(mt)</span></span>;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>C++11后有std::atomic来保证原子性</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::atomic&lt;<span class="hljs-type">int</span>&gt; i = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="锁有哪些种类，有什么异同"><a href="#锁有哪些种类，有什么异同" class="headerlink" title="锁有哪些种类，有什么异同"></a>锁有哪些种类，有什么异同</h2><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072140875.png" alt="锁提纲"></p><h2 id="自旋锁，读写锁和互斥锁有什么区别"><a href="#自旋锁，读写锁和互斥锁有什么区别" class="headerlink" title="自旋锁，读写锁和互斥锁有什么区别"></a>自旋锁，读写锁和互斥锁有什么区别</h2><ol><li>自旋锁：自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码的执行时间很短，那这个忙等待的时间相应也很短。</li><li>读写锁：读写锁更适用于能区分读操作和写操作的场景，它允许多个读线程可以同时拥有读锁，提高了锁的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它用队列把请求锁的线程排队，并保证先进先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也好一些。</li><li>互斥锁：在开发过程中，用的最多的是互斥锁，互斥锁加锁失败时，会使用 [线程切换] 来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</li></ol><h2 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h2><ol><li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</li><li>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</li></ol><h3 id="带实例的解释"><a href="#带实例的解释" class="headerlink" title="带实例的解释"></a>带实例的解释</h3><p>C++默认的拷贝构造函数是浅拷贝<br>浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个没有类而没有提供它的复制构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> _data) : <span class="hljs-built_in">data</span>(_data) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; data &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, b </span>= a; <span class="hljs-comment">// 仅仅是数据成员之间的赋值</span><br>    a.<span class="hljs-built_in">getData</span>();<br>    b.<span class="hljs-built_in">getData</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137587.png" alt="image.png"><br>第18行的<code>b = a;</code>就是浅拷贝，执行完这句后<code>b.data = 5;</code><br>如果对象没有其他的资源（如：堆，文件，系统资源等），深拷贝和浅拷贝没有什么区别，但是当对象中有这些资源时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> _size) : <span class="hljs-built_in">size</span>(_size)<br>    &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[_size]; <span class="hljs-comment">// 假如其中有一段动态分配资源的内存</span><br>    &#125;<br>    <span class="hljs-built_in">A</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> []data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-type">int</span> size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, b </span>= a; <span class="hljs-comment">// 注意这一句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第23行的<code>b = a</code>会造成未定义行为，因为类A中的复制构造函数是编译器生成的，所以<code>b = a</code>执行的是一个浅拷贝过程。浅拷贝是对象数据之间的简单赋值，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">b.size = a.size;<br>b.data = a.data; <span class="hljs-comment">// oops!!!</span><br></code></pre></td></tr></table></figure><p><strong>这里b的指针data和a的指针data指向了堆上的同一块内存，a和b析构时，b先把其data指向的动态分配的内存释放了一次，而后a析构时又将这块已经被释放的内存再释放一次。对同一块动态内存执行2次以上的释放的结果时未定义的。所以这将导致内存泄漏或程序崩溃。</strong></p><p><strong>所以这里就需要深拷贝来解决这个问题，深拷贝指的就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> _size) : <span class="hljs-built_in">size</span>(_size)<br>    &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[_size]; <span class="hljs-comment">// 假如其中有一段动态分配资源的内存</span><br>    &#125;<br>    <span class="hljs-built_in">A</span>() &#123;&#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; _A) : <span class="hljs-built_in">size</span>(_A.size)<br>    &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 深拷贝</span><br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> []data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br>    <span class="hljs-type">int</span> size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, b </span>= a; <span class="hljs-comment">// 这次就没问题了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。</strong></p><h2 id="python中-操作是深拷贝还是浅拷贝"><a href="#python中-操作是深拷贝还是浅拷贝" class="headerlink" title="python中&#x3D;操作是深拷贝还是浅拷贝"></a>python中&#x3D;操作是深拷贝还是浅拷贝</h2><p>python的所有变量其实都时指向内存中的对象的一个指针。<br>当写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;Python&#x27;</span><br></code></pre></td></tr></table></figure><p>Python解释器干的事情：</p><ol><li>创建变量a</li><li>创建一个对象(分配一块内存)，来存储值’python’</li><li>将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072140780.png" alt="image.png"></p><p>平常使用的变量赋值是浅拷贝，即两个变量共享同一个内存块，相同的内存地址，一旦值发生改变，另外一个变量的值也会随着一起改变：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311072137982.png" alt="image.png"></p><p><strong>注意：常规的变量赋值共享一个内存块，内存地址相同，一旦值发生改变，共享同一个内存地址的所有变量值都会发生改变，可以直接通过内置函数id()对比下内存地址即可</strong>！</p><h2 id="常见的STL容器"><a href="#常见的STL容器" class="headerlink" title="常见的STL容器"></a>常见的STL容器</h2><p>各种数据结构，如vector、list、deque、set、map等，用来存放数据，从实现角度看，STL容器是一种class template。</p><h2 id="vector的特性"><a href="#vector的特性" class="headerlink" title="vector的特性"></a>vector的特性</h2><ol><li>空间可以动态扩展。即它可以像数组一样操作，并且可以进行动态操作。通常体现在<code>push_back()</code> <code>pop_back()</code></li><li>随机访问方便，它像数组一样被访问，即支持 [] 操作符和 vector.at()  （假设v是一个vector对象，则v.at(n)和v[n]是一样的，只不过前者会检查是否越界（因此花费的时间稍多），而后者不会（后者越界会导致未定义行为）。）</li><li>节省空间，因为它是连续存储，在存储数据的区域都是没有被浪费的，但是要明确一点 vector 大多情况下并不是满存的，在未存储的区域实际是浪费的。</li><li>在内部进行插入、删除操作效率非常低，这样的操作基本上是被禁止的。vector 被设计成只能在后端进行追加和删除操作，其原因是 vector 内部的实现是按照顺序表的原理，使得在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中</li><li>只能在 vector 的最后进行 push 和 pop，不能在 vector 的头进行 push 和 pop</li><li>当动态添加的数据超过 vector 默认分配的大小时要进行内存的重新分配、拷贝与释放，这个操作非常消耗性能。 所以要vector达到最优的性能，最好在创建vector时就指定其空间大小</li></ol><h2 id="map-和-unordered-map-的区别"><a href="#map-和-unordered-map-的区别" class="headerlink" title="map 和 unordered_map 的区别"></a>map 和 unordered_map 的区别</h2><h3 id="需要引入的头文件不同"><a href="#需要引入的头文件不同" class="headerlink" title="需要引入的头文件不同"></a>需要引入的头文件不同</h3><p>map需要引用的头文件是<code>#include &lt;map&gt;</code><br>unordered_map需要引用的头文件是<code>#include &lt;unordered_map&gt;</code></p><h3 id="内部实现机理不同"><a href="#内部实现机理不同" class="headerlink" title="内部实现机理不同"></a>内部实现机理不同</h3><p><strong>map: <strong>map内部实现了一个</strong>红黑树</strong>（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树存储的，使用中序遍历可将键值按照从小到大遍历出来。<br><strong>unordered_map:</strong> unordered_map内部实现了一个<strong>哈希表</strong>（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无需的。</p><h3 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h3><p><strong>map:</strong></p><ol><li>优点：<ol><li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li><li>红黑树，内部实现一个红黑树使得map的很多操作在logn的时间复杂度下就可以实现，因此效率非常的高</li></ol></li><li>缺点：</li></ol><p>空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红&#x2F;黑性质，使得每一个节点都占用大量的空间</p><ol start="3"><li>适用处：</li></ol><p>对于那些有顺序要求的问题，用map会更高效一些<br><strong>unordered_map:</strong></p><ol><li>优点：</li></ol><p>因为内部实现了哈希表，因此其查找速度非常的快</p><ol start="2"><li>缺点：</li></ol><p>哈希表的建立比较耗费时间</p><ol start="3"><li>适用处：</li></ol><p>对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li><li>但是unordered_map执行效率要比map高很多</li><li>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li></ol><h3 id="map和unordered-map的使用"><a href="#map和unordered-map的使用" class="headerlink" title="map和unordered_map的使用"></a>map和unordered_map的使用</h3><p>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p><h2 id="C-类中可以定义引用数据成员吗？"><a href="#C-类中可以定义引用数据成员吗？" class="headerlink" title="C++ 类中可以定义引用数据成员吗？"></a>C++ 类中可以定义引用数据成员吗？</h2><p>可以，C++ 类中可以定义引用数据成员。引用数据成员是指在类中定义的一一个变量，它的类型为其他变量或对象的引用。引用数据成员必须在类的构造函数中进行初始化，并且一旦初始化后，它将一直引用同一个对象。</p><h2 id="C-中拷贝构造函数可不可以进行值传递"><a href="#C-中拷贝构造函数可不可以进行值传递" class="headerlink" title="C++ 中拷贝构造函数可不可以进行值传递"></a>C++ 中拷贝构造函数可不可以进行值传递</h2><p>不能。</p><p>如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数，如此循环，无法完成拷贝，栈也会满。</p><h2 id="一个-cpp-文件如何变成一个可执行文件？它的过程是什么？"><a href="#一个-cpp-文件如何变成一个可执行文件？它的过程是什么？" class="headerlink" title="一个 .cpp 文件如何变成一个可执行文件？它的过程是什么？"></a>一个 .cpp 文件如何变成一个可执行文件？它的过程是什么？</h2><p>C++ 程序从源码到可执行程序是一个复杂的过程，其流程为：<code>源代码-&gt;预处理-&gt;编译-&gt;优化-&gt;汇编-&gt;链接-&gt;可执行文件</code>。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>源码文件分为3个，<code>hello.h</code>、<code>hello.cpp</code>、<code>main.cpp</code>，代码如下：</p><p><strong>hello.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HELLO_HPP_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO_HPP_</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>hello.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">hello</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>预处理是指 C++ 程序在源代码编译之前，由预处理器 (Preprocessor) 对 C++ 程序源代码进行的处理。在这个阶段，预处理器会处理以 <code>#</code> 开头的命令，处理完成之后会生成一个不包含预处理命令的纯 C++ 文件，常见的预处理有: 文件包含 (<code>#include</code>)、条件编译(<code>#ifndef #ifdef #endif</code>)、提供编译信息(<code>#pragma</code>)、宏替换(<code>#define</code>)等。</p><p>使用 g++ 预处理 <code>main.cpp</code> 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -E main.cpp -o main.ii<br></code></pre></td></tr></table></figure><p><code>-E</code> 参数表示预处理后即停止，不进行编译，预处理后的代码送往标准输出，<code>-o</code> 指定输出文件。输出文件 <code>main.ii</code> 的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># <span class="hljs-number">1</span> <span class="hljs-string">&quot;main.cpp&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> <span class="hljs-number">2</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;main.cpp&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;hello.hpp&quot;</span> <span class="hljs-number">1</span><br><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br># <span class="hljs-number">2</span> <span class="hljs-string">&quot;main.cpp&quot;</span> <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">hello</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译过程中，编译器主要作语法检查和词法分析。通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。</p><p>编译 <code>main.ii</code> 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -S main.ii<br></code></pre></td></tr></table></figure><p><code>-S</code> 参数表示编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出文件是汇编语言文件。输出文件 <code>main.s</code> 的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">        .file   &quot;main.cpp&quot;<br>        .text<br>        .globl  main<br>        .type   main, @function<br>main:<br>.LFB0:<br>        .cfi_startproc<br>        pushq   %rbp<br>        .cfi_def_cfa_offset 16<br>        .cfi_offset 6, -16<br>        movq    %rsp, %rbp<br>        .cfi_def_cfa_register 6<br>        subq    $16, %rsp<br>        movl    %edi, -4(%rbp)<br>        movq    %rsi, -16(%rbp)<br>        call    _Z5hellov<br>        movl    $0, %eax<br>        leave<br>        .cfi_def_cfa 7, 8<br>        ret<br>        .cfi_endproc<br>.LFE0:<br>        .size   main, .-main<br>        .ident  &quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-16)&quot;<br>        .section        .note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化是在编译过程中最重要的，也是最难的。它不仅与编译技术本身有关，而且跟机器的硬件环境也有很大的关系。优化可在编译的不同阶段进行，一类优化是对中间代码的优化，这类优化不依赖于具体的计算机，另一类优化是对目标代码的优化，这类优化与机器的硬件环境有关。</p><p><code>g++</code> 编译器的编译优化参数为 <code>-O</code>，分为四级，分别为 <code>-O0</code>、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>，默认为 <code>-O0</code>。各级优化后的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs asm"># 默认优化，-O0<br>[root@localhost:/workspace] $: g++ -c main.cpp hello.cpp<br>[root@localhost:/workspace] $: nm -C main.o<br>                 U __cxa_atexit<br>                 U __dso_handle<br>000000000000007a t _GLOBAL__sub_I__Z5hellov<br>0000000000000022 T main<br>000000000000003d t __static_initialization_and_destruction_0(int, int)<br>0000000000000000 T hello()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::cout<br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)<br>0000000000000000 b std::__ioinit<br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)<br><br><br># 优化级别-O1<br>[root@localhost:/workspace] $: g++ -c -O1 main.cpp hello.cpp<br>[root@localhost:/workspace] $: nm -C main.o<br>                 U __cxa_atexit<br>                 U __dso_handle<br>000000000000007d t _GLOBAL__sub_I__Z5hellov<br>000000000000006a T main<br>0000000000000000 T hello()<br>                 U std::ctype&lt;char&gt;::_M_widen_init() const<br>                 U std::ostream::put(char)<br>                 U std::ostream::flush()<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)<br>                 U std::__throw_bad_cast()<br>                 U std::cout<br>0000000000000000 b std::__ioinit<br><br># 优化级别-O2<br>[root@localhost:/workspace] $: g++ -c -O2 main.cpp hello.cpp<br>[root@localhost:/workspace] $: nm -C main.o<br>                 U __cxa_atexit<br>                 U __dso_handle<br>0000000000000010 t _GLOBAL__sub_I__Z5hellov<br>0000000000000000 T main<br>0000000000000000 T hello()<br>                 U std::ctype&lt;char&gt;::_M_widen_init() const<br>                 U std::ostream::put(char)<br>                 U std::ostream::flush()<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)<br>                 U std::__throw_bad_cast()<br>                 U std::cout<br>0000000000000000 b std::__ioinit<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编是把汇编语言代码翻译成目标机器指令的过程。</p><p>编译 <code>main.s</code> 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -c main.s<br></code></pre></td></tr></table></figure><p><code>-c</code> 参数表示编译或汇编源文件，但是不作连接，编译器输出对应于源文件的目标文件。输出文件为 <code>main.o</code>，使用 <code>nm -C main.o</code> 来查看文件内容，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">0000000000000000 T main<br>                 U hello()<br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接是将目标文件、启动代码、库文件链接成可执行文件的过程，得到的文件可以直接执行。经过汇编之后生成的目标文件 <code>main.o</code> 是不可以直接执行的。链接命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ main.o -o main<br>main.o: In <span class="hljs-keyword">function</span> `main<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">main.cpp:(.text+0x10): undefined reference to `hello()&#x27;</span><br>collect2: error: ld returned 1 <span class="hljs-built_in">exit</span> status<br></code></pre></td></tr></table></figure><p>从上面可以看出，只链接 <code>main.o</code> 文件会报错，这是因为 <code>main.cpp</code> 引用了 <code>hello.cpp</code> 中定义的函数 <code>hello</code>，因此需要链接文件 <code>hello.cpp</code> 才能生成可执行程序。重复上述过程，生成 <code>hello.o</code>，链接两个文件的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ main.o hello.o -o main<br></code></pre></td></tr></table></figure><p>经过链接，多个文件被链接成了单一的可执行文件 <code>main</code>，执行 <code>main</code> 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: ./main<br>Hello, world!<br></code></pre></td></tr></table></figure><h4 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h4><p>除了直接链接多个目标文件之外，还可以通过链接静态库生成可执行文件。静态链接库是编译器生成的一系列对象文件的集合，库中的成员包括普通函数，类定义，类的对象实例等。静态链接是指把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。可执行文件生成之后，就不再需要静态链接库，即编译后的可执行程序不需要外部函数库的支持。但如果静态链接库发生改变，则可执行程序需要重新编译。静态链接库属于编译时链接。</p><p>再添加两个 <code>static.hpp</code>、<code>static.cpp</code>，并修改 <code>main.cpp</code>，内容如下：</p><p><strong>static.hpp 文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STATIC_HPP_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STATIC_HPP_</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><strong>static.cpp 文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;static.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;static lib&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.cpp 文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123; <br>    <span class="hljs-built_in">hello</span>();<br>    <span class="hljs-built_in">test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译汇编 <code>hello.cpp</code>、<code>static.cpp</code> 之后可以得到两个文件 <code>hello.o</code> 和 <code>static.o</code>，linux 系统中的命令 <code>ar</code>，可以将多个目标文件打包成为一个单独的文件，这个文件被称为静态库。生成静态库的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: ar -r libstatic.a hello.o static.o<br>ar: creating libstatic.a<br></code></pre></td></tr></table></figure><p>查看 <code>liastatic.a</code> 的内容：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs zephir">[root@localhost:/workspace] $: nm -C libstatic.a<br><br>hello.o:<br>                 U __cxa_atexit<br>                 U __dso_handle<br><span class="hljs-number">000000000000005</span>f t _GLOBAL__sub_I__Z5hellov<br><span class="hljs-number">0000000000000022</span> t __static_initialization_and_destruction_0(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)<br><span class="hljs-number">0000000000000000</span> T hello()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::cout<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::endl&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;)<br><span class="hljs-number">0000000000000000</span> b std::__ioinit<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*)<br><br><span class="hljs-keyword">static</span>.o:<br>                 U __cxa_atexit<br>                 U __dso_handle<br><span class="hljs-number">000000000000005</span>f t _GLOBAL__sub_I__Z4testv<br><span class="hljs-number">0000000000000022</span> t __static_initialization_and_destruction_0(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)<br><span class="hljs-number">0000000000000000</span> T test()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::cout<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::endl&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;)<br><span class="hljs-number">0000000000000000</span> b std::__ioinit<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*)<br></code></pre></td></tr></table></figure><p>通过静态链接库生成可执行程序 <code>main</code> 并执行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> g++ main.o libstatic.a -o main<br>[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> ./main<br><span class="hljs-title class_">Hello</span>, world!<br>static lib<br></code></pre></td></tr></table></figure><p>另一种命令方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -L ./ main.cpp -lstatic -o main<br></code></pre></td></tr></table></figure><p>Linux 静态库的命名惯例是名字以三个字母 <code>lib</code> 开头并以后缀 <code>.a</code> 结束。所有的系统库都采用这种命名惯例，并且它允许通过 <code>-l(ell)</code> 选项来简写命令行中的库名。<code>-lstatic</code> 中的 <code>-l</code> 是要求编译器在系统库目录下查找 <code>static</code> 库，<code>static</code> 是 <code>libstatic.a</code> 的简写。<code>-L</code> 参数用来指定要具体的查找目录，如果缺少这个参数，则只会在系统库目录下查找 <code>static</code>，会报错。错误如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> g++ main.cpp -lstatic -o ltest<br>/usr/bin/<span class="hljs-symbol">ld:</span> cannot find -lstatic<br></code></pre></td></tr></table></figure><h4 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h4><p>共享库（Windows 叫动态链接库）是编译器以一种特殊的方式生成的对象文件的集合。对象文件模块中所有地址（变量引用或函数调用）都是相对而不是绝对的，这使得共享模块可以在程序的运行过程中被动态地调用和执行。共享库属于运行时链接。当使用共享库时，只要共享库的接口不变，共享库修改之后，不需要重新编译可执行程序。</p><p>创建 <code>dynamic.cpp</code>，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;dynamic lib&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译 <code>hello.cpp</code> 和 <code>dynamic.cpp</code> ，<code>-fpic</code> 表示生成的对象模块采用浮动（可重定位）地址，<code>pic</code> 是位置无关代码（position independent code）的缩写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -c -fpic hello.cpp static.cpp<br></code></pre></td></tr></table></figure><p>使用 <code>-fpic</code> 与不使用 <code>-fpic</code> 生成的目标文件 <code>hello.o</code> ：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs zephir"># 使用-fpic<br>                 U __cxa_atexit<br>                 U __dso_handle<br>                 U _GLOBAL_OFFSET_TABLE_<br><span class="hljs-number">0000000000000076</span> t _GLOBAL__sub_I_hello.cpp<br><span class="hljs-number">000000000000002</span>e t __static_initialization_and_destruction_0(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)<br><span class="hljs-number">0000000000000000</span> T hello()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::cout<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::endl&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;)<br><span class="hljs-number">0000000000000000</span> b std::__ioinit<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*)<br><br># 不使用-fpic<br>                 U __cxa_atexit<br>                 U __dso_handle<br><span class="hljs-number">000000000000005</span>f t _GLOBAL__sub_I__Z5hellov<br><span class="hljs-number">0000000000000022</span> t __static_initialization_and_destruction_0(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)<br><span class="hljs-number">0000000000000000</span> T hello()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<br>                 U std::ios_base::Init::Init()<br>                 U std::ios_base::Init::~Init()<br>                 U std::cout<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::endl&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;)<br><span class="hljs-number">0000000000000000</span> b std::__ioinit<br>                 U std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="hljs-keyword">char</span>, std::char_traits&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp;, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*)<br><br></code></pre></td></tr></table></figure><p>创建共享库 <code>dynamic.so</code> ， <code>-shared</code> 表示生成共享目标文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ -shared hello.o dynamic.o -o libdynamic.so<br></code></pre></td></tr></table></figure><p>编译 <code>main.cpp</code> 并链接共享库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost:/workspace] $: g++ main.cpp libdynamic.so -o main<br></code></pre></td></tr></table></figure><p>执行 <code>main</code>：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">[root@localhost:/<span class="hljs-keyword">workspace</span>] $: ./main<br>./main: <span class="hljs-keyword">error</span> <span class="hljs-keyword">while</span> loading shared libraries: dynamic.so: cannot open shared object <span class="hljs-keyword">file</span>: No such <span class="hljs-keyword">file</span> or directory<br></code></pre></td></tr></table></figure><p>报错是因为当前工作目录可能不在共享库的查找路径中，因此需要将当前目录添加到环境变量<code>LD_LIBRARY_PATH</code>中：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:</span>./<br>[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> ./main<br><span class="hljs-title class_">Hello</span>, world!<br>dynamic lib<br></code></pre></td></tr></table></figure><p>查看链接静态库和共享库生成的两个可执行 <code>main</code> 文件：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 共享库</span><br>[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> nm -C main<br>000000000060103c B __bss_start<br>000000000060103c b completed.<span class="hljs-number">6354</span><br>0000000000601038 D __data_start<br>0000000000601038 W data_start<br><span class="hljs-number">0000000000400650</span> t deregister_tm_clones<br>00000000004006c0 t __do_global_dtors_aux<br>0000000000600dd8 t __do_global_dtors_aux_fini_array_entry<br>00000000004007b8 R __dso_handle<br>0000000000600de8 d _DYNAMIC<br>000000000060103c D _edata<br><span class="hljs-number">0000000000601040</span> B _end<br>00000000004007a4 T _fini<br>00000000004006e0 t frame_dummy<br>0000000000600dd0 t __frame_dummy_init_array_entry<br>00000000004008e8 r __FRAME_END__<br><span class="hljs-number">0000000000601000</span> d _GLOBAL_OFFSET_TABLE_<br>                 w __gmon_start__<br>00000000004005a8 T _init<br>0000000000600dd8 t __init_array_end<br>0000000000600dd0 t __init_array_start<br>00000000004007b0 R _IO_stdin_used<br>                 w _ITM_deregisterTMCloneTable<br>                 w _ITM_registerTMCloneTable<br>0000000000600de0 d __JCR_END__<br>0000000000600de0 d __JCR_LIST__<br>                 w _Jv_RegisterClasses<br>00000000004007a0 T __libc_csu_fini<br><span class="hljs-number">0000000000400730</span> T __libc_csu_init<br>                 U __libc_start_main<span class="hljs-variable">@@GLIBC_2</span>.<span class="hljs-number">2.5</span><br>000000000040070d T main<br>0000000000400680 t register_tm_clones<br><span class="hljs-number">0000000000400620</span> T _start<br><span class="hljs-number">0000000000601040</span> D __TMC_END__<br>                 U test()<br>                 U hello()<br><br><br><span class="hljs-comment"># 静态库</span><br>[root<span class="hljs-variable">@localhost</span><span class="hljs-symbol">:/workspace</span>] <span class="hljs-variable">$:</span> nm -C main<br>000000000060105c B __bss_start<br><span class="hljs-number">0000000000601170</span> b completed.<span class="hljs-number">6354</span><br>                 U __cxa_atexit<span class="hljs-variable">@@GLIBC_2</span>.<span class="hljs-number">2.5</span><br>0000000000601058 D __data_start<br>0000000000601058 W data_start<br>00000000004007b0 t deregister_tm_clones<br>0000000000400820 t __do_global_dtors_aux<br>0000000000600de8 t __do_global_dtors_aux_fini_array_entry<br>0000000000400a08 R __dso_handle<br>0000000000600df8 d _DYNAMIC<br>000000000060105c D _edata<br>0000000000601178 B _end<br>00000000004009f4 T _fini<br>0000000000400840 t frame_dummy<br>0000000000600dd0 t __frame_dummy_init_array_entry<br>0000000000400c40 r __FRAME_END__<br><span class="hljs-number">0000000000601000</span> d _GLOBAL_OFFSET_TABLE_<br>0000000000400960 t _GLOBAL__sub_I__Z4testv<br>00000000004008ec t _GLOBAL__sub_I__Z5hellov<br>                 w __gmon_start__<br>00000000004006d0 T _init<br>0000000000600de8 t __init_array_end<br>0000000000600dd0 t __init_array_start<br>0000000000400a00 R _IO_stdin_used<br>                 w _ITM_deregisterTMCloneTable<br>                 w _ITM_registerTMCloneTable<br>0000000000600df0 d __JCR_END__<br>0000000000600df0 d __JCR_LIST__<br>                 w _Jv_RegisterClasses<br>00000000004009f0 T __libc_csu_fini<br>0000000000400980 T __libc_csu_init<br>                 U __libc_start_main<span class="hljs-variable">@@GLIBC_2</span>.<span class="hljs-number">2.5</span><br>000000000040086d T main<br>00000000004007e0 t register_tm_clones<br>0000000000400780 T _start<br><span class="hljs-number">0000000000601060</span> D __TMC_END__<br>00000000004008af t __static_initialization_and_destruction_0(int, int)<br>0000000000400923 t __static_initialization_and_destruction_0(int, int)<br>0000000000400901 T test()<br>000000000040088d T hello()<br>                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br>                 U std::ios_base::<span class="hljs-title class_">Init</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Init</span>()<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br>                 U std::ios_base::<span class="hljs-title class_">Init</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:~Init</span>()<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br><span class="hljs-number">0000000000601060</span> B std::cout<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br><span class="hljs-number">0000000000601171</span> b std::__ioinit<br><span class="hljs-number">0000000000601172</span> b std::__ioinit<br>                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*)<span class="hljs-variable">@@GLIBCXX_3</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>可执行文件指的是可以由操作系统进行加载执行的文件。在不同的操作系统环境下，可执行程序的呈现方式不一样。例如上面生成的 <code>main</code> 就是Linux系统下的可执行文件，windows系统下的可执行文件一般为 <code>*.exe</code>。</p><h2 id="静态链接和动态链接的区别"><a href="#静态链接和动态链接的区别" class="headerlink" title="静态链接和动态链接的区别"></a>静态链接和动态链接的区别</h2><p>静态链接就是把 (lib) 文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其他的库文件；动态链接就是把调用的函数所在模块 (DLL) 和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从 DLL 中寻找相应函数代码，因此需要 DLL 文件的支持。</p><p>静态链接库与动态链接库都是共享代码的方式，如果采用了静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。</p><p>静态链接库和动态链接库的另外一个区别在于静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p><p>动态库就是再需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果再当前工程中有多处对 DLL 文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但如果有多处对 lib 文件中同一个函数的调用，那么执行时该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</p><h2 id="C-中如何防止一个类被其他类继承？"><a href="#C-中如何防止一个类被其他类继承？" class="headerlink" title="C++ 中如何防止一个类被其他类继承？"></a>C++ 中如何防止一个类被其他类继承？</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>让子类无法调用父类的构造函数，从而让父类无法被子类继承，实现“终结类”。</p><h3 id="方法1：将构造函数与析构函数设置为私有"><a href="#方法1：将构造函数与析构函数设置为私有" class="headerlink" title="方法1：将构造函数与析构函数设置为私有"></a>方法1：将构造函数与析构函数设置为私有</h3><p>如果将一个类的构造函数声明为“私有”(private)，可以阻止该类进一步派生，但是该类也无法直接实例化了（但是可以被间接实例化，间接实例化的方法是：类中定义一个公有的静态成员函数，由这个函数来完成对象的初始化工作。）C++单例模式 singleton就是用到了这个方法。C++的单例模式的实现如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSingleton</span>  <br>&#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-built_in">CSingleton</span>()&#123;&#125;;   <span class="hljs-comment">//构造函数是私有的  </span><br>    <span class="hljs-type">static</span> CSingleton *m_pInstance;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">static</span> CSingleton * <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        <span class="hljs-keyword">if</span>(m_pInstance == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//判断是否第一次调用  </span><br>            m_pInstance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CSingleton</span>();  <br>        <span class="hljs-keyword">return</span> m_pInstance;  <br>    &#125;  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>所以，虽然将构造函数声明为私有会导致该类无法被实例化，但是我们可以通过在public中实现一个静态成员函数，通过这个成员函数来返回一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Myclass* <span class="hljs-title">NewNode</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Myclass</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DeleteNode</span><span class="hljs-params">(Myclass* _Myclass)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">delete</span>  _Myclass;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Myclass</span>()<br>    &#123;&#125;<br>    ~<span class="hljs-built_in">Myclass</span>()<br>    &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> :<span class="hljs-keyword">public</span> Myclass<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>()<br>    &#123;&#125;<br>    ~<span class="hljs-built_in">Child</span>()<br>    &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码会报错，因为实现了无法被继承的类，Child 类不能再继承Myclass了，Myclass 类的构造函数会无法访问。</p><h3 id="方法2：虚拟继承"><a href="#方法2：虚拟继承" class="headerlink" title="方法2：虚拟继承"></a>方法2：虚拟继承</h3><p>C++ 中实现不能被继承的类的最为安全有效的方法是使用“虚拟继承”。一个基类如果被虚拟继承，那么在创建它的子类的对象时，该基类的构造函数需要单独被调用。此时，如果该基类的构造函数在子类的构造函数中无法被访问，那么就实现了基类的子类不能被继承。</p><p>利用虚拟继承的这种特性，我们可以设计出这样一个基类 FinalParent，它不定义任何数据成员，这样任何类从它派生并不会增加任何空间上的开销。将它的默认构造函数的访问权限设定为 protected，这样它自身不能产生任何实例，只能用作基类。一个使用基类 FinalParent 的实现终结类的例子如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalParent</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-built_in">FinalParent</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalClass</span>:<span class="hljs-keyword">private</span> <span class="hljs-keyword">virtual</span> FinalParent<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">FinalClass</span>():<span class="hljs-built_in">num</span>(<span class="hljs-number">1</span>)&#123;&#125;;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;num:&quot;</span>&lt;&lt;num&lt;&lt;endl;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalClassChild</span>:<span class="hljs-keyword">public</span> FinalClass<br>&#123;<br>  <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">FinalClassChild</span>():<span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>)&#123;&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  FinalClassChild f;<span class="hljs-comment">//报错，无法访问FinalParent：：FinalParent()</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从程序中可以看出，当 FinalClassChild 试图继承 FinalClass 的时候，FinalClassChild 的构造函数中需要调用 FinalParent 的构造函数，而 FinalParent 的构造函数在 FinalClass 中已经变成了私有 private ，不能被 FinalClassChild 的任何成员函数所访问，导致编译错误。所以，任何一个类，只要虚拟继承类 FinalParent，就不能被继续继承，从而简单、高效安全的实现了“终结类”。</p><h2 id="C-拷贝构造函数详解"><a href="#C-拷贝构造函数详解" class="headerlink" title="C++ 拷贝构造函数详解"></a>C++ 拷贝构造函数详解</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>拷贝构造函数只有一个参数，参数类型是本类的引用。</p><p>拷贝构造函数的参数可以是 const 引用，也可以是非 const 引用。一般使用前者，这样既能以常量对象（初始化值后不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个拷贝构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。</p><p>如果类的设计者不实现拷贝构造函数，编译器就会自动生成拷贝构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制。即，使得目标对象的每个成员变量都与源对象相等。编译器自动生成的拷贝构造函数称为“默认拷贝构造函数”。</p><p>注意，<strong>默认构造函数（即无参构造函数）不一定存在</strong>，但是<strong>默认拷贝构造函数总是会存在</strong>。</p><p>下面是一个拷贝构造函数的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">double</span> real, img;<br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123;<br>real = r;<br>img = i;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(c1)</span></span>; <span class="hljs-comment">// 用默认拷贝构造函数初始化c2</span><br>cout &lt;&lt; c2.real &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; c2.img &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 输出 1,2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第16行给出了初始化 c2 的参数，即 c1。只有编译器自动生成的那个默认拷贝构造函数的参数才能和 c1匹配，因此，c2 就是以 c1 为参数，调用默认拷贝构造函数进行初始化的。初始化的结果是 c2 成为 c1 的复制品，即 c2 和 c1 每个成员变量的值都相等。</p><p>如果编写了拷贝构造函数，则默认拷贝构造函数就不存在了。下面是一个非默认拷贝构造函数的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">double</span> real, img;<br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123;<br>real = r;<br>img = i;<br>&#125;<br><span class="hljs-built_in">Complex</span>(Complex&amp; c) &#123;<br>real = c.real;<br>img = c.img;<br>cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor called&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(c1)</span></span>; <span class="hljs-comment">// 用拷贝构造函数初始化c2</span><br>cout &lt;&lt; c2.real &lt;&lt; <span class="hljs-string">&#x27;,&#x27;</span> &lt;&lt; c2.img &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 输出 1,2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">Constructor</span> <span class="hljs-title function_">called</span><br>1,2<br></code></pre></td></tr></table></figure><p>第11行，拷贝构造函数加不加 const 对本程序来说都一样，但是加上 const 是更好的做法，这样拷贝构造函数才能接受常量对象作为参数，即才能以常量对象作为参数去初始化别的对象。</p><p>第21行，即以 c1 为参数调用第11行的那个拷贝构造函数去初始化 c2。该拷贝构造函数执行的结果是使 c2 和 c1 相等，此外还输出 <code>Copy Constructor called</code>。</p><p>可以想象，如果第 12、13 行删去或改为 <code>real = 2 * c.real; img = c.img + 1;</code> 那么 c2 的值就不会等于 c1 了。也就是说，自己编写的拷贝构造函数并不一定要做复制的工作（如果只做复制的工作，那么使用编译器自动生成的默认拷贝构造函数即可）。但从习惯上来说，拷贝构造函数还是应该完成类似于复制的工作为好，在此基础上还可以根据需要做些别的操作。</p><p>构造函数不能以本类的对象作为唯一参数，以免和拷贝构造函数相混淆。例如，不能写如下构造函数：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">Complex</span>(<span class="hljs-type">Complex</span> c) <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数被调用的三种情况"><a href="#拷贝构造函数被调用的三种情况" class="headerlink" title="拷贝构造函数被调用的三种情况"></a>拷贝构造函数被调用的三种情况</h3><ul><li><p>当用一个对象去初始化同类的另一个对象时，会引发拷贝构造函数被调用。例如，下面这两条语句都会引发拷贝构造函数的调用，用以初始化 c2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(c1)</span></span>;<br>Complex c2 = c1;<br></code></pre></td></tr></table></figure><p>这两条语句是等价的。</p><p>注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发拷贝构造函数的调用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Complex c1, c2;<br>c1 = c2;<br></code></pre></td></tr></table></figure><p>这条语句不会引发拷贝构造函数的调用，因为 c1 早已生成，以及初始化过了。</p></li><li><p>如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的拷贝构造函数将会被调用。换句话说，作为形参的对象，是用拷贝构造函数初始化的，而且调用拷贝构造函数时的参数，就是调用函数时所给的实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;&#125;;<br>    <span class="hljs-built_in">A</span>(A&amp; a) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(A a)</span> </span>&#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-built_in">Func</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出的结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">constructor</span> <span class="hljs-title function_">called</span><br></code></pre></td></tr></table></figure><p>这是因为 Func 函数的形参 a 在初始化时调用了拷贝构造函数。</p><p>函数的形参的值等于函数在调用时对应的实参，现在可以知道这不一定是正确的。如果形参是一个对象，那么形参的值是否一定等于实参，这取决于该对象所属类的拷贝构造函数是如何实现的。例如上面的例子， Func 函数的形参 a 的值在进入函数时是随机的，未必等于实参，因为拷贝构造函数做的不一定是复制的操作。</p><p>如果要确保实参的值不会改变，又希望避免拷贝构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">const</span> Complex&amp; c)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，Func 函数中出现任何可能导致 c 的值被修改的语句，都会引发编译错误。</p></li><li><p>如果函数的返回值是类 A 的对象，则函数返回时，类 A 的拷贝构造函数被调用。换言之，作为函数返回值的对象是用拷贝构造函数初始化的，而调用拷贝构造函数时的实参，就是 return 语句所返回的对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n) &#123; v = n; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        v = a.v;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">Func</span>().v &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出结果是：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Copy</span> <span class="hljs-keyword">constructor</span> <span class="hljs-title function_">called</span><br>4<br></code></pre></td></tr></table></figure><p>第19行调用了 Func 函数，其返回值是一个对象，该对象就是用拷贝构造函数初始化的， 而且调用拷贝构造函数时，实参就是第 16 行 return 语句所返回的 a。拷贝构造函数在第 9 行确实完成了复制的工作，所以第 19 行 Func 函数的返回值和第 14 行的 a 相等。</p><p>需要说明的是，有些编译器出于程序执行效率的考虑，编译的时候进行了优化，函数返回值对象就不用复制构造函数初始化了，这并不符合 C++ 的标准。上面的程序，用 Visual Studio 2010 编译后的输出结果如上所述，但是在 Dev C++ 4.9 中不会调用复制构造函数。把第 14 行的 a 变成全局变量，才会调用复制构造函数。</p></li></ul><h2 id="C-的四种强制类型转换"><a href="#C-的四种强制类型转换" class="headerlink" title="C++ 的四种强制类型转换"></a>C++ 的四种强制类型转换</h2><p>分别是 static_cast、dynamic_cast、const_cast、reinterpret_cast</p><ul><li>static_ cast：明确指出类 型转换，一般建议将隐 式转换都替换成显示转换，因为没有动态类型检查，上行转换 (派生类-&gt;基类)安全，下行转换 (基类&gt;派生类)不安全， 所以主要执行非多态的转换操作;</li><li>dynamic_ cast：专门用于派生类之间的转换，type id 必须是类指针，类引用或 void*, 对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而 static_ cast, 当类型不一致时， 转换过来的事错误意义的指针，可能造成非法访问等问题。</li><li>const cast：专门用于const属性的转换，去除const性质，或增加const性质，是四个转换符中唯一一个 可以操作常量的转换符。</li><li>reinterpret cast：不到万不得已，不要使用这个转换符，高危操作。使用特点:从底层对数据进行重新解释，依赖具体的平台，可移植性差；可以将整形转换为指针，也可以把指针转换为数组；可以在指针和引用之间进行肆无忌惮的转换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/2023/11/06/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/11/06/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为什么要使用智能指针？"><a href="#一、为什么要使用智能指针？" class="headerlink" title="一、为什么要使用智能指针？"></a>一、为什么要使用智能指针？</h2><p>智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而<strong>避免内存泄漏</strong>！<br>如下例子就是内存泄露的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// 动态分配内存，没有释放就return</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memoryLeak1</span><span class="hljs-params">()</span> </span>&#123;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;动态分配内存！&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">memoryLeak2</span><span class="hljs-params">()</span> </span>&#123;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;内存泄露！&quot;</span>);<br><br><span class="hljs-comment">// ...此处省略一万行代码</span><br><br><span class="hljs-comment">// 发生某些异常，需要结束函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>/<br><span class="hljs-comment">// 另外，使用try、catch结束函数，也会造成内存泄漏！</span><br>/<br><br><span class="hljs-keyword">delete</span> str;<span class="hljs-comment">// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br><span class="hljs-built_in">memoryLeak1</span>();<br><br><span class="hljs-built_in">memoryLeak2</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><p>memoryLeak1函数中，new了一个字符串指针，但是没有delete就已经return结束函数了，导致内存没有被释放，内存泄露！<br>memoryLeak2函数中，new了一个字符串指针，虽然在函数末尾有些释放内存的代码delete str，但是在delete之前就已经return了，所以内存也没有被释放，内存泄露！<br>使用指针，我们没有释放，就会造成内存泄露。但是我们使用普通对象却不会！<br><strong>思考</strong>：如果我们分配的动态内存都交由有生命周期的对象来处理，那么在对象过期时，让它的析构函数删除指向的内存，这看似是一个 very nice 的方案？<br>智能指针就是通过这个原理来解决指针自动释放的问题！</p><ol><li>C++98 提供了 auto_ptr 模板的解决方案</li><li>C++11 增加unique_ptr、shared_ptr 和weak_ptr</li></ol><h2 id="二、auto-ptr"><a href="#二、auto-ptr" class="headerlink" title="二、auto_ptr"></a>二、auto_ptr</h2><p>auto_ptr是C++98定义的智能指针模板，其定义了管理指针的对象，可以将new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存！<br>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;我要成为大牛~ 变得很牛逼！&quot;</span>))</span></span>;<br>auto_ptr&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">av</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p><strong>例:</strong><br>我们先定义一个类，类的构造函数和析构函数都输出一个字符串用作提示！<br>定义一个私有成员变量，赋值20.<br>再定义一个私有成员方法用于返回这个私有成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的构造函数...&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的析构函数...&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDebug</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;debug; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> debug = <span class="hljs-number">20</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们直接new这个类的对象，却没有释放时。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>Test *test = <span class="hljs-keyword">new</span> Test;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062213528.png" alt="image.png"><br>可以看到，只是打印了构造函数这个字符串，而析构函数的字符却没有被打印，说明并没有调用析构函数！这就导致了内存泄露！<br>解决内存泄露的办法，要么手动delete，要么使用智能指针！<br><strong>使用智能指针</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br></code></pre></td></tr></table></figure><p>智能指针可以像普通指针那样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这时再试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br><span class="hljs-comment">//Test *test = new Test;</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;test-&gt;debug：&quot;</span> &lt;&lt; test-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;(*test).debug：&quot;</span> &lt;&lt; (*test).<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062213708.png" alt="image.png">自动调用了析构函数。<br><strong>为什么智能指针可以像普通指针那样使用</strong>？？？<br>因为其里面重载了 * 和 -&gt; 运算符， * 返回普通对象，而 -&gt; 返回指针对象。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062213352.png" alt="image.png">具体原因不用深究，只需知道他为什么可以这样操作就行<br>函数中返回的是调用get()方法返回的值，那么这个get()是什么呢？<br>智能指针的三个常用函数：</p><ol><li>get()获取智能指针托管的指针地址</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>Test *tmp = test.<span class="hljs-built_in">get</span>();<span class="hljs-comment">// 获取指针返回</span><br>cout &lt;&lt; <span class="hljs-string">&quot;tmp-&gt;debug：&quot;</span> &lt;&lt; tmp-&gt;<span class="hljs-built_in">getDebug</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>但我们一般不会这样使用，因为都可以直接使用智能指针去操作，除非有一些特殊情况。<br><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_NODISCARD _Ty * <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return wrapped pointer</span><br><span class="hljs-keyword">return</span> (_Myptr);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>release</strong>() 取消智能指针对动态内存的托管</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>Test *tmp2 = test.<span class="hljs-built_in">release</span>();<span class="hljs-comment">// 取消智能指针对动态内存的托管</span><br><span class="hljs-keyword">delete</span> tmp2;<span class="hljs-comment">// 之前分配的内存需要自己手动释放</span><br></code></pre></td></tr></table></figure><p>也就是智能指针不再对该指针进行管理，改由管理员进行管理！<br><strong>函数原型</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_Ty * <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return wrapped pointer and give up ownership</span><br>_Ty * _Tmp = _Myptr;<br>_Myptr = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> (_Tmp);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>reset</strong>() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义智能指针</span><br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br>test.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// 释放掉智能指针托管的指针内存，并将其置NULL</span><br><br>test.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>());<span class="hljs-comment">// 释放掉智能指针托管的指针内存，并将参数指针取代之</span><br></code></pre></td></tr></table></figure><p>reset函数会将参数的指针(不指定则为NULL)，与托管的指针比较，如果地址不一致，那么就会析构掉原来托管的指针，然后使用参数的指针替代之。然后智能指针就会托管参数的那个指针了。<br><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(_Ty * _Ptr = <span class="hljs-literal">nullptr</span>)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// destroy designated object and store new pointer</span><br><span class="hljs-keyword">if</span> (_Ptr != _Myptr)<br><span class="hljs-keyword">delete</span> _Myptr;<br>_Myptr = _Ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用建议："><a href="#使用建议：" class="headerlink" title="使用建议："></a>使用建议：</h5><ol><li>尽可能不要将auto_ptr 变量定义为全局变量或指针；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 没有意义，全局变量也是一样</span><br>auto_ptr&lt;Test&gt; *tp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto_ptr</span>&lt;Test&gt;(<span class="hljs-keyword">new</span> Test);<br></code></pre></td></tr></table></figure><ol start="2"><li>除非自己知道后果，不要把auto_ptr智能指针赋值给同类型的另外一个智能指针；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-function">auto_ptr&lt;Test&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>t1 = t2;<span class="hljs-comment">// 不要这样操作...</span><br></code></pre></td></tr></table></figure><ol start="3"><li>C++11 后auto_ptr 已经被“抛弃”，已使用unique_ptr替代！C++11后不建议使用auto_ptr。</li><li><strong>auto_ptr 被C++11抛弃的主要原因</strong><ol><li>复制或者赋值都会改变资源的所有权</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// auto_ptr 被C++11抛弃的主要原因</span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// p2赋值给p1后，首先p1会先将自己原先托管的指针释放掉，然后接收托管p2所托管的指针，</span><br><span class="hljs-comment">// 然后p2所托管的指针制NULL，也就是p1托管了p2托管的指针，而p2放弃了托管。</span><br>p1 = p2;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><pre><code class="hljs">![image.png](https://cdn.nlark.com/yuque/0/2023/png/39059970/1699273259666-117ad0f3-84a7-4382-b58a-e0610613c559.png#averageHue=%231d1c1c&amp;clientId=u2ab3c3fa-7f2e-4&amp;from=paste&amp;height=254&amp;id=sVxd3&amp;originHeight=1183&amp;originWidth=2625&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=262259&amp;status=done&amp;style=none&amp;taskId=u42459c10-7d57-4e4c-8eee-a69b3aa2b68&amp;title=&amp;width=563)  2. 在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;auto_ptr&lt;string&gt;&gt; vec;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P3&quot;</span>))</span></span>;<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P4&quot;</span>))</span></span>;<br><br><span class="hljs-comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p4));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><br><span class="hljs-comment">// 风险来了：</span><br>vec[<span class="hljs-number">0</span>] = vec[<span class="hljs-number">1</span>];<span class="hljs-comment">// 如果进行赋值，问题又回到了上面一个问题中。</span><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062214663.png" alt="image.png"><br>访问越界了！</p><pre><code class="hljs">  3. 不支持对象数组的内存管理</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<span class="hljs-comment">// 不能这样定义</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062214318.png" alt="img"></p><p>所以，C++11用更严谨的unique_ptr取代了auto_ptr！</p><h2 id="三、unique-ptr"><a href="#三、unique-ptr" class="headerlink" title="三、unique_ptr"></a>三、unique_ptr</h2><p>auto_ptr是用于C++11之前的智能指针。由于 auto_ptr 基于排他所有权模式：两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。auto_ptr 主要有三大问题：</p><ol><li>复制和赋值会改变资源的所有权，不符合人的直觉。</li><li>在 STL 容器中使用auto_ptr存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。</li><li>不支持对象数组的操作</li></ol><p>以上问题已经在上面体现出来了，下面将使用unique_ptr解决这些问题。<br>所以，C++11用更严谨的unique_ptr 取代了auto_ptr！<br>unique_ptr 和 auto_ptr用法几乎一样，除了一些特殊。<br><strong>unique_ptr特性</strong></p><ol><li>基于排他所有权模式：两个指针不能指向同一个资源</li><li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</li><li>保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。</li><li>在容器中保存指针是安全的</li></ol><h5 id="A-无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值"><a href="#A-无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值" class="headerlink" title="A. 无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值"></a>A. 无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br><br>p1 = p2;<span class="hljs-comment">// 禁止左值赋值</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<span class="hljs-comment">// 禁止左值赋值构造</span><br><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>;<br>p1 = std::<span class="hljs-built_in">move</span>(p2);<span class="hljs-comment">// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = p2 赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1：&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p2：&quot;</span> &lt;&lt; p2.<span class="hljs-built_in">get</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062214156.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062212717.png" alt="image.png"><br>可以看到效果和auto_ptr一样</p><h5 id="B-在-STL-容器中使用unique-ptr，不允许直接赋值"><a href="#B-在-STL-容器中使用unique-ptr，不允许直接赋值" class="headerlink" title="B. 在 STL 容器中使用unique_ptr，不允许直接赋值"></a>B. 在 STL 容器中使用unique_ptr，不允许直接赋值</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;unique_ptr&lt;string&gt;&gt; vec;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P3&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m P4&quot;</span>))</span></span>;<br><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p4));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>vec[<span class="hljs-number">0</span>] = vec[<span class="hljs-number">1</span>];<span class="hljs-comment">/* 不允许直接赋值 */</span><br>vec[<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">move</span>(vec[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 需要使用move修饰，使得程序员知道后果</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="hljs-number">1</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062212785.png" alt="image.png"><br>当然，运行后是直接报错的，因为vec[1]已经是NULL了，再继续访问就越界了。</p><h5 id="C-支持对象数组的内存管理"><a href="#C-支持对象数组的内存管理" class="headerlink" title="C. 支持对象数组的内存管理"></a>C. 支持对象数组的内存管理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 会自动调用delete [] 函数去释放内存</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<span class="hljs-comment">// 支持这样定义</span><br></code></pre></td></tr></table></figure><p>除了上面ABC三项外，unique_ptr的其余用法都与auto_ptr用法一致。</p><ol><li>构造</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的构造函数...&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">Test</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Test的析构函数...&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;do something......&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 自定义一个内存释放其</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructTest</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Test *pt)</span> </span>&#123;<br>pt-&gt;<span class="hljs-built_in">doSomething</span>();<br><span class="hljs-keyword">delete</span> pt;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// unique_ptr&lt;T&gt; up; 空的unique_ptr，可以指向类型为T的对象</span><br>unique_ptr&lt;Test&gt; t1;<br><br><span class="hljs-comment">// unique_ptr&lt;T&gt; up1(new T());定义unique_ptr,同时指向类型为T的对象</span><br><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><br><span class="hljs-comment">// unique_ptr&lt;T[]&gt; up;空的unique_ptr，可以指向类型为T[的数组对象</span><br>unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; t3;<br><br><span class="hljs-comment">// unique_ptr&lt;T[]&gt; up1(new T[]);定义unique_ptr,同时指向类型为T的数组对象</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">t4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br><br><span class="hljs-comment">// unique_ptr&lt;T, D&gt; up();空的unique_ptr，接受一个D类型的删除器D，使用D释放内存</span><br>unique_ptr&lt;Test, DestructTest&gt; t5;<br><br><span class="hljs-comment">// unique_ptr&lt;T, D&gt; up(new T());定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存</span><br><span class="hljs-function">unique_ptr&lt;Test, DestructTest&gt; <span class="hljs-title">t6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>赋值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t8</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>t7 = std::<span class="hljs-built_in">move</span>(t8);<span class="hljs-comment">// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理</span><br>t7-&gt;<span class="hljs-built_in">doSomething</span>();<br><span class="hljs-comment">// 这时候t8智能指针已经指向空</span><br></code></pre></td></tr></table></figure><ol start="3"><li>主动释放对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;Test&gt; <span class="hljs-title">t9</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br>t9 = <span class="hljs-literal">NULL</span>;<br>t9 = <span class="hljs-literal">nullptr</span>;<br>t9.<span class="hljs-built_in">reset</span>();<br></code></pre></td></tr></table></figure><ol start="4"><li>放弃对象的控制权</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test *t10 = t9.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// t9放弃对象的控制权 把控制权交给t10</span><br></code></pre></td></tr></table></figure><ol start="5"><li>重置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t9.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Test);<br></code></pre></td></tr></table></figure><h5 id="D-auto-ptr-与-unique-ptr智能指针的内存管理陷阱"><a href="#D-auto-ptr-与-unique-ptr智能指针的内存管理陷阱" class="headerlink" title="D. auto_ptr 与 unique_ptr智能指针的内存管理陷阱"></a>D. auto_ptr 与 unique_ptr智能指针的内存管理陷阱</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">auto_ptr&lt;string&gt; p1;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;智能指针的内存管理陷阱&quot;</span>);<br>p1.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p1托管str指针</span><br>&#123;<br>auto_ptr&lt;string&gt; p2;<br>p2.<span class="hljs-built_in">reset</span>(str);<span class="hljs-comment">// p2接管str指针时，会先取消p1的托管，然后再对str的托管</span><br>&#125;<br><br><span class="hljs-comment">// 此时p1已经没有托管内容指针了，为NULL，再使用它就会内存报错！</span><br>cout &lt;&lt; <span class="hljs-string">&quot;str：&quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这是由于auto_ptr 与 unique_ptr的排他性所导致的！<br><strong>为了解决这样的问题，我们可以使用shared_ptr指针指针！</strong></p><h2 id="四、shared-ptr"><a href="#四、shared-ptr" class="headerlink" title="四、shared_ptr"></a>四、shared_ptr</h2><p>熟悉了unique_ptr 后，其实我们发现unique_ptr 这种排他型的内存管理并不能适应所有情况，有很大的局限！如果需要多个指针变量共享怎么办？</p><p>如果有一种方式，可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，<strong>引用计数</strong>加1，当智能指针析构时，<strong>引用计数</strong>减1，如果计数为零，代表已经没有指针指向这块内存，那么我们就释放它！这就是 shared_ptr 采用的策略！<br><strong>例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> v) &#123;<br><span class="hljs-keyword">this</span>-&gt;no = v;<br>cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \t no = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;no &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \t no = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;no &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> no;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数，内存删除</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DestructPerson</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Person* pt)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;DestructPerson...&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> pt;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>引用计数的使用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>shared_ptr&lt;Person&gt; sp1;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>))</span></span>;<br><br><span class="hljs-comment">// 获取智能指针管控的共享指针的数量use_count()：引用计数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-comment">// 共享</span><br>sp1 = sp2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp1use_count() = &quot;</span> &lt;&lt; sp1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sp2use_count() = &quot;</span> &lt;&lt; sp3.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062215741.png" alt="image.png"></p><p>如上代码，sp1 &#x3D; sp2; 和 shared_ptr&lt; Person &gt; sp3(sp1);就是在使用引用计数了。<br>sp1 &#x3D; sp2; –&gt; sp1和sp2共同托管同一个指针，所以他们的引用计数为2；<br>shared_ptr&lt; Person &gt; sp3(sp1); –&gt; sp1和sp2和sp3共同托管同一个指针，所以他们的引用计数为3。</p><ol start="2"><li>构造<ol><li>shared_ptr<T> sp1; 空的shared_ptr，可以指向类型为T的对象</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;Person&gt; sp1;<br>Person *person1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-number">1</span>);<br>sp1.<span class="hljs-built_in">reset</span>(person1);<span class="hljs-comment">// 托管person1</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">  2. shared_ptr&lt; T &gt; sp2(new T()); 定义shared_ptr,同时指向类型为T的对象</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp3</span><span class="hljs-params">(sp1)</span></span>;<br></code></pre></td></tr></table></figure><pre><code class="hljs">  3. shared_ptr&lt;T[]&gt; sp4; 空的shared_ptr，可以指向类型为T[]的数组对象 **C++17后支持**</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;Person[]&gt; sp4;<br></code></pre></td></tr></table></figure><pre><code class="hljs">  4.  shared_ptr&lt;T[]&gt; sp5(new T[] &#123; … &#125;); 指向类型为T的数组对象 **C++17后支持**</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Person[]&gt; <span class="hljs-title">sp5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person[<span class="hljs-number">5</span>] &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br></code></pre></td></tr></table></figure><pre><code class="hljs">  5. shared_ptr&lt; T &gt; sp6(NULL, D()); //空的shared_ptr，接受一个D类型的删除器，使用D释放内存</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp6</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>, DestructPerson())</span></span>;<br></code></pre></td></tr></table></figure><pre><code class="hljs">  6. shared_ptr&lt; T &gt; sp7(new T(), D()); //定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">sp7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">8</span>), DestructPerson())</span></span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>初始化<ol><li>方式1：构造函数</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">// int(10) 的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(up1)</span></span>;  <span class="hljs-comment">// 使用智能指针up1构造up2, 此时int(10) 引用计数为2</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">  2. 方式2：使用make_shared初始化对象，分配内存效率更高(**推荐使用**)</code></pre><p>make_shared函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr;<br>用法：make_shared&lt;类型&gt;(构造类型对象需要的参数列表);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>); <span class="hljs-comment">// 多个参数以逗号&#x27;,&#x27;隔开，最多接受十个</span><br>shared_ptr&lt;string&gt; up4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-string">&quot;字符串&quot;</span>);<br>shared_ptr&lt;Person&gt; up5 = <span class="hljs-built_in">make_shared</span>&lt;Person&gt;(<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li>赋值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptrr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">// int(10) 的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;   <span class="hljs-comment">// int(11) 的引用计数为1</span><br>up1 = up2;<span class="hljs-comment">// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2</span><br></code></pre></td></tr></table></figure><ol start="5"><li>主动释放对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>up1 = <span class="hljs-literal">nullptr</span> ;<span class="hljs-comment">// int(10) 的引用计数减1,计数归零内存释放 </span><br><span class="hljs-comment">// 或</span><br>up1 = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 作用同上 </span><br></code></pre></td></tr></table></figure><ol start="6"><li>重置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// 将p重置为空指针，所管理的对象引用计数-1</span><br>p.<span class="hljs-built_in">reset</span>(p1); <span class="hljs-comment">// 将p重置为p1(的值)，p管控的对象计数-1，p接管对p1指针的管控</span><br>p.<span class="hljs-built_in">reset</span>(p1, d); <span class="hljs-comment">// 将p重置为p1(的值)，p管控的对象计数-1，并使用d作为删除器</span><br></code></pre></td></tr></table></figure><ol start="7"><li>交换</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">swap</span>(p1,p2); <span class="hljs-comment">// 交换p1 和p2 管理的对象，原对象的引用计数不变</span><br>p1.<span class="hljs-built_in">swap</span>(p2);    <span class="hljs-comment">// 交换p1 和p2 管理的对象，原对象的引用计数不变</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr使用陷阱"><a href="#shared-ptr使用陷阱" class="headerlink" title="shared_ptr使用陷阱"></a>shared_ptr使用陷阱</h3><p>shared_ptr作为被管控的对象的成员时，小心因循环引用造成无法释放资源!<br>如下代码：<br>Boy类中有Girl的智能指针；<br>Girl类中有Boy的智能指针；<br>当他们交叉互相持有对方的管理对象时…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span> &#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">Boy</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Boy 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Boy</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Boy 析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFirend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFirend;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Girl</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Girl 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Girl</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Girl 析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br><span class="hljs-comment">// 陷阱用法</span><br>spBoy-&gt;<span class="hljs-built_in">setGirlFriend</span>(spGirl);<br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">useTrap</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062216607.png" alt="image.png"><br>可以看出，程序结束了，但是并没有释放内存，这是为什么？<br>如下图：<br>当我们执行useTrap函数时，注意，是没有结束此函数，boy和girl指针其实是被两个智能指针托管的，所以他们的引用计数是2<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062212791.png"><br>useTrap函数结束后，函数中定义的智能指针被清掉，boy和girl指针的引用计数减1，还剩下1，对象中的智能指针还是托管他们的，所以函数结束后没有将boy和gilr指针释放的原因就是于此。<br><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062216044.png"><br><strong>所以在使用shared_ptr智能指针时，要注意避免对象交叉使用智能指针的情况！</strong> 否则会导致内存泄露！<br>当然，这也是有办法解决的，那就是使用<strong>weak_ptr</strong>弱指针。<br>针对上面的情况，还讲一下另一种情况。如果是单方获得管理对方的共享指针，那么这样着是可以正常释放掉的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br><span class="hljs-comment">// 单方获得管理</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062215818.png" alt="image.png"></p><p>反过来也是一样的！<br>这是什么原理呢？</p><ol><li>首先释放spBoy，但是因为girl对象里面的智能指针还托管着boy，boy的引用计数为2，所以释放spBoy时，引用计数减1，boy的引用计数为1；</li><li>在释放spGirl，girl的引用计数减1，为零，开始释放girl的内存，因为girl里面还包含有托管boy的智能指针对象，所以也会进行boyFriend的内存释放，boy的引用计数减1，为零，接着开始释放boy的内存。最终所有的内存都释放了。</li></ol><h2 id="五、weak-ptr"><a href="#五、weak-ptr" class="headerlink" title="五、weak_ptr"></a>五、weak_ptr</h2><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, <strong>它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造</strong>, 它的构造和析构不会引起引用计数的增加或减少。 同时weak_ptr 没有重载<em>和-&gt;但可以使用</em>* lock **获得一个可用的 shared_ptr 对象。</p><ol><li>弱指针的使用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">weak_ptr wpGirl_1; <span class="hljs-comment">// 定义空的弱指针</span><br><span class="hljs-function">weak_ptr <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>; <span class="hljs-comment">// 使用共享指针构造</span><br>wpGirl_1 = spGirl; <span class="hljs-comment">// 允许共享指针赋值给弱指针</span><br></code></pre></td></tr></table></figure><ol start="2"><li>弱指针也可以获得引用计数；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">wpGirl_1.<span class="hljs-built_in">use_count</span>()<br></code></pre></td></tr></table></figure><ol start="3"><li>弱指针不支持 * 和 -&gt; 对指针的访问；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062212049.jpeg"></p><ol start="4"><li>在必要的使用可以转换成共享指针 lock()；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;Girl&gt; sp_girl;<br>sp_girl = wpGirl_1.<span class="hljs-built_in">lock</span>();<br><br><span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>使用代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br><span class="hljs-comment">// 弱指针的使用</span><br>weak_ptr&lt;Girl&gt; wpGirl_1;<span class="hljs-comment">// 定义空的弱指针</span><br><span class="hljs-function">weak_ptr&lt;Girl&gt; <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>;<span class="hljs-comment">// 使用共享指针构造</span><br>wpGirl_1 = spGirl;<span class="hljs-comment">// 允许共享指针赋值给弱指针</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;spGirl \t use_count = &quot;</span> &lt;&lt; spGirl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;wpGirl_1 \t use_count = &quot;</span> &lt;&lt; wpGirl_1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br><br><span class="hljs-comment">// 弱指针不支持 * 和 -&gt; 对指针的访问</span><br><span class="hljs-comment">/*wpGirl_1-&gt;setBoyFriend(spBoy);</span><br><span class="hljs-comment">(*wpGirl_1).setBoyFriend(spBoy);*/</span><br><br><span class="hljs-comment">// 在必要的使用可以转换成共享指针</span><br>shared_ptr&lt;Girl&gt; sp_girl;<br>sp_girl = wpGirl_1.<span class="hljs-built_in">lock</span>();<br><br>cout &lt;&lt; sp_girl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>具体用法如下：<br><strong>Boy类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Boy</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Boy</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Boy 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Boy</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Boy 析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br><br><br><span class="hljs-comment">// 在必要的使用可以转换成共享指针</span><br>shared_ptr&lt;Girl&gt; sp_girl;<br>sp_girl = <span class="hljs-keyword">this</span>-&gt;girlFriend.<span class="hljs-built_in">lock</span>();<br><br>cout &lt;&lt; sp_girl.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 使用完之后，再将共享指针置NULL即可</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>weak_ptr&lt;Girl&gt; girlFriend;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Girl</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Girl</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Girl 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Girl</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Girl 析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><br>spBoy-&gt;<span class="hljs-built_in">setGirlFriend</span>(spGirl);<br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">useTrap</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311062216021.png" alt="image.png"></p><p>在类中使用弱指针接管共享指针，在需要使用时就转换成共享指针去使用即可！<br>自此问题完美解决！</p><h2 id="六、智能指针的使用陷阱"><a href="#六、智能指针的使用陷阱" class="headerlink" title="六、智能指针的使用陷阱"></a>六、智能指针的使用陷阱</h2><ol><li>不要把一个原生指针给多个智能指针管理;</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(x)</span></span>;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(x)</span></span>;<br><span class="hljs-comment">// 警告! 以上代码使up1 up2指向同一个内存,非常危险</span><br>或以下形式：<br>up1.<span class="hljs-built_in">reset</span>(x);<br>up2.<span class="hljs-built_in">reset</span>(x);<br></code></pre></td></tr></table></figure><ol start="2"><li>记得使用u.release()的返回值;</li></ol><p>在调用u.release()时是不会释放u所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.</p><ol start="3"><li>禁止delete 智能指针get 函数返回的指针;</li></ol><p>如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果!</p><ol start="4"><li>禁止用任何类型智能指针get 函数返回的指针去初始化另外一个智能指针！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// 一个典型的错误用法 shared_ptr&lt;int&gt; sp4(sp1.get());</span><br></code></pre></td></tr></table></figure><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft_Structure翻译</title>
    <link href="/2023/10/28/Raft_Structure%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/10/28/Raft_Structure%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">Raft Structure Advice</a></p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>Raft结构建议</p><p>Raft 实例必须处理外部事件的到来（<code>Start()</code> 调用、<code>AppendEntries</code> 和 <code>RequestVote</code> RPC 以及 RPC 回复），它必须执行周期性任务（选举和心跳）。有很多方法可以构建 Raft 代码来管理这些活动; 本文档概述了一些想法。</p><p>每个 Raft 实例都有一堆状态（日志、当前索引、&amp;c) 必须更新以响应并发 goroutine 中出现的事件。 Go 文档指出，goroutines 可以直接使用共享数据结构和锁或通过在通道上传递消息来执行更新。 经验表明，对于 Raft 来说，使用共享数据和锁是最直接的。</p><p>Raft 实例有两个时间驱动的活动：领导者必须发送心跳，如果自收到领导者消息以来已经过去了太多时间，其他人必须开始选举。 最好使用专用的长时间运行的 goroutine 来驱动每个活动，而不是将多个活动组合到单个 goroutine 中。</p><p>选举超时的管理是一个常见的令人头痛的问题。 也许最简单的计划是在 Raft 结构中维护一个变量，其中包含对等点上次收到领导者消息的时间，并让选举超时 goroutine 定期检查从那时起的时间是否大于超时时间。 最简单的方法是使用 <code>time.Sleep()</code> 和一个小的常量参数来驱动定期检查。 不要使用 time.Ticker 和 time.Timer； 正确使用它们很棘手。</p><p>您需要有一个单独的长时间运行的 goroutine，它在 applyCh 上按顺序发送已提交的日志条目。 它必须是单独的，因为在 applyCh 上发送可能会阻塞； 并且它必须是单个 goroutine，否则可能很难确保按日志顺序发送日志条目。 推进 commitIndex 的代码将需要启动 apply goroutine； 为此，使用条件变量（Go 的sync.Cond）可能是最简单的。</p><p>每个 RPC 可能应该在自己的 goroutine 中发送（及其回复处理），原因有两个：这样无法到达的对等点就不会延迟大多数回复的收集，并且心跳和选举计时器可以一直继续计时。 最简单的方法是在同一个 goroutine 中进行 RPC 回复处理，而不是通过通道发送回复信息。</p><p>请记住，网络可以延迟 RPC 和 RPC 回复，并且当您发送并发 RPC 时，网络可以重新排序请求和回复。 图 2 很好地指出了 RPC 处理程序必须小心的地方（例如 RPC 处理程序应该忽略具有旧term的 RPC）。 图 2 并不总是明确说明 RPC 如何处理回复。 领导在处理回复时要小心； 它必须检查自发送 RPC 以来该term是否未更改，并且必须考虑并发 RPC 对同一追随者的回复已更改领导者状态的可能性（例如 nextIndex）。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
      <category>MIT6.824官方指导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>分布式共识算法</tag>
      
      <tag>MIT6.824官方指导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft_Locking翻译</title>
    <link href="/2023/10/27/Raft_Locking%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/10/27/Raft_Locking%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">Raft Locking原文</a></p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>Raft Locking建议</p><p>如果你想直到如在再6.824Raft实验中使用锁，这里有一些可能有用的规则和思考方式。</p><p>规则1：当你有多个goroutine使用的数据时，至少有一个goroutine可以修改数据，goroutine应该 使用锁来防止同时使用数据。The Go race detector非常擅长检测违反此规则的行为（尽管它不会帮助任何下面的规则）。</p><p>规则2：每当代码对共享数据进行一系列修改时，如果其他goroutine在序列中途查看数据，它们可能会发生故障，那么您应该在整个序列周围使用锁。</p><p>一个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br>rf.currentTerm += <span class="hljs-number">1</span><br>rf.state = Candidate<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>对于另一个goroutine来说，单独看到这些更新中的任何一个都是错误的（即旧状态和新项，或者新项和旧状态）。 因此，我们需要在整个更新序列中持续持有锁。 所有其他使用rf.currentTerm或rf.state的代码也必须持有锁，以确保所有使用的独占访问。</p><p><code>Lock</code>和<code>UnLock()</code>之间的代码通常被称为“临界区”。程序员选择的锁定规则（例如，“当使用rf.currentTerm或rf.state时，goroutine必须持有rf.mu”）通常被称为“锁定协议”。</p><p>规则3：每当代码对共享数据进行一系列的读取（或读写）时，如果另一个goroutine在序列中途修改了数据，就会发生故障，你应该在整个序列周围使用锁。</p><p>一个可能发生在Raft RPC处理程序中的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br><span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;<br>    rf.currentTerm = args.Term<br>&#125;<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>这段代码需要在整个序列中持续持有锁。Raft要求currentTerm只增加，永远不会减少。另一个RPC处理程序可以在一个单独的goroutine中执行；如果允许它在if语句和更新rf.currentTerm之间修改rf.currentTerm，那么这段代码最终可能会减少rf. currentTerm。 因此，锁必须在整个序列上连续保持。 此外，currentTerm的每一次使用都必须持有锁，以确保没有其他goroutine在我们的临界区修改currentTerm。</p><p>真实的Raft代码需要使用比这些示例更长的临界区；例如，Raft RPC处理程序可能应该持有整个处理程序的锁。</p><p>在做任何可能等待的事情时持有锁通常是一个坏主意：阅读Go通道，在通道上发送，等待计时器，调用<code>time.Sleep()</code>或发送RPC（并等待回复）。 一个原因是你可能希望其他的goroutine在等待过程中取得进展。 另一个原因是避免死锁。想象有两个peershi先发送RPC并持有锁；任何一个RPC处理程序都不会完成因为它需要哪个被正在等待的RPC调用持有的锁。</p><p>等待的代码应该首先释放锁。如果不方便的话，有时候创建一个单独的goroutine来完成等待是很有用的。</p><p>规则5：在删除和重新获取锁时要小心假设。这可能出现的一个地方是避免在锁被持有的情况下等待。例如，下面这个发送投票RPC的代码是不正确的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.mu.Lock()<br>rf.currentTerm += <span class="hljs-number">1</span><br>rf.state = Candidate<br><span class="hljs-keyword">for</span> &lt;each peer&gt; &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        rf.mu.Lock()<br>        args.Term = rf.currentTerm<br>        rf.mu.Unlock()<br>        Call(<span class="hljs-string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)<br>        <span class="hljs-comment">// handle the reply...</span><br>    &#125; ()<br>&#125;<br>rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>代码在不同的goroutine中发送每个RPC。上面的代码不正确是因为<code>args.Term</code>可能和周围代码决定成为<code>Candidate</code>的<code>rf.currentTerm</code>不同。从周围的代码创建goroutine到goroutine读取<code>rf.currentTerm</code>之间可能会经过很多时间；例如，多个term可能来来去去，peer可能不再是候选者。解决这个问题的一种方法是让创建的goroutine在尾部代码持有锁时创建<code>rf.currentTerm</code>的副本。类似地，<code>Call()</code>之后地回复处理代码必须在重新获取锁之后重新检查相关假设；例如，它应该检查<code>rf.currentTerm</code>自决定成为候选者以来没有更改。</p><p>可能很难解释和应用这些规则。 也许最令人困惑的是规则2和规则3中关于代码序列不应该与其他goroutine的读或写交错的概念。 如何识别这样的序列呢？ 如何决定一个序列应该在哪里开始和结束？</p><p>一种方法是从没有锁的代码开始，仔细考虑需要在哪里添加锁以获得正确性。这种方法可能很困难，因为它需要对并发代码的正确性进行推理。</p><p>一个更实用的方法是从观察开始的，如果没有并发（没有同时执行的goroutine），你就根本不需要锁。 但是，当RPC系统创建goroutine来执行RPC处理程序时，您必须强制并发，因为您需要在单独的goroutine中发送RPC以避免等待。你可以通过识别所有goroutine开始的地方（RPC处理程序，你在<code>Make()</code>中创建的后台goroutine，&amp;c），在每个goroutine开始时获取锁，只有当goroutine完全完成并返回时才释放锁，来有效地消除这种并发性。这个锁协议确保了没有任何重要的东西会并行执行；锁确保每个goroutine在其他goroutine被允许开始之前执行完毕。 由于没有并行执行，很难违反规则1、2、3或5。 如果每个goroutine的代码在隔离状态下是正确的（当单独执行时，没有并发goroutine），那么当您使用锁来抑制并发时，它可能仍然是正确的。 因此，您可以避免对正确性进行显式推理，或显式识别关键部分。</p><p>但是，第四条规则可能是一个问题。 因此，下一步是找到代码等待的地方，并根据需要添加锁释放和重新获取（和&#x2F;或goroutine创建），在每次重新获取之后小心地重新建立假设。 您可能会发现这个过程比直接识别必须锁定以确保正确性的序列更容易正确。</p><p>（顺便说一句，这种方法牺牲的是荣国多核并行执行获得更好性能的任何机会：你的代码可能在不需要的时候拥有锁，因此可能不必要地禁止goroutine地并行执行。另一方面，在单个Raft对等体中没有太多地CPU并行机会。）</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
      <category>MIT6.824官方指导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>分布式共识算法</tag>
      
      <tag>MIT6.824官方指导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Students_Guide_to_Raft翻译</title>
    <link href="/2023/10/27/Students_Guide_to_Raft%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/10/27/Students_Guide_to_Raft%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a></p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在我们深入研究Raft之前，一些背景可能是有用的。6.824曾经有一组<a href="http://nil.csail.mit.edu/6.824/2015/labs/lab-3.html">基于Paxos的实验</a>，它们都是用<a href="https://go.dev/">Go语言</a>构建的;之所以选择Go，是因为它对学生来说很容易学习，而且非常适合编写并发的分布式应用程序（goroutine特别方便）。在四个实验的过程中，学生构建了一个容错的分片键值存储。第一个实验让他们构建了一个基于共识的日志库，第二个实验在此基础上添加了一个键值存储，第三个实验将多个容错集群之间的键空间分片，并由容错分片主机处理配置更改。我们还有第四个实验，学生们必须处理机器的故障和恢复，无论磁盘是否完好无损。这个实验是学生的默认期末专题。</p><p>今年，我们决定使用Raft重写所有这些实验。前三个实验都是一样的，但是第四个实验被放弃了，因为持久性和故障恢复已经内置到Raft中。本文将主要讨论我们在第一个实验中的经验，因为它是与Raft最直接相关的实验，尽管我也将涉及在Raft之上构建应用程序（如第二个实验）。</p><p>对于那些刚刚开始了解Raft的人来说，<a href="https://raft.github.io/">Raft算法网站</a>上的文字对Raft进行了最好的描述：</p><blockquote><p>Raft是一个共识算法，旨在易于理解。它在容错和性能方面与Paxos相当。不同的是，它被分解成相对独立的子问题，并且它清楚地解决了实际系统所需的所有主要部分。我们希望Raft能够让更多的人获得共识，并且这些更广泛的人能够开发出比现在更高质量的基于共识的系统。</p></blockquote><p>像这样的<a href="https://thesecretlivesofdata.com/raft/">可视化</a>给予了协议主要组件的一个很好的概述，并且该论文给出了直观地给出了为什么需要各个部分。如果您还没有阅读过<a href="https://raft.github.io/raft.pdf">扩展的Raft论文</a>，那么在继续本文之前，您应该先阅读一下，因为我将假定您对Raft相当熟悉。</p><p>像其他的分布式共识算法一样，细节决定成败。在没有故障的稳定状态下，Raft的行为很容易理解，并且可以以直观的方式解释。例如，从可视化中可以很容易地看到，假设没有失败，最终将选出一个领导者，并且最终发送给领导者的所有操作都将由追随者以正确的顺序应用。然而，当引入延迟消息、网络分区和故障服务器时，每一个if、but和and都变得至关重要。特别是，我们发现有许多 bug 会反复出现，原因很简单，就是在阅读论文时产生了误解或疏忽。这个问题并非 Raft 独有，所有提供正确性的复杂分布式系统都会遇到这个问题。这个问题并不是Raft所独有的，在所有提供正确性的复杂分布式系统中都会出现。</p><h4 id="实现Raft"><a href="#实现Raft" class="headerlink" title="实现Raft"></a>实现Raft</h4><p>Raft的最终指南在Raft论文的图2中。此图指定了在Raft服务器之间交换的每个RPC的行为，给出了服务器必须维护的各种不变量，并指定了某些操作应该何时发生。我们将在本文的其余部分中<strong>大量</strong>讨论图2。<strong>必须严格遵守</strong>。</p><p>图2定义了在任何状态下，每个服务器应该为每个传入的RPC做什么，以及何时应该发生某些其他事情（例如，何时可以安全地应用日志中的条目）。首先，您可能会试图将图2视为某种非正式的指南;您只读了一遍，然后开始编写一个实现，该实现大致遵循它所说的内容。这样做，您将快速启动并运行一个主要工作的Raft实现。然后问题就开始了。</p><p>事实上，图2是非常精确的，它所做的每一个声明都应该被视为<strong>必须</strong>，而不是<strong>应该</strong>。例如，当您收到一个<code>AppendEntries</code>或<code>RequestVote</code> RPC时，您可以合理地重置一个peer的选举计时器，因为这两者都表明其他对等体认为它是领导者，或者正在试图成为领导者。直觉上，这意味着我们不应该干涉。但是，如果你仔细阅读图2，它说：</p><blockquote><p>如果选举超时，而没有收到来自当前领导人的<code>AppendEntries</code>RPC或没有为候选人<strong>授予</strong>投票：转换为候选人。</p></blockquote><p>事实证明，这种区别很重要，因为前一种实现在某些情况下会导致活性显著降低。</p><p><u>译者注解：注意，这里的<strong>当前领导人</strong>和<strong>授予投票</strong>很重要。</u></p><h5 id="细节的重要性"><a href="#细节的重要性" class="headerlink" title="细节的重要性"></a>细节的重要性</h5><p>为了使讨论更具体，让我们考虑一个例子，让做6.824的学生出错。Raft论文在许多地方提到了心跳RPC。具体来说，领导者会偶尔（至少每个心跳间隔一次）向所有peer发送一个<code>AppendEntries</code>RPC，以防止它们开始新的选举。如果leader没有新的entries要发送到特定的peer，则该<code>AppendEntries</code>RPC不包含任何条目，并被视为心跳。</p><p>许多同学会认为心跳是有些“特殊的”；当一个peer收到心跳时，它应该将其与非心跳的<code>AppendEntries</code>RPC区别对待，许多人的实现是在peer收到心跳时简单地重置它们地选举定时器，然后返回success，而不执行图2中指定地任何检查。这是<strong>非常危险</strong>的。通过接受RPC，follower隐式地告诉leader他们的日志与leader的日志匹配，直到<code>prevLogIndex</code>(包括<code>prevLogIndex</code>的位置都是匹配的，这个<code>prevLogIndex</code>被包含在<code>AppendEntries</code>的参数中)。当Leader收到返回结果的时候，它可能会认为一些entries已经被复制到了大多数的server上(然而这是错误的)，并开始commit这些entries。</p><p>许多人遇到的另一个问题(通常是在解决上述问题后立刻出现的)是，当接收到一个心跳的时候，它们会截断follower的日志中在<code>prevLogIndex</code>之后的日志，然后在follower的日志上附加上所有从<code>AppendEntries</code>参数中传进来的entries。这<strong>同样</strong>也是不正确的，我们可以再一次看向图2：</p><blockquote><p><strong>如果</strong>现有的entry和新的entry冲突(相同的index但是不同的term)，则删除现有entry及其后面的所有entry。</p></blockquote><p>这里的<strong>如果</strong>是很关键的。如果这个follower拥有leader发送过来的所有entry，那么这个follower就<strong>绝对不应该</strong>截断它的log。必须保留领导者发送的entries之后的任何元素。这是因为我们可能从leader那里收到了一个过时的<code>AppendEntries</code>RPC，并且截断log的话意味着“收回”我们可能已经告诉leader的我们的日志中的entry。</p><h4 id="Debugging-Raft"><a href="#Debugging-Raft" class="headerlink" title="Debugging Raft"></a>Debugging Raft</h4><p>不可避免地，你的第一次Raft实现已经会是错误的，第二次也是，然后是第三次、第四次。一般来说，每一个都会比前一次少一些bug，而且根据经验，大多数的bug都是因为没有忠实地遵循图2。</p><p>当你在debug地时候，Raft通常有四个主要的bug来源：</p><ul><li>活锁</li><li>不正确或者不完整的RPC handlers</li><li>未能遵守规则</li><li>term的混淆</li></ul><p>除以上四个，死锁也是一个常见的问题，但是死锁这个问题通常可以通过记录所有的锁定和解锁来调试，并找出你正在使用但是没有释放的锁。让我们依次考虑其中的每一个：</p><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>当你的系统活锁，系统中的每一个节点都在做一些事情，但是所有的节点集体处于一种没有进展的状态。这在Raft中很容易发生，特别是如果你不严格遵循图2的话。一种活锁的场景出现地特别频繁；没有领导者被选举出来，或者一旦一个领导者被选举出来，其他一些节点就开始选举，迫使最近当选地领导者立即退位。</p><p>出现这种情况的原因有很多，但是这里有一些很多学生都犯过的错误：</p><ul><li><p><strong>确保</strong>你完全按照图2所示的重置了选举计时器。具体来说，你应该只在以下几种情况出现时重新启动你的选举计时器，如果a)你从<strong>当前</strong>的Leader处收到了一个<code>AppendEntries</code>RPC(即，如果在<code>AppendEntries</code>中的term已经过期了，那么就不应该重置计时器)；b)你正在开始一个选举；c)你将投票授权给另外一个peer</p><p>最后一种情况在不可靠的网络中尤其重要，因为在这种情况下，follower可能有不同的日志；在这种情况下，通常会有很少一部分的服务器，而大多数服务器都愿意为这一小部分服务器投票。如果一有别人请求你为它们投票你就重置选举计时器的话，这会使得具有过时日志的服务器和具有较长日志的服务器有相同的可能性向前迈进。</p><p>事实上，因为只有很少的服务器有足够的最新日志，这些服务器不太可能在足够的和平中举行选举。如果你遵循图2中的规则，具有最新日志的服务器将不会被过时服务器的选举所打断，因此更有可能完成选举并成为领导者。</p></li><li><p>遵循图2的指示决定何时开始选举。特别要注意的时，如果你是一个候选人(即，你现在正在进行一场选举)，但是选举计时器触发，你应该开始另一场选举。这对于避免由于RPC延迟或丢弃而导致的系统停滞非常重要。</p></li><li><p>在处理传入的RPC之前，请确保遵循“Rules for Servers”(在论文的图2中)中的第二条规定。第二条规定说：</p><blockquote><p>如果RPC request或者response中包含了term T &gt; currentTerm：那么就设置currentTerm &#x3D; T，并且转换为Follower</p></blockquote><p>举个例子。如果你在当前term已经投过票了，并且传入了一个有着更高term的<code>RequestVote</code>RPC，你应该首先停下并采用它们的term(从而重置votedFor)，然后处理RPC，这将导致你授予投票！</p></li></ul><h5 id="不正确的RPC处理程序"><a href="#不正确的RPC处理程序" class="headerlink" title="不正确的RPC处理程序"></a>不正确的RPC处理程序</h5><p>尽管图2详细说明了每个RPC处理程序应该做什么，但仍容易忽略一些细微之处。下面是我们反复看到的一些例子，你应该在实现中注意：</p><ul><li><p>如果某个步骤显示“reply false”，这意味着您应该立即回复，而不执行任何后续步骤。</p></li><li><p>如果你得到了一个<code>AppendEntries</code>RPC，RPC里面的<code>prevLogIndex</code>指向超出了你日志的结尾(prevLogIndex &gt;&#x3D; len(rf.logs))，你应该像你确实有那个entry但是term不匹配来处理它(即，回复为false)</p></li><li><p>即使<strong>leader没有发送任何的entries</strong>，也应该检查图2以确定是否有RPC处理程序。</p></li><li><p>最后一步（#5）的最小值是必需的，它需要用最后一个<strong>新</strong>条目的索引来计算。仅仅有一个从你的log中应用从<code>lastApplied</code>到<code>commitIndex</code>的entry的函数并在到达log的结尾时停止的函数是<strong>不够</strong>的。这是因为您的日志中的entries可能与领导者发送给您的entries（这些条目都与您的日志中的条目匹配）不同。因为#3规定只有在条目冲突的情况下才截断日志，这些entry不会被删除，如果leaderCommit超出了leader发送给您的条目，您可能会应用不正确的entry。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202310271623270.png" alt="image-20231027162302164"><br><u>译者注解：这里的意思是说可能有这样一种情况：</u></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202310271640961.png" alt="image-20231027164049901"></p><p><u>如上图，从lastApplied+1到LeaderCommit这之间的term都与Follower日志中的entry匹配，所以这些entry不会被删除，如果LeaderCommit超出了上面的LeaderCommit，那么就有可能应有不正确的entry。</u></p></li><li><p>严格按照第5.4节所述执行“最新日志”检查<strong>非常重要</strong>。不要欺骗自己只是检查它的长度！</p></li></ul><h5 id="未能遵守规则"><a href="#未能遵守规则" class="headerlink" title="未能遵守规则"></a>未能遵守规则</h5><p>虽然Raft的文章非常明确地说明了如何实现每个RPC处理程序，但它也没有说明许多规则和不变量的实现。这些都列在图2右侧的“Rules for Servers”块中。虽然其中一些是相当不言自明的，但也有一些需要非常仔细地设计您的应用程序，以便它不违反The Rules：</p><ul><li><p>如果在执行过程中的任何时候<code>commitIndex</code> &gt; <code>lastApplied</code>，则应应用特定的日志条目。是否直接执行此操作并不重要（例如，在<code>AppendEntries</code>RPC处理程序中），但重要的是确保此应用程序仅由一个实体执行。具体来说，你需要有一个专用的“applier”，或者锁定这些applies，这样其他一些例程就不会检测到需要应用的条目，也会尝试应用。</p></li><li><p>确保定期检查commitIndex &gt; lastApplied，或者在commitIndex更新后（即，在matchIndex更新之后）。例如，如果您在向peer发送<code>AppendEntries</code>的同时检查commitIndex，则可能必须等到<strong>下一个</strong>entry被追加到日志中，然后才能应用刚刚发送并得到确认的entry。</p></li><li><p>如果一个leader发送了一个<code>AppendEntries</code>RPC，并且被拒绝了，但是<strong>不是因为日志不一致的原因</strong>(唯一的原因只有leader的任期已经结束了)，那么leader应该立即下台，并且<strong>不要</strong>更新<code>nextIndex</code>。如果你更新了，那么如果你立即重新开始选举，那就会和重置<code>nextIndex</code>操作冲突。</p></li><li><p>一个leader不允许将commitIndex更新到上一个term(或者未来term)的某个位置。因此，正如规则所说，你需要特别检查<code>log[N].term == currentTerm</code>。这是因为如果entry不是来自当前term，Raft领导者无法确定entry是否实际提交了(并且将来不会被更改)。这在本文的图8中得到了说明。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202310271711296.png" alt="image-20231027171132235"></p></li></ul><p>一个常见的混淆来源是nextIndex和matchIndex之间的差异。特别是，你可能会观察到matchIndex &#x3D; nextIndex - 1，而根本没有实现matchIndex。这是不安全的。虽然nextIndex和matchIndex通常会同时更新为类似的值(具体来说，nextIndex &#x3D; matchIndex + 1)，但是两者的用途完全不同。nextIndex是关于leader与给定follower共享什么前缀的猜测。它通常是相当乐观的(Leader分享一切)，只有在负面反应时才向后移动。例如，当一个leader刚刚被选举时，nextIndex被设置为日志末尾entry的index。在某种程度上，nextIndex用于性能——你只需要将这些东西发送给peer。</p><p><code>matchIndex</code>被用于安全。这是一个关于这个leader的日志的哪些前缀需要共享给给定的follower的保守的测量。<code>matchIndex</code>的值不能被设置得太高，因为这有可能导致<code>commitIndex</code>向前移动得太远。这是为什么<code>matchIndex</code>被初始化为-1(即，我们认为没有前缀是一致的)，并且只有当一个follower肯定地确认了一个<code>AppendEntries</code>RPC时才会更新<code>matchIndex</code>。</p><h5 id="任期混淆"><a href="#任期混淆" class="headerlink" title="任期混淆"></a>任期混淆</h5><p>任期混淆是指服务器被来自旧任期的RPC混淆。一般来说，在接收RPC时这不是问题，因为图2中的规则准确地说明了当你看到一个旧的term的时候应该做什么。然而，图2一般不会讨论当您得到了旧的RPC<strong>回复</strong>时应该做什么。根据经验，我们发现到目前为止最简单的方法是首先在回复中记录term(它可能高于您当前的term)，然后将当前term与你在原始RPC中发送的term进行比较。如果两者不同，就删除回复并返回。<strong>只有</strong>当两个term相同时，你才应该继续处理答复。你可以通过一些巧妙的协议推理来做进一步的优化，但是前面说的这种方法似乎效果不错。如果<strong>不</strong>这样做，就会走上一条漫长而曲折的道路，其中充满了鲜血、汗水、泪水和绝望。</p><p>一个相关但不完全相同的问题时，假设在发送RPC和收到回复之间你的状态(Leader&#x2F;Candidate&#x2F;Follower)没有改变。一个很好的例子是，当你收到对RPC的响应时，设置<code>matchIndex = nextIndex - 1</code>或者<code>matchIndex = len(log)</code>。这是不安全的，因为这两个值都有可能在发送RPC后被更新。取而代之，正确的做法是将<code>matchIndex</code>更新为你最初在RPC中发送的参数中的<code>prevLogIndex + len(entries[])</code></p><h5 id="An-aside-on-optimizations"><a href="#An-aside-on-optimizations" class="headerlink" title="An aside on optimizations"></a>An aside on optimizations</h5><p>Raft文件包括一些有趣的可选特性。在6.824中，我们需要学生去实现其中的两件事：日志压缩(section 7)和加速日志回溯(第8页顶部左侧)。前者是避免日志无限制增长所必需的，而后者则有助于快速更新过时的followers。</p><p>这些功能不是”core Raft”的一部分，因此在论文中没有像主要共识算法那样受到足够多的关注。日志压缩已经相当全面地介绍过了(如图13所示)，但是忽略了一些设计细节，如果你读得太随意，可能会错过这些细节：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/202311011048144.png" alt="image-20231101104821961"></p><ul><li><p>当对某个应用程序状态进行快照时，需要确保应用程序状态与Raft日志中某个已知索引之后的状态相对应。这意味着应用程序要么需要向Raft传达快照对应的索引，要么Raft需要延迟应用其他日志条目，直到快照完成。</p></li><li><p>本文没有讨论服务器崩溃时的恢复协议，因为现在涉及到了快照。特别是，如果单独提交Raft状态和快照，服务器可能会在持久化快照和持久化更新的Raft状态之间崩溃。这是一个问题，因为图13中的步骤6规定快照所覆盖的Raft日志<strong>必须被丢弃</strong>。</p><p>如果服务器重新启动的时候，它读取更新的快照，但是读取过时的日志，它可能最终应用快照中<strong>已包含的某些日志条目</strong>。这是因为commitIndex和lastApplied没有持久化，所以Raft不知道这些日志条目已经被应用。解决方法是向Raft引入一段持久化状态，记录Raft持久日志中第一个条目对应的“真实的”索引。然后可以将其与加载的快照的<code>lastIncludedIndex</code>进行比较，以确定要丢弃日志头部的哪些元素。</p></li></ul><p>加速日志回溯优化的详细说明非常少，可能是因为作者认为它对于大多数部署都不是必需的。从文本中并不清楚从客户端发送回来的冲突index和term应该如何被领导者用来确定去使用什么nextIndex。我们相信作者<strong>可能</strong>希望您遵循的协议是：</p><ul><li>如果一个follower的log中没有位于prevLogIndex上的entry的话，那么它应该返回<code>conflictIndex = len(log)</code>和<code>conflictTerm = None</code>。</li><li>如果一个follower的log中有位于prevLogIndex上的entry的话，但是term不匹配，它应该返回<code>conflictTerm = log[prevLogIndex].Term</code>，然后在它的log中找到第一个term与conflictTerm匹配的entry，得到这个entry的index。</li><li>收到冲突响应后，leader应该首先在其日志中搜索conflictTerm。如果它在日志中找到一个包含该term的entry，它应该将<code>nextIndex</code>设置为日志中该term中最后一个entry的索引之后的索引。</li><li>如果没有找到有那个term的entry，它应该将设置<code>nextIndex = conflictIndex</code>。</li></ul><p>一个折中的解决方案是使用<code>conflictIndex</code>(忽略<code>conflictTerm</code>)，这简化了实现，但是leader有时会向follower发送比使它们更新严格必要的更多的log entries。</p><h5 id="Applications-on-top-of-Raft"><a href="#Applications-on-top-of-Raft" class="headerlink" title="Applications on top of Raft"></a>Applications on top of Raft</h5><p>当在Raft之上构建服务时（例如第二个6.824 Raft实验中的键&#x2F;值存储），服务和Raft日志之间的交互可能很难正确。本节详细介绍了开发过程的一些方面，你可能会发现这些方面在构建应用程序时很有用。</p><h5 id="应用客户端操作"><a href="#应用客户端操作" class="headerlink" title="应用客户端操作"></a>应用客户端操作</h5><p>您可能对如何使用复制的日志实现应用程序感到困惑。你可以从你的服务开始，每当它收到客户端请求时，将该请求发送给leader，等待Raft应用某些东西，执行客户端请求的操作，然后返回到客户端。虽然这在单客户端系统中很好，但它不适用于并发客户端。</p><p>相反，服务应该构造为<strong>状态机</strong>，客户端操作将机器从一种状态转换到另一种状态。你应该在某个地方有一个循环，它一次接受一个客户端操作（在所有服务器上都是相同的顺序-这就是Raft的作用），并按顺序将每个操作应用于状态机。这个循环应该是你的代码中<strong>唯一</strong>涉及应用程序状态的部分（6.824中的键&#x2F;值映射）。这意味着您的面向客户端的RPC方法应该简单地将客户端的操作提交给Raft，然后等待该操作被这个“applier循环”应用。只有当客户端的命令出现时，才应该执行它，并读取任何返回值。请注意，<strong>这包括读取请求</strong>！</p><p>这就带来了另一个问题：如何知道客户端操作何时完成？在没有失败的情况下，这很简单——您只需等待放入日志中的内容返回即可(即，通过apply())。当这种情况发生时，您将结果返回给客户端。但是，如果出现故障怎么办？例如，当客户最初联系您时，您可能是领导者，但现在其他人已经当选，并且您放入日志中的客户请求已被丢弃。显然，你需要让客户端再试一次，但你如何知道何时告诉他们错误？</p><p>解决这个问题的一个简单方法是记录客户端操作在插入时出现在Raft日志中的位置。一旦该索引处的操作被发送到<code>apply()</code>，你就可以根据该索引出现的操作是否实际上是您放在那里的操作来判断客户端操作是否成功。如果不是，则发生了故障，并且可以向客户端返回错误。</p><h5 id="重复检测"><a href="#重复检测" class="headerlink" title="重复检测"></a>重复检测</h5><p>一旦客户端在遇到错误时重试操作，您就需要某种重复检测方案——如果客户端向服务器发送<code>APPEND</code>，没有收到回复，并将其重新发送到下一个服务器，则<code>apply()</code>函数需要确保<code>APPEND</code>不会执行两次。要做到这一点，您需要为每个客户端请求提供某种唯一的标识符，以便您可以识别过去是否看到过（更重要的是，是否应用过）特定的操作。此外，此状态需要成为状态机的一部分，以便所有Raft服务器<strong>消除</strong>相同的重复项。</p><p>有许多方法可以指定这种标识符。一个简单而有效的方法是给给予每个客户端一个唯一的标识符，然后让它们用单调递增的序列号标记每个请求。如果客户端重新发送请求，它将重复使用相同的序列号。您的服务器跟踪它从每个客户端看到的最新序列号，并简单地忽略它已经看到的任何操作。</p><h5 id="Hairy-corner-cases"><a href="#Hairy-corner-cases" class="headerlink" title="Hairy corner-cases"></a>Hairy corner-cases</h5><p>如果您的实现遵循上面给出的general outline，那么您可能会遇到至少两个微妙的问题，如果不进行认真的调试，这些问题可能很难识别。为了节省你的时间，它们在这里：</p><p>Re-appearing indices(多次出现的索引)：假设你的Raft库中有方法<code>Start()</code>可以接受一个命令，并返回该命令在日志中的索引（以便您知道何时返回客户端，如上所述）。你可能会假设你永远不会看到<code>Start()</code>返回一个相同的index两次，或者退一步说如果你看到了一个index两次，那么第一次返回该索引的命令一定失败了。事实证明，即使没有服务器崩溃，这两件事都不是真的。</p><p>请考虑以下包含五台服务器（S1到S5）的场景。最初，S1是领导者，其日志为空。</p><ol><li>两个客户端操作（C1和C2）到达S1。</li><li><code>Start()</code>操作C1返回1，C2返回2。</li><li>S1向S2发送一个包含C1和C2的<code>AppendEntries</code>，但它的所有其他报文都丢失了。</li><li>S3继续向前成为了候选人</li><li>S1和S2不会投票给S3，但S3、S4和S5都会投票，所以S3成为领导者。</li><li>另一个客户端请求C3进入S3。</li><li>S3调用<code>Start()</code>（返回1）</li><li>S3向S1发送一个<code>AppendEntries</code>，S1从日志中删除C1和C2，并添加C3。</li><li>S3在向任何其他服务器发送<code>AppendEntries</code>之前失败。</li><li>S1前进，因为它的日志是最新的，所以它被选为领导者。</li><li>另一个客户端请求C4到达S1</li><li>S1调用<code>Start()</code>，返回2（<code>Start(C2)</code>也返回2）。</li><li>所有S1发送出去的<code>AppendEntries</code>都丢失了，S2向前</li><li>S1和S3不会投票给S2，但S2、S4和S5都会投票，所以S2成为领导者。</li><li>客户端请求C5进入S2</li><li>S2调用<code>Start()</code>，返回3。</li><li>S2成功地向所有的服务器发送了<code>AppendEntries</code>，S2通过在下一个心跳中包括更新的<code>leaderCommit = 3</code>来向服务器报告。</li></ol><p>由于S2的日志是<code>[C1 C2 C5]</code>，这意味着在索引2处提交（并在所有服务器上应用，包括S1）的条目是C2。尽管C4是在S1处返回索引2的最后一个客户端操作。</p><h5 id="The-four-way-deadlock"><a href="#The-four-way-deadlock" class="headerlink" title="The four-way deadlock"></a>The four-way deadlock</h5><p>所有的功劳都归功于<a href="https://stebalien.com/">史蒂芬艾伦</a>，另一个6.824 TA。他发现了以下令人讨厌的四向死锁，当在Raft上构建应用程序时，您很容易陷入这种死锁。</p><p>不管Raft代码的结构如何，它可能有一个类似<code>Start()</code>的函数，允许应用程序向Raft日志添加新命令。它同样可能有一个死循环，当<code>commitIndex</code>被更新时，在应用程序上为<code>lastApplied</code>和<code>commitIndex</code>之间的日志中的每个元素调用<code>apply()</code>。这些例程可能都需要一些锁<code>a</code>。在基于Raft的应用程序中，您可能会在RPC处理程序中的某个位置调用Raft的<code>Start()</code>函数，并且在其他位置有一些代码，每当Raft应用新的日志条目时，就会通知这些代码。由于这两者需要通信（即，RPC方法需要知道它放入日志中的操作何时完成），它们可能都需要一些锁<code>b</code>。</p><p>在Go中，这四个代码段可能看起来像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *App)</span></span> RPC(args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-comment">// ...</span><br>    a.mutex.Lock()<br>    i := a.raft.Start(args)<br>    <span class="hljs-comment">// update some data structure so that apply knows to poke us later</span><br>    a.mutex.Unlock()<br>    <span class="hljs-comment">// wait for apply to poke us</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> Start(cmd <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">int</span> &#123;<br>    r.mutex.Lock()<br>    <span class="hljs-comment">// do things to start agreement on this new command</span><br>    <span class="hljs-comment">// store index in the log where cmd was placed</span><br>    r.mutex.Unlock()<br>    <span class="hljs-keyword">return</span> index<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *App)</span></span> apply(index <span class="hljs-type">int</span>, cmd <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    a.mutex.Lock()<br>    <span class="hljs-keyword">switch</span> cmd := cmd.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> GetArgs:<br>        <span class="hljs-comment">// do the get</span><br><span class="hljs-comment">// see who was listening for this index</span><br><span class="hljs-comment">// poke them all with the result of the operation</span><br>    <span class="hljs-comment">// ...</span><br>    &#125;<br>    a.mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> AppendEntries(...) &#123;<br>    <span class="hljs-comment">// ...</span><br>    r.mutex.Lock()<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">for</span> r.lastApplied &lt; r.commitIndex &#123;<br>      r.lastApplied++<br>      r.app.apply(r.lastApplied, r.log[r.lastApplied])<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    r.mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>现在考虑系统是否处于以下状态：</p><ul><li><code>App.RPC</code>刚刚接受了一个<code>a.mutex</code>并调用了<code>Raft.Start</code></li><li><code>Raft.Start</code>正在等待锁<code>r.mutex</code></li><li><code>Raft.AppendEntries</code>持有锁<code>r.mutex</code>，并且刚刚调用了<code>App.apply</code></li></ul><p>我们现在陷入死锁，因为：</p><ul><li><code>Raft.AppendEntries</code>不会释放它持有的锁直到<code>App.apply</code>返回</li><li><code>App.apply</code>不会返回直到它得到了锁<code>a.mutex</code></li><li><code>a.mutex</code>不会被释放直到<code>App.RPC</code>返回</li><li><code>App.RPC</code>不会返回直到<code>Raft.Start</code>返回</li><li><code>Raft.Start</code>不会返回直到它得到<code>r.mutex</code></li><li><code>Raft.Start</code>必须等待<code>Raft.AppendEntries</code></li></ul><p>有几种方法可以解决这个问题。最简单的方法是在<code>App.RPC</code>调用<code>a.raft.Start</code>之后再获取锁<code>a.mutex</code>。但是，这意味着在<code>App.RPC</code>有机会记录它希望得到通知的事实之前，<code>App.apply</code>可能会被调用来执行<code>App.RPC</code>刚刚调用的<code>Raft.Start </code>操作。另一种可能产生更整洁设计的方案是使用一个从<code>Raft</code>调用<code>r.app.apply</code>的专用线程。这个线程可以在每次更新<code>commitIndex</code>时得到通知，然后不需要持有锁来应用，从而打破死锁。</p>]]></content>
    
    
    <categories>
      
      <category>MIT6.824官方指导</category>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>分布式共识算法</tag>
      
      <tag>MIT6.824官方指导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解go_Cond</title>
    <link href="/2023/10/21/%E8%AF%A6%E8%A7%A3go_Cond/"/>
    <url>/2023/10/21/%E8%AF%A6%E8%A7%A3go_Cond/</url>
    
    <content type="html"><![CDATA[<h2 id="1-sync-Cond的使用场景"><a href="#1-sync-Cond的使用场景" class="headerlink" title="1.sync.Cond的使用场景"></a>1.sync.Cond的使用场景</h2><blockquote><p>一句话总结：sync.Cond条件变量用来协调想要访问共享资源的那些goroutine，当共享资源的状态发生变化的时候，它可以用来通知被互斥锁阻塞的goroutine</p></blockquote><p><code>sync.Cond</code>基于互斥锁&#x2F;读写锁，它和互斥锁的区别是什么呢？</p><p>互斥锁<code>sync.Mutex</code>通常用来保护临界区和共享资源，条件变量<code>sync.Cond</code>用来协调想要访问共享资源的goroutine。</p><p><code>sync.Cond</code>经常用在多个goroutine等待，一个goroutine通知(时间发生)的场景。如果是一个通知，一个等待，使用互斥锁或者channel就可以搞定了。</p><p>我们想象一个非常简单的场景：</p><p>有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接受完数据，才能读取到正确的数据。在这种情况下，如果单纯地使用chan或互斥锁，那么只能有一个协程可以等待，并读取到数据，没有办法通知其他的协程也读取数据。</p><p>这个时候，就需要有一个全局的变量来标志第一个协程数据是否接收完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个channel，每个协程阻塞在一个channel上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。</p><p>Go语言在标准库sync中内置一个<code>sync.Cond</code>用来解决这类问题。</p><h2 id="2-sync-Cond的四个方法"><a href="#2-sync-Cond的四个方法" class="headerlink" title="2. sync.Cond的四个方法"></a>2. sync.Cond的四个方法</h2><p><code>sync.Cond</code>的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),</span><br><span class="hljs-comment">// which must be held when changing the condition and</span><br><span class="hljs-comment">// when calling the Wait method.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A Cond must not be copied after first use.</span><br><span class="hljs-keyword">type</span> Cond <span class="hljs-keyword">struct</span> &#123;<br>        noCopy noCopy<br><br>        <span class="hljs-comment">// L is held while observing or changing the condition</span><br>        L Locker<br><br>        notify  notifyList<br>        checker copyChecker<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个Cond实例都会关联一个锁L(互斥锁*Mutex，或读写锁 *RWMutex)，当修改条件或者调用Wait方法时，必须加锁。</p><p>和<code>sync.Cond</code>相关的有如下几个方法：</p><h3 id="2-1-NewCond创建实例"><a href="#2-1-NewCond创建实例" class="headerlink" title="2.1 NewCond创建实例"></a>2.1 NewCond创建实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewCond returns a new Cond with Locker l.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCond</span><span class="hljs-params">(l Locker)</span></span> *Cond &#123;<br><span class="hljs-keyword">return</span> &amp;Cond&#123;L: l&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NewCond创建Cond实例时，需要关联一个锁。</p><h3 id="2-2-Broadcast广播唤醒所有"><a href="#2-2-Broadcast广播唤醒所有" class="headerlink" title="2.2 Broadcast广播唤醒所有"></a>2.2 Broadcast广播唤醒所有</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Broadcast wakes all goroutines waiting on c.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It is allowed but not required for the caller to hold c.L</span><br><span class="hljs-comment">// during the call.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast() &#123;<br>c.checker.check()<br>runtime_notifyListNotifyAll(&amp;c.notify)<br>&#125;<br></code></pre></td></tr></table></figure><p>Broadcast唤醒所有等待条件变量c的goroutine，无需锁保护。</p><h3 id="2-3-Signal唤醒一个协程"><a href="#2-3-Signal唤醒一个协程" class="headerlink" title="2.3 Signal唤醒一个协程"></a>2.3 Signal唤醒一个协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Signal wakes one goroutine waiting on c, if there is any.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It is allowed but not required for the caller to hold c.L</span><br><span class="hljs-comment">// during the call.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal() &#123;<br>c.checker.check()<br>runtime_notifyListNotifyOne(&amp;c.notify)<br>&#125;<br></code></pre></td></tr></table></figure><p>Signal只唤醒任意1个等待条件变量c的goroutine，无需锁保护。</p><h3 id="2-4-Wait等待"><a href="#2-4-Wait等待" class="headerlink" title="2.4 Wait等待"></a>2.4 Wait等待</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wait atomically unlocks c.L and suspends execution</span><br><span class="hljs-comment">// of the calling goroutine. After later resuming execution,</span><br><span class="hljs-comment">// Wait locks c.L before returning. Unlike in other systems,</span><br><span class="hljs-comment">// Wait cannot return unless awoken by Broadcast or Signal.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Because c.L is not locked when Wait first resumes, the caller</span><br><span class="hljs-comment">// typically cannot assume that the condition is true when</span><br><span class="hljs-comment">// Wait returns. Instead, the caller should Wait in a loop:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    c.L.Lock()</span><br><span class="hljs-comment">//    for !condition() &#123;</span><br><span class="hljs-comment">//        c.Wait()</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//    ... make use of condition ...</span><br><span class="hljs-comment">//    c.L.Unlock()</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait() &#123;<br>c.checker.check()<br>t := runtime_notifyListAdd(&amp;c.notify)<br>c.L.Unlock()<br>runtime_notifyListWait(&amp;c.notify, t)<br>c.L.Lock()<br>&#125;<br></code></pre></td></tr></table></figure><p>调用Wait会自动释放锁c.L，并挂起调用者所在的goroutine，因此当前协程会阻塞在Wait方法调用的地方。如果其他协程调用了Signal或Broadcast唤醒了该协程，那么Wait方法在结束阻塞时，会重新给c.L加锁，并且继续执行Wait后面的代码。</p><p>对条件的检查，使用了<code>for !condition()</code>而非<code>if</code>，是因为当前协程被唤醒时，条件不一定符合要求，需要再次Wait等待下次被唤醒。需要再次Wait等待下次被唤醒。为了保险起见，使用<code>for</code>能够确保条件符合要求后，再执行后续的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c.L.Lock()<br><span class="hljs-keyword">for</span> !condition() &#123;<br>    c.Wait()<br>&#125;<br>... <span class="hljs-built_in">make</span> use of confition ...<br>c.L.Unlock()<br></code></pre></td></tr></table></figure><h2 id="3-使用实例"><a href="#3-使用实例" class="headerlink" title="3. 使用实例"></a>3. 使用实例</h2><p>接下来实现一个简单的例子，三个协程调用<code>Wait()</code>等待，另一个协程调用<code>Broadcast()</code>唤醒所有等待的协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(name <span class="hljs-type">string</span>, c *sync.Cond)</span></span> &#123;<br>c.L.Lock()<br><span class="hljs-keyword">for</span> !done &#123;<br>c.Wait()<br>&#125;<br>log.Println(name, <span class="hljs-string">&quot;start reading&quot;</span>)<br>c.L.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(name <span class="hljs-type">string</span>, c *sync.Cond)</span></span> &#123;<br>log.Println(name, <span class="hljs-string">&quot;start writing&quot;</span>)<br>time.Sleep(time.Second)<br>c.L.Lock()<br>done = <span class="hljs-literal">true</span> <span class="hljs-comment">// 写完了置为true</span><br>c.L.Unlock()<br>log.Println(name, <span class="hljs-string">&quot;wake all&quot;</span>)<br>c.Broadcast()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)<br><br><span class="hljs-keyword">go</span> read(<span class="hljs-string">&quot;reader1&quot;</span>, cond)<br><span class="hljs-keyword">go</span> read(<span class="hljs-string">&quot;reader2&quot;</span>, cond)<br><span class="hljs-keyword">go</span> read(<span class="hljs-string">&quot;reader3&quot;</span>, cond)<br>write(<span class="hljs-string">&quot;writer&quot;</span>, cond)<br><br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>done</code>互斥锁需要保护的条件变量。</li><li><code>read()</code>调用<code>Wait()</code>等待通知，直到done变为true。</li><li><code>write()</code>象征写入数据，写入完成后，将done置为true，调用<code>Broadcast()</code>通知所有等待的读者。</li><li><code>write()</code>中暂停了1s，一方面时模拟耗时，另一方面时确保前面的3个read协程都执行到<code>Wait()</code>，处于等待状态。main函数最后暂停了3s，确保所有操作执行完毕。</li></ul><p>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231021142734971.png" alt="image-20231021142734971"></p><p>writer写数据花费了1s，同时通知所有等待的协程。</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Euleros01</title>
    <link href="/2023/10/11/Euleros01/"/>
    <url>/2023/10/11/Euleros01/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h2><ol><li><p>编译linux内核并安装。</p></li><li><p>编译hello_world模块，安装模块输出日志。</p></li><li><p>依据hello_world编写hello_student模块，完成指定任务。</p></li><li><p>查询代码中使用的一些宏定义的含义及其用法。</p></li></ol><h2 id="二、-实验过程"><a href="#二、-实验过程" class="headerlink" title="二、 实验过程"></a>二、 实验过程</h2><h3 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h3><p>查找相关资料，解释hello_world.c文件中以下代码的含义和作用。</p><ol><li><p>MODULE_LICENSE</p></li><li><p>module_param</p></li><li><p>MODULE_PARM_DESC</p></li><li><p>module_init</p></li><li><p>module_exit</p></li><li><p>__init</p></li><li><p>__exit</p></li></ol><table><thead><tr><th><strong>宏</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>MODULE_LICENSE</strong></td><td>声明代码采用的开源协议，由于linux内核代码采用GPL协议，而GPL协议要求使用GPL协议的代码同样需要使用GPL协议，即代码开源。被内核接受的有意义的许可证有 GPL，GPL v2，GPL and additional  rights，Dual BSD&#x2F;GPL，Dual MPL&#x2F;GPL，Proprietary。否则，收到内核被污染“kernel tainted”的警告。</td></tr><tr><td><strong>module_param</strong></td><td>typesafe helper for a  module&#x2F;cmdline parameter。提供一种类型安全的命令行参数。  @value: the variable to alter,  and exposed parameter name.  @type: the type of the  parameter. @perm: visibility in sysfs. eg. 0444 for world-readable. 0644 for  root-writable. 这里其实和linux文件权限一致。</td></tr><tr><td><strong>MODULE_PARM_DESC</strong></td><td>使用modinfo时，可以显示出参数的描述。One for each  parameter, describing how to use it. Some files do multiple of these per  line, so can’t just use MODULE_INFO.</td></tr><tr><td><strong>module_init</strong></td><td>模块初始化入口。driver initialization entry  point.</td></tr><tr><td><strong>module_exit</strong></td><td>模块出口。driver exit entry point.</td></tr><tr><td><strong>__init</strong></td><td>kernel macros. 标识函数为初始化函数。在模块装载之后，模块装载就会将初始化函数扔掉。这样可以将该函数占用的内存释放出来。 Detail in __init  &amp; __exit</td></tr><tr><td><strong>__exit</strong></td><td>kernel macros. 标识函数为退出函数，在模块卸载时执行。 Detail in __init  &amp; __exit</td></tr></tbody></table><p>[1]   MODULE_LICENSE &#x2F;&#x2F; 在源码下的include&#x2F;linux&#x2F;module.h文件中</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011152902200.png" alt="image-20231011152902200"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011152910963.png" alt="image-20231011152910963"></p><p>[2]   module_param &#x2F;&#x2F; 在源码下的include&#x2F;linux&#x2F;module.h文件中</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011152915914.png" alt="image-20231011152915914"></p><p>[3]   MODULE_PARAM_DESC</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153018844.png" alt="image-20231011153018844"></p><p>[4]   module_init &amp; module_exit</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153029178.png" alt="image-20231011153029178"></p><p>[5]   __ init&amp; __exit</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153049899.png" alt="image-20231011153049899"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153059162.png" alt="image-20231011153059162"></p><h3 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h3><p>参考hello_world.c和Makefile文件，代码文件区域编写hello_magic_student.c和 Makefile文件，完成以下任务： </p><p>在hello_magic_student.c文件中定义函数 hello_student(…)，该函数包含3个参数：id, name, age，分别代表学号、姓名和年龄，并通过printk输出：</p><p>My name is ${name}, student id is ${id}. I am ${age} years old.  </p><p>在hello_magic_student.c文件中定义函数 my_magic_number(…)，该函数包含2个参数：id和age，分别代表学号和年龄。请你在该函数里将学号的每一位数字相加后再与年龄求和，将求和结果的个位数作为magic_number，并使用printk输出：</p><p>My magic number is ${magic_number}. </p><p>完成hello_magic_student.c文件的编写后，系统会自动保存。参考hello_world模块的Makefile并适当调整，在加载内核时提供学号、姓名和年龄，通过dmesg命令查看printk的输出。 </p><ol><li>第一步 编写hello_magic_student.c</li></ol><ul><li>编写hello_student驱动函数</li></ul><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153132946.png" alt="image-20231011153132946"></p><p>比较简单，直接使用printk将传入的参数输出即可。</p><ul><li>编写my_magic_numbr()驱动函数</li></ul><p>由于需要将学号的每一位相加得到的结果再与年龄求和，最后将所得结果的个位数作为最终结果输出，所以另写一个函数get_magic(char* id, int age)用于得到没有取个位数的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153148892.png"></p><p>strlen用于得到字符串的长度。</p><p>my_magic_number()函数中将所得结果取个位数，然后输出：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153424488.png" alt="image-20231011153424488"></p><ol start="2"><li>第二步编写Makefile</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153213897.png" alt="image-20231011153213897"></p><ol start="3"><li>第三步 运行make run得到结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153222320.png" alt="image-20231011153222320"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153229756.png" alt="image-20231011153229756"></p><p>可以看到结果正确，将57取个位数即为7。</p><h2 id="三、-遇到的问题"><a href="#三、-遇到的问题" class="headerlink" title="三、 遇到的问题"></a>三、 遇到的问题</h2><p>在我将名字中间加入空格的时候会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153304978.png" alt="image-20231011153304978"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153309738.png" alt="image-20231011153309738"></p><p>参考这篇博客得以解决<a href="https://www.javaer101.com/ja/article/14914575.html">https://www.javaer101.com/ja/article/14914575.html</a></p><p>当运行insmod hello_magic_student.ko id&#x3D;”22920202204632” name&#x3D;”Yao huaiyu” age&#x3D;21时，shell会使用引号，并且insmod二进制文件将字符串name&#x3D;Yao huaiyu作为参数。它将原样传递给内核，然后全部传递给内核parse_args函数(在kernel&#x2F;params.c中)，该函数依次调用next_arg以将下一个参数拆分为名称和值。</p><p>改为insmod hello_magic_student.ko id&#x3D;”22920202204632” name&#x3D;’”Yao huaiyu”’ age&#x3D;21</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153319712.png" alt="image-20231011153319712"></p><p>注意这里在双引号外面多加了单引号。</p><p>再次运行make run</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231011153537231.png" alt="image-20231011153537231"></p><p>可以看到，程序正常执行。</p><p>还有一个小问题就是，在右边的代码区写，pull下来之后会有问题，于是就直接在图形化终端里写了。</p><h2 id="四、-实验总结"><a href="#四、-实验总结" class="headerlink" title="四、 实验总结"></a>四、 实验总结</h2><p>在本次实验中，我学习并掌握了如何安装操作系统，编译操作系统内核以及了解了内核模块编程。这些知识对于我今后的学习和工作都将非常有用。</p><p>在实验中，我首先学习了如何安装欧拉操作系统。通过按照实验指导的步骤，我成功地安装了欧拉系统。</p><p>接着，我学习了如何编译操作系统内核。这是一个比较复杂的过程，需要仔细地阅读指导书上的步骤并且耐心地等待编译完成。在这个过程中，我还学习了一些常用的命令行工具。</p><p>最后，我了解了内核模块编程。通过实验指导以及网络资源上的介绍，我对内核模块有了更深入的了解。我知道了什么是内核模块、为什么需要内核模块以及如何编写内核模块。</p><p>总的来说，这次实验让我受益匪浅。通过亲手实践，我不仅掌握了一些实用的技能，而且对计算机系统有了更深入的了解。我相信这些知识会对我今后的学习和工作都非常有帮助。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Euleros</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试手撕</title>
    <link href="/2023/10/09/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95/"/>
    <url>/2023/10/09/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.nowcoder.com/exam/oj">OJ网站</a></p></blockquote><h2 id="第一部分：链表"><a href="#第一部分：链表" class="headerlink" title="第一部分：链表"></a>第一部分：链表</h2><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h3><h4 id="方法1：栈"><a href="#方法1：栈" class="headerlink" title="方法1：栈"></a>方法1：栈</h4><p>最简单的方法就是用栈，把所有链表上的节点都放进栈里，然后再一个一个取出，重新链成一个新的链。最后要注意，反转的最后一个节点是最开始的头节点，需要将它的next置空，不然会形成环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;ListNode*&gt; stk;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            stk.<span class="hljs-built_in">push</span>(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* node = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>        ListNode* ret = node;<br>        <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            node-&gt;next = t;<br>            node = node-&gt;next;<br>        &#125;<br>        node-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 这里注意要将开头的next置空</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：用一个pre记录上一个节点，用一个ne记录写一个节点，一次遍历"><a href="#方法2：用一个pre记录上一个节点，用一个ne记录写一个节点，一次遍历" class="headerlink" title="方法2：用一个pre记录上一个节点，用一个ne记录写一个节点，一次遍历"></a>方法2：用一个pre记录上一个节点，用一个ne记录写一个节点，一次遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-链表内指定区间反转"><a href="#2-链表内指定区间反转" class="headerlink" title="2.  链表内指定区间反转"></a>2.  链表内指定区间反转</h3><p>要求时间复杂度O(1)，空间复杂度O(n)。</p><h4 id="方法1：先将要反转的部分按照“反转链表”的操作来，然后再将剩余的部分连上，需要两次遍历"><a href="#方法1：先将要反转的部分按照“反转链表”的操作来，然后再将剩余的部分连上，需要两次遍历" class="headerlink" title="方法1：先将要反转的部分按照“反转链表”的操作来，然后再将剩余的部分连上，需要两次遍历"></a>方法1：先将要反转的部分按照“反转链表”的操作来，然后再将剩余的部分连上，需要两次遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param m int整型 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseLinkedList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">// 设置虚拟头节点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy;<br>        <span class="hljs-comment">// 1. pre走m - 1步走到m的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        ListNode* right = pre;<br>        <span class="hljs-comment">// 2. right走n - m + 1步走到right节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m + <span class="hljs-number">1</span>; i++) &#123;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 3. 截取出一个子链表</span><br>        ListNode* left = pre-&gt;next;<br>        ListNode* cur = right-&gt;next;<br><br>        <span class="hljs-comment">// 4. 切断链接</span><br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        right-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 5. 反转局部链表</span><br>        <span class="hljs-built_in">reverseLinkedList</span>(left);<br><br>        <span class="hljs-comment">// 6. 接回原来的链表</span><br>        pre-&gt;next = right;<br>        left-&gt;next = cur;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为是链表，所以我们将闯进去的指针的next改掉就行了，也不用返回值取得head。</p><h3 id="3-链表中的节点每k个一组翻转"><a href="#3-链表中的节点每k个一组翻转" class="headerlink" title="3. 链表中的节点每k个一组翻转"></a>3. 链表中的节点每k个一组翻转</h3><h4 id="方法1：递归"><a href="#方法1：递归" class="headerlink" title="方法1：递归"></a>方法1：递归</h4><p>从最后一个分组开始翻转，得到最后一个分组的链表首部（也就是原本链表的最后一个），然后将这个链表首部直接连接在倒数第二个分组翻转后的尾（也就是原本倒数第二个分组的头部）后面。</p><p>从后往前做：使用递归的方法。假如一共有n组需要翻转，此时后面的n - 1组已经翻转完了，那么此时我们只需要将第一组翻转后的尾部接上已经翻转好的n - 1组即可。那么这n - 1组就是一个子问题。</p><p>看看递归的三段式模板：</p><ul><li>终止条件：当进行到最后一个分组的时候，即不足k次遍历到链表尾部，就将剩余的部分直接返回</li><li>返回值：每一级要返回的是翻转后的这一分组的头，以及连接好它后面所有翻转好的分组链表</li><li>本级任务：对于本级，先遍历k次，找到下一个的开头，然后依次翻转，最开始的头已经变成了本组的结尾，然后将本组的结尾连接上后面已经解决的子问题，也就是后面分组的头</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* tail = head;<br>        <span class="hljs-comment">// 遍历k次到尾部</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">// 如果不足k次到了链表尾部 直接返回 不翻转</span><br>            <span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 翻转时需要的前序和当前节点</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur != tail) &#123;<br>            ListNode* cur_next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = cur_next;<br>        &#125;<br>        head-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(tail, k);<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意，使用反转链表的板子要改一下，是<code>cur != tail</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>ListNode* cur = head;<br><span class="hljs-keyword">while</span> (cur != tail) &#123;<br>    ListNode* cur_next = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = cur_next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-合并两个已排序的链表"><a href="#4-合并两个已排序的链表" class="headerlink" title="4. 合并两个已排序的链表"></a>4. 合并两个已排序的链表</h3><p>比较简单，直接上代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead1 ListNode类 </span><br><span class="hljs-comment">     * @param pHead2 ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (list1) &#123;<br>            cur-&gt;next = list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = list2;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-合并k个已排序的链表"><a href="#5-合并k个已排序的链表" class="headerlink" title="5.  合并k个已排序的链表"></a>5.  合并k个已排序的链表</h3><h4 id="题解：分治"><a href="#题解：分治" class="headerlink" title="题解：分治"></a>题解：分治</h4><p>基于[合并两个已排序的链表](#4. 合并两个排序的链表)，我们可以将k个已排序的链表两两分组，两两合并，每两个合并成一个再将合并好的接着两两合并。</p><p>步骤：</p><ul><li>链表总个数为n，每次划分从中间开始，划分成两半，得到左边n &#x2F; 2个链表和右边n &#x2F; 2个链表</li><li>继续不断将两边的链表划分，直到只有一个链表</li><li>将相邻的两个链表按照[合并两个已排序的链表](#4. 合并两个排序的链表)合并，合并好的部分继续向上合并，直到最终合并成一个新的链表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param lists ListNode类vector </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val) &#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (list1) &#123;<br>            cur-&gt;next = list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = list2;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">divideMerge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == right) &#123;<br>            <span class="hljs-keyword">return</span> lists[left];<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Merge</span>(<span class="hljs-built_in">divideMerge</span>(lists, left, mid), <span class="hljs-built_in">divideMerge</span>(lists, mid + <span class="hljs-number">1</span>, right));<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">divideMerge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-判断链表中是否有环"><a href="#6-判断链表中是否有环" class="headerlink" title="6. 判断链表中是否有环"></a>6. 判断链表中是否有环</h3><h4 id="方法1：用set存某个节点是否已经遍历过就行了"><a href="#方法1：用set存某个节点是否已经遍历过就行了" class="headerlink" title="方法1：用set存某个节点是否已经遍历过就行了"></a>方法1：用set存某个节点是否已经遍历过就行了</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">find</span>(head) != st.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">insert</span>(head);<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：双指针法-快慢指针"><a href="#方法2：双指针法-快慢指针" class="headerlink" title="方法2：双指针法 快慢指针"></a>方法2：双指针法 快慢指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* slow = head, *fast = head;<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span> (fast-&gt;next) &#123;<br>                fast = fast-&gt;next-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-链表中环的入口节点"><a href="#7-链表中环的入口节点" class="headerlink" title="7. 链表中环的入口节点"></a>7. 链表中环的入口节点</h3><h4 id="题解：和-判断链表中是否有环-6-判断链表中是否有环-类似，直接上代码"><a href="#题解：和-判断链表中是否有环-6-判断链表中是否有环-类似，直接上代码" class="headerlink" title="题解：和[判断链表中是否有环](#6. 判断链表中是否有环)类似，直接上代码"></a>题解：和[判断链表中是否有环](#6. 判断链表中是否有环)类似，直接上代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span> (pHead != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">find</span>(pHead) != st.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> pHead;<br>            &#125;<br>            st.<span class="hljs-built_in">insert</span>(pHead);<br>            pHead = pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-链表中倒数最后k个结点"><a href="#8-链表中倒数最后k个结点" class="headerlink" title="8. 链表中倒数最后k个结点"></a>8. 链表中倒数最后k个结点</h3><h4 id="方法1：两次遍历"><a href="#方法1：两次遍历" class="headerlink" title="方法1：两次遍历"></a>方法1：两次遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode* node = pHead;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            n++;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> t = n - k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br>            pHead = pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：快慢指针"><a href="#方法2：快慢指针" class="headerlink" title="方法2：快慢指针"></a>方法2：快慢指针</h4><p>第一个指针先移动k步，然后第二个指针再从头开始，这个时候这两个指针同时移动，当第一个指针到链表的末尾的时候，返回第二个指针即可</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/B27699765EEF6CA0E75AF0D1A4B9BCAC" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = pHead;<br>        ListNode* fast = pHead;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-删除链表的倒数第n个节点"><a href="#9-删除链表的倒数第n个节点" class="headerlink" title="9. 删除链表的倒数第n个节点"></a>9. 删除链表的倒数第n个节点</h3><h4 id="题解：首先找到链表的倒数第n个节点，然后将它删除就行了"><a href="#题解：首先找到链表的倒数第n个节点，然后将它删除就行了" class="headerlink" title="题解：首先找到链表的倒数第n个节点，然后将它删除就行了"></a>题解：首先找到链表的倒数第n个节点，然后将它删除就行了</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        &#125;<br>        ListNode* pre = slow;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            fast = fast-&gt;next;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>        &#125;<br>        pre-&gt;next = slow-&gt;next;<br>        <span class="hljs-built_in">delete</span>(slow);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要注意一点，当n恰好等于链表的长度时，删除的是第一个节点，这样我们直接返回第二个节点就行了。</p><h3 id="10-两个链表的第一个公共节点"><a href="#10-两个链表的第一个公共节点" class="headerlink" title="10. 两个链表的第一个公共节点"></a>10. 两个链表的第一个公共节点</h3><h4 id="题解：哈希表走天下"><a href="#题解：哈希表走天下" class="headerlink" title="题解：哈希表走天下"></a>题解：哈希表走天下</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        set&lt;ListNode*&gt; st;<br><span class="hljs-keyword">while</span> (pHead1 != <span class="hljs-literal">nullptr</span>) &#123;<br>st.<span class="hljs-built_in">insert</span>(pHead1);<br>pHead1 = pHead1-&gt;next;<br>&#125;<br><span class="hljs-keyword">while</span> (pHead2 != <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">find</span>(pHead2) != st.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-keyword">return</span> pHead2;<br>&#125;<br>pHead2 = pHead2-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11-链表相加-二"><a href="#11-链表相加-二" class="headerlink" title="11. 链表相加(二)"></a>11. 链表相加(二)</h3><h4 id="题解：先反转两个链表，然后按照整数加法相加就行"><a href="#题解：先反转两个链表，然后按照整数加法相加就行" class="headerlink" title="题解：先反转两个链表，然后按照整数加法相加就行"></a>题解：先反转两个链表，然后按照整数加法相加就行</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head1 ListNode类 </span><br><span class="hljs-comment">     * @param head2 ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* cur_next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = cur_next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">addInList</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        head1 = <span class="hljs-built_in">reverseList</span>(head1);<br>        head2 = <span class="hljs-built_in">reverseList</span>(head2);<br>        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* nHead = head;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head1 || head2) &#123;<br>            <span class="hljs-type">int</span> val = tmp;<br>            <span class="hljs-keyword">if</span> (head1 != <span class="hljs-literal">nullptr</span>) &#123;<br>                val += head1-&gt;val;<br>                head1 = head1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (head2 != <span class="hljs-literal">nullptr</span>) &#123;<br>                val += head2-&gt;val;<br>                head2 = head2-&gt;next;<br>            &#125;<br>            tmp = val / <span class="hljs-number">10</span>;<br>            nHead-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val % <span class="hljs-number">10</span>);<br>            nHead = nHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmp) &#123;<br>            nHead-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="12-单链表的排序"><a href="#12-单链表的排序" class="headerlink" title="12. 单链表的排序"></a>12. 单链表的排序</h3><h4 id="题解：归并排序"><a href="#题解：归并排序" class="headerlink" title="题解：归并排序"></a>题解：归并排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 the head node</span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortInList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (fast-&gt;next) &#123;<br>                fast = fast-&gt;next-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            slow = slow-&gt;next;<br>        &#125;<br>        ListNode* tmp = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        ListNode* left = <span class="hljs-built_in">sortInList</span>(head);<br>        ListNode* right = <span class="hljs-built_in">sortInList</span>(tmp);<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* node = dummy;<br>        <span class="hljs-keyword">while</span> (left &amp;&amp; right) &#123;<br>            <span class="hljs-keyword">if</span> (left-&gt;val &lt; right-&gt;val) &#123;<br>                node-&gt;next = left;<br>                left = left-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;next = right;<br>                right = right-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        node-&gt;next = left == <span class="hljs-literal">nullptr</span> ? right : left;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="13-判断一个链表是否为回文结构"><a href="#13-判断一个链表是否为回文结构" class="headerlink" title="13. 判断一个链表是否为回文结构"></a>13. 判断一个链表是否为回文结构</h3><h4 id="题解：快慢指针-找到中间的那个-然后把后面的都反转-然后比较"><a href="#题解：快慢指针-找到中间的那个-然后把后面的都反转-然后比较" class="headerlink" title="题解：快慢指针 找到中间的那个 然后把后面的都反转 然后比较"></a>题解：快慢指针 找到中间的那个 然后把后面的都反转 然后比较</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 the head</span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* cur_next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = cur_next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPail</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (fast-&gt;next) &#123;<br>                fast = fast-&gt;next-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            slow = slow-&gt;next;<br>        &#125;<br>        ListNode* right = <span class="hljs-built_in">reverseList</span>(slow);<br>        <span class="hljs-keyword">while</span> (head != slow) &#123;<br>            <span class="hljs-keyword">if</span> (head-&gt;val != right-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            head = head-&gt;next;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="14-链表的奇偶重排"><a href="#14-链表的奇偶重排" class="headerlink" title="14. 链表的奇偶重排"></a>14. 链表的奇偶重排</h3><h4 id="题解：odd-next-even-next，-even-next-odd-next"><a href="#题解：odd-next-even-next，-even-next-odd-next" class="headerlink" title="题解：odd-&gt;next = even-&gt;next， even-&gt;next = odd-&gt;next"></a>题解：<code>odd-&gt;next = even-&gt;next</code>， <code>even-&gt;next = odd-&gt;next</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* even = head-&gt;next;<br>        ListNode* tmp = even;<br>        ListNode* odd = head;<br>        ListNode* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span> (even &amp;&amp; odd) &#123;<br>            t = odd;<br>            odd-&gt;next = even-&gt;next;<br>            odd = odd-&gt;next;<br>            <span class="hljs-keyword">if</span> (odd) &#123;<br>                even-&gt;next = odd-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (even-&gt;next) &#123;<br>                even = even-&gt;next;<br>            &#125;<br>        &#125;<br>        t-&gt;next = tmp;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="15-删除有序链表中重复的元素-I"><a href="#15-删除有序链表中重复的元素-I" class="headerlink" title="15. 删除有序链表中重复的元素-I"></a>15. 删除有序链表中重复的元素-I</h3><h4 id="题解：比较简单-无题解"><a href="#题解：比较简单-无题解" class="headerlink" title="题解：比较简单 无题解"></a>题解：比较简单 无题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* p = head;<br>        ListNode* q = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; q != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;val == q-&gt;val) &#123;<br>                q = q-&gt;next;<br>            &#125;<br>            p-&gt;next = q;<br>            p = q;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="16-删除有序链表中重复的元素-II"><a href="#16-删除有序链表中重复的元素-II" class="headerlink" title="16. 删除有序链表中重复的元素-II"></a>16. 删除有序链表中重复的元素-II</h3><p>只保留原链表中只出现一次的元素</p><p>双指针判断是不是只出现一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> *ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;endian.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">auto</span>* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span>* node = dummy;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            ListNode* q = p;<br>            <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;val == q-&gt;val) &#123;<br>                cnt++;<br>                q = q-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) &#123;<br>                node-&gt;next = p;<br>                node = node-&gt;next;<br>            &#125;<br>            node-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            p = q;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="附加-LeetCode143-重排链表"><a href="#附加-LeetCode143-重排链表" class="headerlink" title="附加 LeetCode143 重排链表"></a>附加 LeetCode143 重排链表</h3><ul><li>找到原链表的中点：用快慢指针的方法</li><li>将原链表的右半端反转</li><li>将原链表的两端合并</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        ListNode* mid = <span class="hljs-built_in">middleNode</span>(head);<br>        ListNode* l1 = head;<br>        ListNode* l2 = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        l2 = <span class="hljs-built_in">reverseList</span>(l2);<br>        <span class="hljs-built_in">mergeList</span>(l1, l2);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br><br>        <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* cur = head;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* cur_next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = cur_next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* l1_next;<br>        ListNode* l2_next;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            l1_next = l1-&gt;next;<br>            l2_next = l2-&gt;next;<br><br>            l1-&gt;next = l2;<br>            l1 = l1_next;<br><br>            l2-&gt;next = l1;<br>            l2 = l2_next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第二部分-二分查找-排序"><a href="#第二部分-二分查找-排序" class="headerlink" title="第二部分 二分查找&#x2F;排序"></a>第二部分 二分查找&#x2F;排序</h2><h3 id="17-二分查找-I"><a href="#17-二分查找-I" class="headerlink" title="17. 二分查找-I"></a>17. 二分查找-I</h3><p>板子题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @param target int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (nums[l] == target) &#123;<br>            ret = l;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="18-二维数组中的查找"><a href="#18-二维数组中的查找" class="headerlink" title="18. 二维数组中的查找"></a>18. 二维数组中的查找</h3><h4 id="方法1：线性搜索"><a href="#方法1：线性搜索" class="headerlink" title="方法1：线性搜索"></a>方法1：线性搜索</h4><p>主要思路：</p><ul><li>由于每行每列都是递增的，可以利用下面的性质，对于一列上的数，它上面的数都比当前的数要小；对于一行上的数，它右边的数都比当前的数要大</li><li>所以可以从左下角开始比较，如果当前数字大于target，那就向上移动一格；小于就向右移动一格；相等就返回true。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param target int整型 </span><br><span class="hljs-comment">     * @param array int整型vector&lt;vector&lt;&gt;&gt; </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (array.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> row = array.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 行数</span><br>        <span class="hljs-type">int</span> col = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 列数</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = row - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (x &lt; col &amp;&amp; y &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> tmp = array[y][x];<br>            <span class="hljs-keyword">if</span> (tmp &gt; target) &#123;<br>                y--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &lt; target) &#123;<br>                x++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法2：双二分查找"><a href="#方法2：双二分查找" class="headerlink" title="方法2：双二分查找"></a>方法2：双二分查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">double_binary</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; arr,<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x1 == x2 || y1 == y2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> xmid = (x1 + x2)/<span class="hljs-number">2</span>, ymid = (y1 + y2)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> num = arr[xmid][ymid];<br>        <span class="hljs-keyword">if</span>(num == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(num &gt; target)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-built_in">double_binary</span>(arr, x1, xmid, y1, y2, target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-built_in">double_binary</span>(arr,xmid,x2,y1,ymid,target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">double_binary</span>(arr, xmid+<span class="hljs-number">1</span>, x2, y1, y2, target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">double_binary</span>(arr, x1, xmid+<span class="hljs-number">1</span>, ymid+<span class="hljs-number">1</span>, y2, target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double_binary</span>(array, <span class="hljs-number">0</span>, array.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), target);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="19-寻找峰值"><a href="#19-寻找峰值" class="headerlink" title="19. 寻找峰值"></a>19. 寻找峰值</h3><ul><li>step 1：二分查找首先从数组首尾开始，每次取中间值，直到首尾相遇。</li><li>step 2：如果中间值的元素大于它右边的元素，说明往右是向下，我们不一定会遇到波峰，但是那就往左收缩区间。</li><li>step 3：如果中间值大于右边的元素，说明此时往右是向上，向上一定能有波峰，那我们往右收缩区间。</li><li>step 4：最后区间收尾相遇的点一定就是波峰。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ios&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l &gt;= nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> l;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l] &gt; nums[r] ? l : r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="20-数组中的逆序对"><a href="#20-数组中的逆序对" class="headerlink" title="20. 数组中的逆序对"></a>20. 数组中的逆序对</h3><h4 id="题解：归并排序-1"><a href="#题解：归并排序-1" class="headerlink" title="题解：归并排序"></a>题解：归并排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">mergeSort</span>(nums, l, mid) + <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(<span class="hljs-number">100010</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) &#123;<br>                tmp[k++] = nums[i++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp[k++] = nums[j++];<br>                ret = (ret + mid - i + <span class="hljs-number">1</span>) % <span class="hljs-number">1000000007</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>            tmp[k++] = nums[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt;= r) &#123;<br>            tmp[k++] = nums[j++];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>            nums[i] = tmp[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret % <span class="hljs-number">1000000007</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="21-旋转数组的最小数字"><a href="#21-旋转数组的最小数字" class="headerlink" title="21. 旋转数组的最小数字"></a>21. 旋转数组的最小数字</h3><p>简单题，直接上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>                ret = nums[i + <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>            ret = nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="22-比较版本号"><a href="#22-比较版本号" class="headerlink" title="22. 比较版本号"></a>22. 比较版本号</h3><p>阿里淘天一面的手撕题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 比较版本号</span><br><span class="hljs-comment">     * @param version1 string字符串 </span><br><span class="hljs-comment">     * @param version2 string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            string ss = s.<span class="hljs-built_in">substr</span>(i, j);<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">atoi</span>(ss.<span class="hljs-built_in">c_str</span>());<br>            cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            ret.<span class="hljs-built_in">push_back</span>(t);<br>            i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = v1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (v1[i] &lt; v2[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1[i] &gt; v2[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; v1 = <span class="hljs-built_in">get</span>(version1);<br>        vector&lt;<span class="hljs-type">int</span>&gt; v2 = <span class="hljs-built_in">get</span>(version2);<br>        <span class="hljs-type">int</span> m = v1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = v2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m &lt; n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &lt; n; i++) &#123;<br>                v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; m; i++) &#123;<br>                v2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(v1, v2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="附加一题-拓扑排序"><a href="#附加一题-拓扑排序" class="headerlink" title="附加一题 拓扑排序"></a>附加一题 拓扑排序</h3><p>注意不要数组越界</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ind</span><span class="hljs-params">(N, <span class="hljs-number">0</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123; <span class="hljs-comment">// m 条边</span><br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        ind[y]++; <span class="hljs-comment">// 入度</span><br>        g[x].<span class="hljs-built_in">push_back</span>(y);<br>    &#125;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (ind[i] == <span class="hljs-number">0</span>) &#123;<br>            q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>    &#125;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(t);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v : g[t]) &#123;<br>            ind[v]--;<br>            <span class="hljs-keyword">if</span> (ind[v] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() == n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : res) &#123;<br>            cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三部分-二叉树"><a href="#第三部分-二叉树" class="headerlink" title="第三部分 二叉树"></a>第三部分 二叉树</h2><h3 id="23-二叉树的前序遍历"><a href="#23-二叉树的前序遍历" class="headerlink" title="23. 二叉树的前序遍历"></a>23. 二叉树的前序遍历</h3><h4 id="方法1：递归-1"><a href="#方法1：递归-1" class="headerlink" title="方法1：递归"></a>方法1：递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; res, TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><br>        <span class="hljs-built_in">preorder</span>(res, root-&gt;left);<br>        <span class="hljs-built_in">preorder</span>(res, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preorder</span>(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="24-二叉树的中序遍历"><a href="#24-二叉树的中序遍历" class="headerlink" title="24. 二叉树的中序遍历"></a>24. 二叉树的中序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; res, TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(res, root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(res, root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorder</span>(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="25-二叉树的后序遍历"><a href="#25-二叉树的后序遍历" class="headerlink" title="25. 二叉树的后序遍历"></a>25. 二叉树的后序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; res, TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">postorder</span>(res, root-&gt;left);<br>        <span class="hljs-built_in">postorder</span>(res, root-&gt;right);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">postorder</span>(res, root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="26-求二叉树的层序遍历"><a href="#26-求二叉树的层序遍历" class="headerlink" title="26. 求二叉树的层序遍历"></a>26. 求二叉树的层序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        TreeNode* cur = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; row;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                row.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="27-按之字形顺序打印二叉树"><a href="#27-按之字形顺序打印二叉树" class="headerlink" title="27. 按之字形顺序打印二叉树"></a>27. 按之字形顺序打印二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; row;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                TreeNode* tmp = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    row.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    row.<span class="hljs-built_in">insert</span>(row.<span class="hljs-built_in">begin</span>(), tmp-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>                &#125;<br>            &#125;<br>            level++;<br>            <span class="hljs-keyword">if</span> (!row.<span class="hljs-built_in">empty</span>()) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(row);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="28-二叉树的最大深度"><a href="#28-二叉树的最大深度" class="headerlink" title="28. 二叉树的最大深度"></a>28. 二叉树的最大深度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="29-二叉树中和为某一值的路径-一"><a href="#29-二叉树中和为某一值的路径-一" class="headerlink" title="29. 二叉树中和为某一值的路径(一)"></a>29. 二叉树中和为某一值的路径(一)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> *   public TreeNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root TreeNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sum int整型 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span> <span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; sum - root.val == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param sum int整型 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span> &amp;&amp; sum - root-&gt;val == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="30-二叉搜索树与双向链表-不是很理解"><a href="#30-二叉搜索树与双向链表-不是很理解" class="headerlink" title="30. 二叉搜索树与双向链表   不是很理解"></a>30. 二叉搜索树与双向链表   不是很理解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>TreeNode* head = <span class="hljs-literal">nullptr</span>;<br>TreeNode* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRootOfTree == <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-built_in">Convert</span>(pRootOfTree-&gt;left);<br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) &#123;<br>head = pRootOfTree;<br>pre = pRootOfTree;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pre-&gt;right = pRootOfTree;<br>pRootOfTree-&gt;left = pre;<br>pre = pRootOfTree;<br>&#125;<br><span class="hljs-built_in">Convert</span>(pRootOfTree-&gt;right);<br><span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="31-对称的二叉树"><a href="#31-对称的二叉树" class="headerlink" title="31. 对称的二叉树"></a>31. 对称的二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursion</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">nullptr</span> &amp;&amp; root2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">nullptr</span> || root2 == <span class="hljs-literal">nullptr</span> || root1-&gt;val != root2-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursion</span>(root1-&gt;left, root2-&gt;right) &amp;&amp; <span class="hljs-built_in">recursion</span>(root1-&gt;right, root2-&gt;left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursion</span>(pRoot, pRoot);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="32-合并二叉树"><a href="#32-合并二叉树" class="headerlink" title="32. 合并二叉树"></a>32. 合并二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param t1 TreeNode类 </span><br><span class="hljs-comment">     * @param t2 TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        TreeNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);<br>        head-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>        head-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="33-二叉树的镜像"><a href="#33-二叉树的镜像" class="headerlink" title="33. 二叉树的镜像"></a>33. 二叉树的镜像</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode* left = <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>        TreeNode* right = <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>        pRoot-&gt;left = right;<br>        pRoot-&gt;right = left;<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="34-判断是不是二叉搜索树"><a href="#34-判断是不是二叉搜索树" class="headerlink" title="34. 判断是不是二叉搜索树"></a>34. 判断是不是二叉搜索树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> pre = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidBST</span>(root-&gt;left)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= pre) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pre = root-&gt;val;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidBST</span>(root-&gt;right)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="35-判断是不是完全二叉树"><a href="#35-判断是不是完全二叉树" class="headerlink" title="35. 判断是不是完全二叉树"></a>35. 判断是不是完全二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (flag) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="36-判断是不是二叉平衡树"><a href="#36-判断是不是二叉平衡树" class="headerlink" title="36. 判断是不是二叉平衡树"></a>36. 判断是不是二叉平衡树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pRoot TreeNode类 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> depl = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (depl == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> depr = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (depr == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <br>        <span class="hljs-type">int</span> sub = <span class="hljs-built_in">abs</span>(depl - depr);<br>        <span class="hljs-keyword">if</span> (sub &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(depl, depr) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(pRoot) != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="37-二叉搜索树的最近公共祖先"><a href="#37-二叉搜索树的最近公共祖先" class="headerlink" title="37. 二叉搜索树的最近公共祖先"></a>37. 二叉搜索树的最近公共祖先</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param p int整型 </span><br><span class="hljs-comment">     * @param q int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_path</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        TreeNode* node = root;<br>        <span class="hljs-keyword">while</span> (node-&gt;val != target) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (target &lt; node-&gt;val) &#123;<br>                node = node-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node-&gt;right;<br>            &#125;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path_p = <span class="hljs-built_in">get_path</span>(root, p);<br>        vector&lt;<span class="hljs-type">int</span>&gt; path_q = <span class="hljs-built_in">get_path</span>(root, q);<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path_p.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; path_q.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (path_p[i] == path_q[i]) &#123;<br>                res = path_p[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="38-在二叉树中找到两个节点的最近公共祖先"><a href="#38-在二叉树中找到两个节点的最近公共祖先" class="headerlink" title="38. 在二叉树中找到两个节点的最近公共祖先"></a>38. 在二叉树中找到两个节点的最近公共祖先</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @param o1 int整型 </span><br><span class="hljs-comment">     * @param o2 int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-type">int</span> o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (flag || root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val == o) &#123;<br>            flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, path, o);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, path, o);<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path1, path2;<br>        <span class="hljs-built_in">dfs</span>(root, path1, o1);<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">dfs</span>(root, path2, o2);<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path1.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; path2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (path1[i] == path2[i]) &#123;<br>                res = path1[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="39-序列化二叉树"><a href="#39-序列化二叉树" class="headerlink" title="39. 序列化二叉树"></a>39. 序列化二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stringstream ss;<br>        <span class="hljs-built_in">dfs_s</span>(ss, root);<br>        string str = ss.<span class="hljs-built_in">str</span>();<br>        <span class="hljs-type">char</span>* ans = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[str.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(ans, str.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(stringstream&amp; ss, TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            ss &lt;&lt; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MAX + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ss &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-built_in">dfs_s</span>(ss, root-&gt;left);<br>            <span class="hljs-built_in">dfs_s</span>(ss, root-&gt;right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span>* data)</span> </span>&#123;<br>        <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(ss);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs_d</span><span class="hljs-params">(stringstream&amp; ss)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> val;<br>        ss &gt;&gt; val;<br>        <span class="hljs-keyword">if</span> (val &gt; INT_MAX) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        node-&gt;left = <span class="hljs-built_in">dfs_d</span>(ss);<br>        node-&gt;right = <span class="hljs-built_in">dfs_d</span>(ss);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="40-重建二叉树"><a href="#40-重建二叉树" class="headerlink" title="40. 重建二叉树"></a>40. 重建二叉树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> *TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param preOrder int整型vector </span><br><span class="hljs-comment">     * @param vinOrder int整型vector </span><br><span class="hljs-comment">     * @return TreeNode类</span><br><span class="hljs-comment">     */</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos; <span class="hljs-comment">// 记录每个值在中序遍历中的位置</span><br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vinOrder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = vinOrder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            pos[vinOrder[i]] = i; <span class="hljs-comment">// 记录每个数在中序遍历中的位置</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preOrder, vinOrder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, vector&lt;<span class="hljs-type">int</span>&gt;&amp; in, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[pl]);<br>        <span class="hljs-type">int</span> k = pos[pre[pl]] - il; <span class="hljs-comment">// 找到根节点的位置 k</span><br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">dfs</span>(pre, in, pl + <span class="hljs-number">1</span>, pl + k, il, il + k - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">dfs</span>(pre, in, pl + k + <span class="hljs-number">1</span>, pr, il + k + <span class="hljs-number">1</span>, ir);<br>        root-&gt;left = left;<br>        root-&gt;right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="41-输出二叉树的右视图"><a href="#41-输出二叉树的右视图" class="headerlink" title="41. 输出二叉树的右视图"></a>41. 输出二叉树的右视图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 求二叉树的右视图</span><br><span class="hljs-comment">     * @param preOrder int整型vector 先序遍历</span><br><span class="hljs-comment">     * @param inOrder int整型vector 中序遍历</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preOrder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inOrder)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (preOrder.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span> n = preOrder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            pos[inOrder[i]] = i;<br>        &#125;<br>        TreeNode* root = <span class="hljs-built_in">buildTree</span>(preOrder, inOrder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightSideView</span>(root);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, vector&lt;<span class="hljs-type">int</span>&gt;&amp; in, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[pl]);<br>        <span class="hljs-type">int</span> k = pos[pre[pl]] - il; <span class="hljs-comment">// 找到根节点的位置 k</span><br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">buildTree</span>(pre, in, pl + <span class="hljs-number">1</span>, pl + k, il, il + k - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">buildTree</span>(pre, in, pl + k + <span class="hljs-number">1</span>, pr, il + k + <span class="hljs-number">1</span>, ir);<br>        root-&gt;left = left;<br>        root-&gt;right = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> max_depth = <span class="hljs-number">-1</span>;<br>        stack&lt;TreeNode*&gt; nodes;<br>        stack&lt;<span class="hljs-type">int</span>&gt; depths;<br>        nodes.<span class="hljs-built_in">push</span>(root);<br>        depths.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!nodes.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* cur = nodes.<span class="hljs-built_in">top</span>();<br>            nodes.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> depth = depths.<span class="hljs-built_in">top</span>();<br>            depths.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>                max_depth = <span class="hljs-built_in">max</span>(max_depth, depth);<br>                <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">find</span>(depth) == mp.<span class="hljs-built_in">end</span>()) &#123;<br>                    mp[depth] = cur-&gt;val;<br>                &#125;<br>                nodes.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                nodes.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                depths.<span class="hljs-built_in">push</span>(depth + <span class="hljs-number">1</span>);<br>                depths.<span class="hljs-built_in">push</span>(depth + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_depth; i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(mp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><h3 id="实现思路：递归"><a href="#实现思路：递归" class="headerlink" title="实现思路：递归"></a>实现思路：递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxSum = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;left), <span class="hljs-number">0</span>); <span class="hljs-comment">// 只有在最大贡献值大于0时，才会选取对应节点</span><br>        <span class="hljs-type">int</span> rightGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;right), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> temp = leftGain + node-&gt;val + rightGain;<br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, temp);<br>        <span class="hljs-keyword">return</span> node-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightGain);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">maxGain</span>(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第四部分-堆-栈-队列"><a href="#第四部分-堆-栈-队列" class="headerlink" title="第四部分 堆&#x2F;栈&#x2F;队列"></a>第四部分 堆&#x2F;栈&#x2F;队列</h2><h3 id="42-用两个栈实现队列"><a href="#42-用两个栈实现队列" class="headerlink" title="42. 用两个栈实现队列"></a>42. 用两个栈实现队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack1.<span class="hljs-built_in">empty</span>()) &#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> node = stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="43-包含min函数的栈"><a href="#43-包含min函数的栈" class="headerlink" title="43. 包含min函数的栈"></a>43. 包含min函数的栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;value, value&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (value &lt; st.<span class="hljs-built_in">top</span>().second) &#123;<br>                st.<span class="hljs-built_in">push</span>(&#123;value, value&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(&#123;value, st.<span class="hljs-built_in">top</span>().second&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="44-有效括号序列"><a href="#44-有效括号序列" class="headerlink" title="44. 有效括号序列"></a>44. 有效括号序列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">switch</span> (s[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>                stk.<span class="hljs-built_in">push</span>(s[i]);<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="45-滑动窗口的最大值"><a href="#45-滑动窗口的最大值" class="headerlink" title="45. 滑动窗口的最大值"></a>45. 滑动窗口的最大值</h3><p>单调队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param num int整型vector </span><br><span class="hljs-comment">     * @param size int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        list&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; i - size + <span class="hljs-number">1</span> &gt; q.<span class="hljs-built_in">front</span>()) &#123;<br>                q.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() &amp;&amp; num[q.<span class="hljs-built_in">back</span>()] &lt;= num[i]) &#123;<br>                q.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            q.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (i &gt;= size - <span class="hljs-number">1</span>) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(num[q.<span class="hljs-built_in">front</span>()]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="46-最小的K个数"><a href="#46-最小的K个数" class="headerlink" title="46. 最小的K个数"></a>46. 最小的K个数</h3><p>维护一个大根堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param input int整型vector </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; heap; <span class="hljs-comment">// 维护一个大顶堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            heap.<span class="hljs-built_in">push</span>(input[i]);<br>            <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                heap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(heap.<span class="hljs-built_in">top</span>());<br>            heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="47-寻找第K大"><a href="#47-寻找第K大" class="headerlink" title="47. 寻找第K大"></a>47. 寻找第K大</h3><h4 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param a int整型vector</span><br><span class="hljs-comment">     * @param n int整型</span><br><span class="hljs-comment">     * @param K int整型</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">q_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<br>            <span class="hljs-keyword">return</span> nums[l];<br>        &#125;<br>        <span class="hljs-type">int</span> x = nums[(l + r) / <span class="hljs-number">2</span>], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt; x) i++;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; x) i--;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> restl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= restl) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">q_sort</span>(nums, l, j, k);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">q_sort</span>(nums, j + <span class="hljs-number">1</span>, r, k - restl);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">q_sort</span>(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="48-数据流中的中位数"><a href="#48-数据流中的中位数" class="headerlink" title="48. 数据流中的中位数"></a>48. 数据流中的中位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; max_heap; <span class="hljs-comment">// 大根堆</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; min_heap; <span class="hljs-comment">// 小根堆</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>        max_heap.<span class="hljs-built_in">push</span>(num); <span class="hljs-comment">// 先向大根堆里面添加元素</span><br>        <span class="hljs-keyword">if</span> (min_heap.<span class="hljs-built_in">size</span>() &amp;&amp; max_heap.<span class="hljs-built_in">top</span>() &gt; min_heap.<span class="hljs-built_in">top</span>()) &#123; <span class="hljs-comment">// 逆序了 交换</span><br>            <span class="hljs-type">int</span> maxv = max_heap.<span class="hljs-built_in">top</span>(), minv = min_heap.<span class="hljs-built_in">top</span>();<br>            max_heap.<span class="hljs-built_in">pop</span>(), min_heap.<span class="hljs-built_in">pop</span>();<br>            max_heap.<span class="hljs-built_in">push</span>(minv), min_heap.<span class="hljs-built_in">push</span>(maxv);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (max_heap.<span class="hljs-built_in">size</span>() - min_heap.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 移入</span><br>            min_heap.<span class="hljs-built_in">push</span>(max_heap.<span class="hljs-built_in">top</span>());<br>            max_heap.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> ((max_heap.<span class="hljs-built_in">size</span>() + min_heap.<span class="hljs-built_in">size</span>()) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果是奇数</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(max_heap.<span class="hljs-built_in">top</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(max_heap.<span class="hljs-built_in">top</span>()) + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(min_heap.<span class="hljs-built_in">top</span>())) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第五部分-哈希"><a href="#第五部分-哈希" class="headerlink" title="第五部分 哈希"></a>第五部分 哈希</h2><h3 id="50-两数之和"><a href="#50-两数之和" class="headerlink" title="50. 两数之和"></a>50. 两数之和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @param target int整型 </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> temp = target - numbers[i];<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(temp) == hash.<span class="hljs-built_in">end</span>()) &#123;<br>                hash[numbers[i]] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(hash[temp] + <span class="hljs-number">1</span>);<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="51-数组中出现次数超过一半的数字"><a href="#51-数组中出现次数超过一半的数字" class="headerlink" title="51. 数组中出现次数超过一半的数字"></a>51. 数组中出现次数超过一半的数字</h3><h4 id="候选法"><a href="#候选法" class="headerlink" title="候选法"></a>候选法</h4><p>假如数组中存在众数，那么众数的一定大于数组长度的一半。</p><p>思想就是：如果两个数不相等，就消去这两个数，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</p><p>具体做法：</p><ol><li>初始化：候选人 candidate &#x3D; -1，候选人的投票次数 cnt &#x3D; 0</li><li>遍历数组，如果 cnt &#x3D; 0，表示当前没有候选人，则将候选人置为当前遍历的数 numbers[i]，并将 cnt++</li><li>否则，如果 cnt &gt; 0，表示当前有候选人，与 number[i] 做比较，如果相等，则 cnt++，否则 cnt–，表示消掉</li><li>数组遍历完毕，判断 candidate 是不是众数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param numbers int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>                candidate = numbers[i];<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (candidate == numbers[i]) &#123;<br>                    cnt++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cnt--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i] == candidate) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt &gt; numbers.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> candidate;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="52-数组中只出现一次的两个数字"><a href="#52-数组中只出现一次的两个数字" class="headerlink" title="52. 数组中只出现一次的两个数字"></a>52. 数组中只出现一次的两个数字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// first ^ second</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            sum ^= x;<br>        &#125;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!(sum &gt;&gt; k &amp; <span class="hljs-number">1</span>)) k++;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x &gt;&gt; k &amp; <span class="hljs-number">1</span>) &#123;<br>                first ^= x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> second = sum ^ first;<br>        <span class="hljs-keyword">if</span> (first &lt; second) &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;first, second&#125;;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;second, first&#125;;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="53-缺失的第一个正整数"><a href="#53-缺失的第一个正整数" class="headerlink" title="53. 缺失的第一个正整数"></a>53. 缺失的第一个正整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberDisappeared</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) &#123;<br>            mp[x] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (mp[res]) &#123;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="54-三数之和"><a href="#54-三数之和" class="headerlink" title="54. 三数之和"></a>54. 三数之和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param num int整型vector </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; num[i] == num[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> target = -num[i];<br>            <span class="hljs-keyword">while</span> (left &lt;  right) &#123;<br>                <span class="hljs-keyword">if</span> (num[left] + num[right] == target) &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;num[i], num[left], num[right]&#125;);<br>                    <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right &amp;&amp; num[left] == num[left + <span class="hljs-number">1</span>]) &#123;<br>                        left++;<br>                    &#125; <br>                    <span class="hljs-keyword">while</span> (right - <span class="hljs-number">1</span> &gt; left &amp;&amp; num[right] == num[right - <span class="hljs-number">1</span>]) &#123;<br>                        right--;<br>                    &#125;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num[left] + num[right] &gt; target) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    left++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第六部分-递归"><a href="#第六部分-递归" class="headerlink" title="第六部分 递归"></a>第六部分 递归</h2><h3 id="55-没有重复项数字的全排列"><a href="#55-没有重复项数字的全排列" class="headerlink" title="55. 没有重复项数字的全排列"></a>55. 没有重复项数字的全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param num int整型vector </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(num);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; num.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-built_in">swap</span>(num[i], num[index]);<br>                <span class="hljs-built_in">recursion</span>(res, num, index + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">swap</span>(num[i], num[index]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">recursion</span>(res, num, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="56-有重复数字项的全排列"><a href="#56-有重复数字项的全排列" class="headerlink" title="56. 有重复数字项的全排列"></a>56. 有重复数字项的全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param num int整型vector </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res, vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == num.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i] || i &gt; <span class="hljs-number">0</span> &amp;&amp; num[i - <span class="hljs-number">1</span>] == num[i] &amp;&amp; !vis[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(num[i]);<br>            <span class="hljs-built_in">recursion</span>(res, num, temp, vis);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; num) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(num.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-built_in">recursion</span>(res, num, temp, vis);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="57-岛屿数量"><a href="#57-岛屿数量" class="headerlink" title="57. 岛屿数量"></a>57. 岛屿数量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 判断岛屿数量</span><br><span class="hljs-comment">     * @param grid char字符型vector&lt;vector&lt;&gt;&gt; </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, i - <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, i + <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, i, j - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(grid, i, j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    count++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="59-N-皇后问题"><a href="#59-N-皇后问题" class="headerlink" title="59. N 皇后问题"></a>59. N 皇后问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 the n</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pos, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">if</span> (col == pos[i] || <span class="hljs-built_in">abs</span>(row - i) == <span class="hljs-built_in">abs</span>(col - pos[i])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, vector&lt;<span class="hljs-type">int</span>&gt;&amp; pos, <span class="hljs-type">int</span>&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            res++;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(pos, row, i)) &#123;<br>                pos[row] = i;<br>                <span class="hljs-built_in">recursion</span>(n, row + <span class="hljs-number">1</span>, pos, res);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Nqueen</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-built_in">recursion</span>(n, <span class="hljs-number">0</span>, pos, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="58-字符串的排列"><a href="#58-字符串的排列" class="headerlink" title="58. 字符串的排列"></a>58. 字符串的排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;system_error&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(vector&lt;string&gt;&amp; res, string&amp; str, string&amp; temp, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; vis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">length</span>() == str.<span class="hljs-built_in">length</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i] || i &gt; <span class="hljs-number">0</span> &amp;&amp; str[i - <span class="hljs-number">1</span>] == str[i] &amp;&amp; !vis[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(str[i]);<br>            <span class="hljs-built_in">recursion</span>(res, str, temp, vis);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(str.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;string&gt; res;<br>        string temp;<br>        <span class="hljs-built_in">recursion</span>(res, str, temp, vis);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="60-括号生成"><a href="#60-括号生成" class="headerlink" title="60. 括号生成"></a>60. 括号生成</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursion</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, string temp, vector&lt;string&gt;&amp; res, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == n &amp;&amp; right == n) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>            <span class="hljs-built_in">recursion</span>(left + <span class="hljs-number">1</span>, right, temp + <span class="hljs-string">&quot;(&quot;</span>, res, n);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; left &gt; right) &#123;<br>            <span class="hljs-built_in">recursion</span>(left, right + <span class="hljs-number">1</span>, temp + <span class="hljs-string">&quot;)&quot;</span>, res, n);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string temp;<br>        <span class="hljs-built_in">recursion</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, temp, res, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="61-矩阵最长递增路径"><a href="#61-矩阵最长递增路径" class="headerlink" title="61. 矩阵最长递增路径"></a>61. 矩阵最长递增路径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;regex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 递增路径的最大长度</span><br><span class="hljs-comment">     * @param matrix int整型vector&lt;vector&lt;&gt;&gt; 描述矩阵的每个数</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dp, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dp[i][j] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        &#125;<br>        dp[i][j]++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>            <span class="hljs-type">int</span> nexti = i + dx[k];<br>            <span class="hljs-type">int</span> nextj = j + dy[k];<br>            <span class="hljs-keyword">if</span> (nexti &gt;= <span class="hljs-number">0</span> &amp;&amp; nexti &lt; n &amp;&amp; nextj &gt;= <span class="hljs-number">0</span> &amp;&amp; nextj &lt; m &amp;&amp; matrix[nexti][nextj] &gt; matrix[i][j]) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], <span class="hljs-built_in">dfs</span>(matrix, dp, nexti, nextj) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        n = matrix.<span class="hljs-built_in">size</span>();<br>        m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dfs</span>(matrix, dp, i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第七部分-动态规划"><a href="#第七部分-动态规划" class="headerlink" title="第七部分 动态规划"></a>第七部分 动态规划</h2><h3 id="62-斐波那契数列"><a href="#62-斐波那契数列" class="headerlink" title="62. 斐波那契数列"></a>62. 斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="63-跳台阶"><a href="#63-跳台阶" class="headerlink" title="63. 跳台阶"></a>63. 跳台阶</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param number int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(number + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= number; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">2</span>] + dp[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="64-最小花费爬楼梯"><a href="#64-最小花费爬楼梯" class="headerlink" title="64. 最小花费爬楼梯"></a>64. 最小花费爬楼梯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param cost int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="65-最长公共子序列"><a href="#65-最长公共子序列" class="headerlink" title="65. 最长公共子序列"></a>65. 最长公共子序列</h3><p>状态表示: $dp[i][j]$表示在第一个字符串中以i为结尾，第二个字符串中以j为结尾的最长公共子序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * longest common subsequence</span><br><span class="hljs-comment">     * @param s1 string字符串 the string</span><br><span class="hljs-comment">     * @param s2 string字符串 the string</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">size</span>(), m = s2.<span class="hljs-built_in">size</span>();<br>        s1 = <span class="hljs-string">&quot;#&quot;</span> + s1;<br>        s2 = <span class="hljs-string">&quot;.&quot;</span> + s2;<br>        cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (s1[i] == s2[j]) &#123;<br>                    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> i = n, j = m;<br>        cout &lt;&lt; dp[n][m] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; s;<br>        <span class="hljs-keyword">while</span> (dp[i][j]) &#123;<br>            <span class="hljs-comment">// 说明第一个字符串的第i个不是最长公共子序列中的</span><br>            <span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j]) &#123;<br>                i--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] == dp[i][j - <span class="hljs-number">1</span>]) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] &gt; dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                s.<span class="hljs-built_in">push</span>(s1[i]);<br>                i--;<br>                j--;<br>            &#125;<br>        &#125;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            res += s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res != <span class="hljs-string">&quot;&quot;</span> ? res : <span class="hljs-string">&quot;-1&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="66-最长公共子串"><a href="#66-最长公共子串" class="headerlink" title="66. 最长公共子串"></a>66. 最长公共子串</h3><p>最长公共子串，子串一定是连续的</p><p>$dp[i][j]$表示以str1中第i个字符和str2中第j个字符为最后一个元素所构成的最长公共子串</p><p>分为两种情况讨论：</p><ul><li><p>str1[i] !&#x3D; str2[j]</p><p><code>dp[i][j] = 0</code></p></li><li><p>str1[i] &#x3D;&#x3D; str2[j]</p><p><code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * longest common substring</span><br><span class="hljs-comment">     * @param str1 string字符串 the string</span><br><span class="hljs-comment">     * @param str2 string字符串 the string</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">LCS</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = str1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = str2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (str1[i - <span class="hljs-number">1</span>] == str2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (dp[i][j] &gt; len) &#123;<br>                        len = dp[i][j];<br>                        index = i - <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str1.<span class="hljs-built_in">substr</span>(index - len + <span class="hljs-number">1</span>, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="67-不同路径的数目-一"><a href="#67-不同路径的数目-一" class="headerlink" title="67. 不同路径的数目(一)"></a>67. 不同路径的数目(一)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param m int整型 </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="68-矩阵的最小路径和"><a href="#68-矩阵的最小路径和" class="headerlink" title="68. 矩阵的最小路径和"></a>68. 矩阵的最小路径和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param matrix int整型vector&lt;vector&lt;&gt;&gt; the matrix</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; col; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + matrix[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + matrix[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j =  <span class="hljs-number">1</span>; j &lt; col; j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + matrix[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="69-把数字翻译成字符串"><a href="#69-把数字翻译成字符串" class="headerlink" title="69. 把数字翻译成字符串"></a>69. 把数字翻译成字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 解码</span><br><span class="hljs-comment">     * @param nums string字符串 数字串</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-string">&quot;10&quot;</span> || nums == <span class="hljs-string">&quot;20&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.length() + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= nums.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span> || nums[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-string">&#x27;7&#x27;</span>) <br>            &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">length</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="70-兑换零钱-一"><a href="#70-兑换零钱-一" class="headerlink" title="70. 兑换零钱(一)"></a>70. 兑换零钱(一)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 最少货币数</span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @param aim int整型 the target</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoney</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> aim)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (aim &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(aim + <span class="hljs-number">1</span>, aim + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= aim; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt;= i) &#123;<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - arr[j]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[aim] &gt; aim ? <span class="hljs-number">-1</span> : dp[aim];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="71-最长上升子序列-一"><a href="#71-最长上升子序列-一" class="headerlink" title="71. 最长上升子序列(一)"></a>71. 最长上升子序列(一)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 给定数组的最长严格上升子序列的长度。</span><br><span class="hljs-comment">     * @param arr int整型vector 给定的数组</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(arr.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &lt; arr[i]) &#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="72-连续子数组的最大和"><a href="#72-连续子数组的最大和" class="headerlink" title="72. 连续子数组的最大和"></a>72. 连续子数组的最大和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param array int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + array[i], array[i]);<br>            res = <span class="hljs-built_in">max</span>(dp[i], res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="73-最长回文子串"><a href="#73-最长回文子串" class="headerlink" title="73. 最长回文子串"></a>73. 最长回文子串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param A string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(string A, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; A.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (A[left] == A[right]) &#123;<br>                left--;<br>                right++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLongestPalindrome</span><span class="hljs-params">(string A)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = A.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">helper</span>(A, i, i), <span class="hljs-built_in">helper</span>(A, i, i + <span class="hljs-number">1</span>));<br>            res = <span class="hljs-built_in">max</span>(res, len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="74-数字字符串转化为IP地址"><a href="#74-数字字符串转化为IP地址" class="headerlink" title="74. 数字字符串转化为IP地址"></a>74. 数字字符串转化为IP地址</h3><p>思路：对于一个IP字符串，如果它给一个数字，相当于我们需要将IP地址的三个点插入字符串中；而第一个点的位置只能在IP的第一、第二、第三个字符之后，第二个点只能在第一个点后1 ~ 3个位置内，第三个点只能在第二个点之后的1 ~ 3个位置内，并且要求第三个点之后的数字个数不能超过3，因为IP地址每位最多3位数字。</p><p>具体做法：</p><ul><li>依次枚举这三个点的位置</li><li>截取出四段数字</li><li>比较截取出来的数字，不能大于255，且除了0以外不能有前导0，然后才能组装成IP地址加入答案。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;string&gt; ret;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 1. 遍历IP</span><br>        <span class="hljs-comment">// 枚举第一个点的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span> &amp;&amp; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 枚举第二个点的位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; i + <span class="hljs-number">4</span> &amp;&amp; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-comment">// 枚举第三个点的位置</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; j + <span class="hljs-number">4</span> &amp;&amp; k &lt; n; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (n - k &gt; <span class="hljs-number">3</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 最后一段的长度不能超过3</span><br>                    &#125;<br>                    string a = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>                    string b = s.<span class="hljs-built_in">substr</span>(i, j - i);<br>                    string c = s.<span class="hljs-built_in">substr</span>(j, k - j);<br>                    string d = s.<span class="hljs-built_in">substr</span>(k);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stoi</span>(a) &gt; <span class="hljs-number">255</span> || <span class="hljs-built_in">stoi</span>(b) &gt; <span class="hljs-number">255</span> || <span class="hljs-built_in">stoi</span>(c) &gt; <span class="hljs-number">255</span> || <span class="hljs-built_in">stoi</span>(d) &gt; <span class="hljs-number">255</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 不能超过255</span><br>                    &#125;<br>                    <span class="hljs-comment">// 排除前导0的情况</span><br>                    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> ((a.<span class="hljs-built_in">length</span>() != <span class="hljs-number">1</span> &amp;&amp; a[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) || (b.<span class="hljs-built_in">length</span>() != <span class="hljs-number">1</span> &amp;&amp; b[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) || (c.<span class="hljs-built_in">length</span>() != <span class="hljs-number">1</span> &amp;&amp; c[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) || (d.<span class="hljs-built_in">length</span>() != <span class="hljs-number">1</span> &amp;&amp; d[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)) &#123;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    string temp = a + <span class="hljs-string">&quot;.&quot;</span> + b + <span class="hljs-string">&quot;.&quot;</span> + c + <span class="hljs-string">&quot;.&quot;</span> + d;<br>                    ret.<span class="hljs-built_in">push_back</span>(temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="75-编辑距离"><a href="#75-编辑距离" class="headerlink" title="75. 编辑距离"></a>75. 编辑距离</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str1 string字符串 </span><br><span class="hljs-comment">     * @param str2 string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">editDistance</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        str1 = <span class="hljs-string">&quot;#&quot;</span> + str1;<br>        str2 = <span class="hljs-string">&quot;#&quot;</span> + str2;<br>        <span class="hljs-type">int</span> n = str1.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> m = str2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (str1[i] == str2[j]) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="76-正则表达式匹配"><a href="#76-正则表达式匹配" class="headerlink" title="76. 正则表达式匹配"></a>76. 正则表达式匹配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">状态表示：dp[i][j] 表示 s[i, ...] 和 p[j, ...] 相匹配</span><br><span class="hljs-comment">状态转移：</span><br><span class="hljs-comment">1. p[j] 是正常字符 dp[i][j] = s[i] == p[j] &amp;&amp; dp[i + 1][j + 1]</span><br><span class="hljs-comment">2. p[j] 是 &#x27;.&#x27; dp[i][j] = dp[i + 1][j + 1]</span><br><span class="hljs-comment">3. p[j + 1] 是 &#x27;*&#x27; </span><br><span class="hljs-comment">dp[i][j] = dp[i][j + 2] // b* 枚举0次</span><br><span class="hljs-comment">dp[i][j] = dp[i + 1][j] // b* 枚举非0次</span><br><span class="hljs-comment">dp[n][m] = true</span><br><span class="hljs-comment">b*</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n, m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">length</span>(), m = p.<span class="hljs-built_in">length</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; (n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s, p);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[x][y] != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 如果已经被算过了</span><br>            <span class="hljs-keyword">return</span> f[x][y];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (y == m) &#123;<br>            <span class="hljs-keyword">return</span> f[x][y] = x == n;<br>        &#125;<br>        <span class="hljs-type">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="hljs-string">&#x27;.&#x27;</span> || s[x] == p[y]);<br>        <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; m &amp;&amp; p[y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            f[x][y] = <span class="hljs-built_in">dp</span>(x, y + <span class="hljs-number">2</span>, s, p) || first_match &amp;&amp; <span class="hljs-built_in">dp</span>(x + <span class="hljs-number">1</span>, y, s, p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f[x][y] = first_match &amp;&amp; <span class="hljs-built_in">dp</span>(x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, s, p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x][y];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="77-最长的括号子串"><a href="#77-最长的括号子串" class="headerlink" title="77. 最长的括号子串"></a>77. 最长的括号子串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">size</span>() &amp;&amp; s[stk.<span class="hljs-built_in">top</span>()] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stk.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">size</span>()) &#123;<br>                r = i - stk.<span class="hljs-built_in">top</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = i + <span class="hljs-number">1</span>;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="78-打家劫舍-一"><a href="#78-打家劫舍-一" class="headerlink" title="78. 打家劫舍(一)"></a>78. 打家劫舍(一)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="79-打家劫舍-二"><a href="#79-打家劫舍-二" class="headerlink" title="79. 打家劫舍(二)"></a>79. 打家劫舍(二)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param nums int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> res = dp[n - <span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);<br>        &#125;<br>        res = <span class="hljs-built_in">max</span>(res, dp[n - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="80-买卖股票的最好时机-一"><a href="#80-买卖股票的最好时机-一" class="headerlink" title="80. 买卖股票的最好时机(一)"></a>80. 买卖股票的最好时机(一)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param prices int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="81-买卖股票的最好时机-二"><a href="#81-买卖股票的最好时机-二" class="headerlink" title="81. 买卖股票的最好时机(二)"></a>81. 买卖股票的最好时机(二)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 计算最大收益</span><br><span class="hljs-comment">     * @param prices int整型vector 股票每一天的价格</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="82-买卖股票的最好时机-三"><a href="#82-买卖股票的最好时机-三" class="headerlink" title="82. 买卖股票的最好时机(三)"></a>82. 买卖股票的最好时机(三)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;endian.h&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 两次交易所能获得的最大收益</span><br><span class="hljs-comment">     * @param prices int整型vector 股票每一天的价格</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第八部分-字符串"><a href="#第八部分-字符串" class="headerlink" title="第八部分 字符串"></a>第八部分 字符串</h2><h3 id="83-字符串变形"><a href="#83-字符串变形" class="headerlink" title="83. 字符串变形"></a>83. 字符串变形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param s string字符串</span><br><span class="hljs-comment">     * @param n int整型</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">trans</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>                res += s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                res += s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += s[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; res[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>() + i, res.<span class="hljs-built_in">begin</span>() + j);<br>            i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="84-最长公共前缀"><a href="#84-最长公共前缀" class="headerlink" title="84. 最长公共前缀"></a>84. 最长公共前缀</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param strs string字符串vector </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = strs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">char</span> temp = strs[<span class="hljs-number">0</span>][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == strs[j].<span class="hljs-built_in">length</span>() || strs[j][i] != temp) &#123;<br>                    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="85-验证IP地址"><a href="#85-验证IP地址" class="headerlink" title="85. 验证IP地址"></a>85. 验证IP地址</h3><p>思路：对于每一个IP，分别判断是IPv4还是IPv6，用两个不同的函数。</p><p>写一个函数split，将所有的数字分割开，判断是否满足条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 验证IP地址</span><br><span class="hljs-comment">     * @param IP string字符串 一个IP地址字符串</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string str, string spliter)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">while</span> ((i = str.<span class="hljs-built_in">find</span>(spliter)) &amp;&amp; i != str.npos) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>            str = str.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(str);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv4</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>        vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(IP, <span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 一定是四组</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i].<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span> || s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span> || (s[i].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> &amp;&amp; s[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(s[i][j])) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">stoi</span>(s[i]);<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span> || num &gt; <span class="hljs-number">255</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIPv6</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>        vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(IP, <span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-comment">// 8组</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != <span class="hljs-number">8</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i].<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span> || s[i].<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; s[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">isdigit</span>(s[i][j]) || (s[i][j] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i][j] &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) || (s[i][j] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i][j] &lt;= <span class="hljs-string">&#x27;F&#x27;</span>))) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        string res = <span class="hljs-string">&quot;Neither&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isIPv4</span>(IP)) &#123;<br>            res = <span class="hljs-string">&quot;IPv4&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isIPv6</span>(IP)) &#123;<br>            res = <span class="hljs-string">&quot;IPv6&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="86-大数加法"><a href="#86-大数加法" class="headerlink" title="86. 大数加法"></a>86. 大数加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 计算两个数之和</span><br><span class="hljs-comment">     * @param s string字符串 表示第一个整数</span><br><span class="hljs-comment">     * @param t string字符串 表示第二个整数</span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = t.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> n1 = i &gt;= <span class="hljs-number">0</span> ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> n2 = j &gt;= <span class="hljs-number">0</span> ? t[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> tmp = n1 + n2 + carry;<br>            carry = tmp / <span class="hljs-number">10</span>;<br>            <span class="hljs-type">char</span> st = tmp % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            res = st + res;<br>            i -= <span class="hljs-number">1</span>;<br>            j -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry) &#123;<br>            res = <span class="hljs-string">&quot;1&quot;</span> + res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第九部分-双指针"><a href="#第九部分-双指针" class="headerlink" title="第九部分 双指针"></a>第九部分 双指针</h2><h3 id="87-合并两个有序的数组"><a href="#87-合并两个有序的数组" class="headerlink" title="87. 合并两个有序的数组"></a>87. 合并两个有序的数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> c[m + n];<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;<br>            c[p++] = A[i] &lt; B[j] ? A[i++] : B[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>            c[p++] = A[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            c[p++] = B[j++];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m + n; i++) &#123;<br>            A[i] = c[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="88-判断是否为回文字符串"><a href="#88-判断是否为回文字符串" class="headerlink" title="88. 判断是否为回文字符串"></a>88. 判断是否为回文字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param str string字符串 待判断的字符串</span><br><span class="hljs-comment">     * @return bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = str.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == str[j]) &#123;<br>                i++;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="89-合并区间"><a href="#89-合并区间" class="headerlink" title="89. 合并区间"></a>89. 合并区间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct Interval &#123;</span><br><span class="hljs-comment"> *int start;</span><br><span class="hljs-comment"> *int end;</span><br><span class="hljs-comment"> *Interval(int s, int e) : start(start), end(e) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param intervals Interval类vector </span><br><span class="hljs-comment">     * @return Interval类vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Interval&amp; a, Interval&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.start &lt; b.start;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;Interval&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;Interval&gt; res;<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        res.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> n = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i].start &lt;= res.<span class="hljs-built_in">back</span>().end) &#123;<br>                res.<span class="hljs-built_in">back</span>().end = <span class="hljs-built_in">max</span>(res.<span class="hljs-built_in">back</span>().end, intervals[i].end);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(intervals[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="90-最小覆盖子串"><a href="#90-最小覆盖子串" class="headerlink" title="90. 最小覆盖子串"></a>90. 最小覆盖子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param S string字符串 </span><br><span class="hljs-comment">     * @param T string字符串 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = hash.<span class="hljs-built_in">begin</span>(); iter != hash.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>            <span class="hljs-keyword">if</span> (iter-&gt;second &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string S, string T)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> cnt = S.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            hash[T[i]] -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">-1</span>, right = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (; fast &lt; S.<span class="hljs-built_in">length</span>(); fast++) &#123;<br>            <span class="hljs-type">char</span> c = S[fast];<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(c)) &#123;<br>                hash[c]++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>(hash)) &#123;<br>                <span class="hljs-keyword">if</span> (cnt &gt; fast - slow + <span class="hljs-number">1</span>) &#123;<br>                    cnt = fast - slow + <span class="hljs-number">1</span>;<br>                    left = slow;<br>                    right = fast;<br>                &#125;<br>                <span class="hljs-type">char</span> c = S[slow];<br>                <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(c)) &#123;<br>                    hash[c]--;<br>                &#125;<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(S.<span class="hljs-built_in">begin</span>() + left, S.<span class="hljs-built_in">begin</span>() + right + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="91-反转字符串"><a href="#91-反转字符串" class="headerlink" title="91. 反转字符串"></a>91. 反转字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 反转字符串</span><br><span class="hljs-comment">     * @param str string字符串 </span><br><span class="hljs-comment">     * @return string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">solve</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            res += str[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="92-最长无重复子数组"><a href="#92-最长无重复子数组" class="headerlink" title="92. 最长无重复子数组"></a>92. 最长无重复子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>; right &lt; arr.<span class="hljs-built_in">size</span>(); right++) &#123;<br>            mp[arr[right]]++;<br>            <span class="hljs-keyword">while</span> (mp[arr[right]] &gt; <span class="hljs-number">1</span>) &#123;<br>                mp[arr[left++]]--;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="93-盛水最多的容器"><a href="#93-盛水最多的容器" class="headerlink" title="93. 盛水最多的容器"></a>93. 盛水最多的容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param height int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> cap = <span class="hljs-built_in">min</span>(height[left], height[right]) * (right - left);<br>            res = <span class="hljs-built_in">max</span>(res, cap);<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="94-接雨水"><a href="#94-接雨水" class="headerlink" title="94. 接雨水"></a>94. 接雨水</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * max water</span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @return long长整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maxWater</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxL = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxR = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            maxL = <span class="hljs-built_in">max</span>(maxL, arr[left]);<br>            maxR = <span class="hljs-built_in">max</span>(maxR, arr[right]);<br>            <span class="hljs-keyword">if</span> (maxR &gt; maxL) &#123;<br>                res += maxL - arr[left++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += maxR - arr[right--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第十部分-贪心算法"><a href="#第十部分-贪心算法" class="headerlink" title="第十部分 贪心算法"></a>第十部分 贪心算法</h2><h3 id="95-分糖果问题"><a href="#95-分糖果问题" class="headerlink" title="95. 分糖果问题"></a>95. 分糖果问题</h3><p>从左往右一遍，右边比左边大就递增，不然就是0；从右往左一遍，一样；最后所有都+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * pick candy</span><br><span class="hljs-comment">     * @param arr int整型vector the array</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>                res[i + <span class="hljs-number">1</span>] = res[i] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[i - <span class="hljs-number">1</span>]) &#123;<br>                res[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(res[i - <span class="hljs-number">1</span>], res[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res[i] = res[i] + dp[i];<br>            sum += res[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="96-主持人调度-二"><a href="#96-主持人调度-二" class="headerlink" title="96. 主持人调度(二)"></a>96. 主持人调度(二)</h3><p>将所有的时间排序，如果是开始时间就加1，结束时间就减1，峰值就是需要的主持人数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 计算成功举办活动需要多少名主持人</span><br><span class="hljs-comment">     * @param n int整型 有n个活动</span><br><span class="hljs-comment">     * @param startEnd int整型vector&lt;vector&lt;&gt;&gt; startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minmumNumberOfHost</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; startEnd)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">tt</span>(<span class="hljs-number">2</span> * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            tt[<span class="hljs-number">2</span> * i] = &#123;startEnd[i][<span class="hljs-number">0</span>], <span class="hljs-number">1</span>&#125;;<br>            tt[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] = &#123;startEnd[i][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>&#125;;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(tt.<span class="hljs-built_in">begin</span>(), tt.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ma = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (tt[i].second == <span class="hljs-number">1</span>) &#123;<br>                res += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res -= <span class="hljs-number">1</span>;<br>            &#125;<br>            ma = <span class="hljs-built_in">max</span>(ma, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ma;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第十一部分-模拟"><a href="#第十一部分-模拟" class="headerlink" title="第十一部分 模拟"></a>第十一部分 模拟</h2><h3 id="97-旋转数组"><a href="#97-旋转数组" class="headerlink" title="97. 旋转数组"></a>97. 旋转数组</h3><p>三次反转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 旋转数组</span><br><span class="hljs-comment">     * @param n int整型 数组长度</span><br><span class="hljs-comment">     * @param m int整型 右移距离</span><br><span class="hljs-comment">     * @param a int整型vector 给定数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        m = m % n;<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">begin</span>() + m);<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>() + m, a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="98-螺旋矩阵"><a href="#98-螺旋矩阵" class="headerlink" title="98. 螺旋矩阵"></a>98. 螺旋矩阵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param matrix int整型vector&lt;vector&lt;&gt;&gt; </span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左边界</span><br>        <span class="hljs-type">int</span> right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 右边界</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>; <span class="hljs-comment">// 上边界</span><br>        <span class="hljs-type">int</span> down = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 下边界</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; up &lt;= down) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[up][i]);<br>            &#125;<br>            up++;<br>            <span class="hljs-keyword">if</span> (up &gt; down) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = up; i &lt;= down; i++) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = right; i &gt;= left; i--) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            &#125;<br>            down--;<br>            <span class="hljs-keyword">if</span> (up &gt; down) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = down; i &gt;= up; i--) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            &#125;<br>            left++;<br>            <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="99-顺时针旋转矩阵"><a href="#99-顺时针旋转矩阵" class="headerlink" title="99. 顺时针旋转矩阵"></a>99. 顺时针旋转矩阵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param mat int整型vector&lt;vector&lt;&gt;&gt; </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">rotateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; mat, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                res[i][j] = mat[n - <span class="hljs-number">1</span> - j][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="100-设计LRU缓存结构"><a href="#100-设计LRU缓存结构" class="headerlink" title="100. 设计LRU缓存结构"></a>100. 设计LRU缓存结构</h3><p>哈希表实现O(1)查找，list模拟双向链表实现最近不经常使用，队头的是最近使用的，队尾的是最不经常使用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(<span class="hljs-type">int</span> capacity)&#123;<br>    <span class="hljs-comment">// write code here</span><br>        cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">find</span>(key) != mp.<span class="hljs-built_in">end</span>()) &#123; <span class="hljs-comment">// 如果原本里面存在</span><br>            <span class="hljs-type">int</span> val = mp[key]-&gt;second;<br>            dlist.<span class="hljs-built_in">erase</span>(mp[key]);<br>            dlist.<span class="hljs-built_in">push_front</span>(&#123;key, val&#125;);<br>            mp[key] = dlist.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果不存在</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">find</span>(key) != mp.<span class="hljs-built_in">end</span>()) &#123; <span class="hljs-comment">// 如果原本里面就已经存在</span><br>            dlist.<span class="hljs-built_in">erase</span>(mp[key]);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dlist.<span class="hljs-built_in">size</span>() == cap) &#123;<br>            mp.<span class="hljs-built_in">erase</span>(dlist.<span class="hljs-built_in">back</span>().first);<br>            dlist.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dlist.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>        mp[key] = dlist.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; dlist;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; mp;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* solution = new Solution(capacity);</span><br><span class="hljs-comment"> * int output = solution-&gt;get(key);</span><br><span class="hljs-comment"> * solution-&gt;set(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="101-设计LFU缓存结构"><a href="#101-设计LFU缓存结构" class="headerlink" title="101. 设计LFU缓存结构"></a>101. 设计LFU缓存结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * lfu design</span><br><span class="hljs-comment">     * @param operators int整型vector&lt;vector&lt;&gt;&gt; ops</span><br><span class="hljs-comment">     * @param k int整型 the k</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; freqToKeys;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator&gt; mp;<br><br>    <span class="hljs-type">int</span> minFreq = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cap = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">LFU</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; operators, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        cap = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; operators.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">auto</span> op = operators[i];<br>            <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">set</span>(op[<span class="hljs-number">1</span>], op[<span class="hljs-number">2</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">get</span>(op[<span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator iter, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-type">int</span> freq = (*iter)[<span class="hljs-number">0</span>];<br>        freqToKeys[freq].<span class="hljs-built_in">erase</span>(iter);<br>        <span class="hljs-keyword">if</span> (freqToKeys[freq].<span class="hljs-built_in">empty</span>()) &#123;<br>            freqToKeys.<span class="hljs-built_in">erase</span>(freq);<br>            <span class="hljs-keyword">if</span> (minFreq == freq) &#123;<br>                minFreq++;<br>            &#125;<br>        &#125;<br>        freqToKeys[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">push_front</span>(&#123;freq + <span class="hljs-number">1</span>, key, value&#125;);<br>        mp[key] = freqToKeys[freq + <span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it != mp.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-built_in">update</span>(it-&gt;second, key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (cap == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> oldKey = freqToKeys[minFreq].<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>];<br>                freqToKeys[minFreq].<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-keyword">if</span> (freqToKeys[minFreq].<span class="hljs-built_in">empty</span>()) &#123;<br>                    freqToKeys.<span class="hljs-built_in">erase</span>(minFreq);<br>                &#125;<br>                mp.<span class="hljs-built_in">erase</span>(oldKey);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cap--;<br>            &#125;<br>            minFreq = <span class="hljs-number">1</span>;<br>            freqToKeys[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">1</span>, key, value&#125;);<br>            mp[key] = freqToKeys[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span> (it != mp.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> iter = it-&gt;second;<br>            res = (*iter)[<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">update</span>(iter, key, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="第十二部分-随机刷题！"><a href="#第十二部分-随机刷题！" class="headerlink" title="第十二部分 随机刷题！"></a>第十二部分 随机刷题！</h2><h3 id="102-leetcode155-最小栈"><a href="#102-leetcode155-最小栈" class="headerlink" title="102. leetcode155 最小栈"></a>102. leetcode155 最小栈</h3><h4 id="方法1：用一个辅助栈"><a href="#方法1：用一个辅助栈" class="headerlink" title="方法1：用一个辅助栈"></a>方法1：用一个辅助栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_stack.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">push</span>(val);<br>        min_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(min_stack.<span class="hljs-built_in">top</span>(), val));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">pop</span>();<br>        min_stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; x_stack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="方法2：一个栈同时保存当前值和栈内最小值"><a href="#方法2：一个栈同时保存当前值和栈内最小值" class="headerlink" title="方法2：一个栈同时保存当前值和栈内最小值"></a>方法2：一个栈同时保存当前值和栈内最小值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;val, val&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;val, <span class="hljs-built_in">min</span>(val, st.<span class="hljs-built_in">top</span>().second)&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().second;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="103-leetcode221-最大正方形"><a href="#103-leetcode221-最大正方形" class="headerlink" title="103. leetcode221.  最大正方形"></a>103. leetcode221.  最大正方形</h3><h4 id="方法1：动态规划"><a href="#方法1：动态规划" class="headerlink" title="方法1：动态规划"></a>方法1：动态规划</h4><p><code>dp[i][j]</code>表示以i,j为右下角的最大正方形的边长。</p><p>$dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1$</p><p>如果i &#x3D;&#x3D; 0或j &#x3D;&#x3D; 0，且$matrix[i][j] &#x3D;&#x3D; 1$，那么$dp[i][j] &#x3D; 1$</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    maxSide := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix[i]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            dp[i][j] = <span class="hljs-type">int</span>(matrix[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                maxSide = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = min(min(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]), dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; maxSide &#123;<br>                    maxSide = dp[i][j]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxSide = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(matrix.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                    maxSide = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; matrix[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] &gt; maxSide) &#123;<br>                    maxSide = dp[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSide * maxSide;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="104-Haffman编码-合并果子"><a href="#104-Haffman编码-合并果子" class="headerlink" title="104. Haffman编码 合并果子"></a>104. Haffman编码 合并果子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        heap.<span class="hljs-built_in">push</span>(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> a = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        heap.<span class="hljs-built_in">push</span>(a + b);<br>        res += a + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">solve</span>(nums) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="105-leetcode560-和为k的子数组"><a href="#105-leetcode560-和为k的子数组" class="headerlink" title="105. leetcode560 和为k的子数组"></a>105. leetcode560 和为k的子数组</h3><p>前缀和+哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// mp[i]表示前缀和为i的个数</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            pre += nums[i];<br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">find</span>(pre - k) != mp.<span class="hljs-built_in">end</span>()) &#123;<br>                res += mp[pre - k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试手撕</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The_Google_File_System</title>
    <link href="/2023/10/01/The_Google_File_System/"/>
    <url>/2023/10/01/The_Google_File_System/</url>
    
    <content type="html"><![CDATA[<h3 id="2-设计概览"><a href="#2-设计概览" class="headerlink" title="2 设计概览"></a>2 设计概览</h3><h4 id="2-1-假设"><a href="#2-1-假设" class="headerlink" title="2.1 假设"></a>2.1 假设</h4><ul><li>该系统由廉价的商业器件组成，经常会出问题，所以需要不断监控自己是否出现问题并从问题中恢复。</li><li>该系统存储少量的大型文件。有几百万个文件，每个文件的大小通常都是100MB左右。可以有少量的大文件，系统需要支持小文件，但是不需要对它做优化。</li><li>工作负载主要由两种读操作组成：大的顺序流读和小的随机读。大顺序流读：大多数是1MB或更多；小随机读：从任意的偏移量处读一些KB大小的数据。一些要求性能的应用会批处理或者给这些小的随机读排序而不是来回地从不同地地方去读取。</li><li>工作负载有写操作（大的连续写操作）。一旦写入，文件基本不会再改变。支持小随机写但是不需要考虑性能问题。</li><li>该系统必须有效地为并发附加到同一文件的多个客户端实现定义明确的语义。大多数是生产者消费者模型。</li><li>高持续带宽比低延迟更重要。</li></ul><h4 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h4><p>该系统提供熟悉的文件系统接口。支持一些常见的操作: <code>create</code>、<code>delete</code>、<code>open</code>、<code>close</code>、<code>read</code> and <code>write</code>files。还有<code>snapshot</code>和<code>record append</code>操作。</p><h4 id="2-3-架构"><a href="#2-3-架构" class="headerlink" title="2.3 架构"></a>2.3 架构</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231008195650024.png" alt="image-20231008195650024"></p><p>GFS集群由单个master服务器和多个chunk服务器组成，并由多个clients访问，如上图所示。</p><p>文件被分成固定大小的chunk(64MB)。每一个chunk被一个64位的唯一的chunk handle所标识（在chunk创建的时候被master标识）。为了系统的可靠性，每一个chunk在多个chunk服务器上复制。</p><p>client和chunk服务器都不做cache。对于客户端来说，客户端缓存几乎没有好处，因为大多数应用程序通过巨大的文件流或拥有太大而无法缓存的工作集；对于chunk服务器来说，块服务器不需要缓存文件数据，因为块存储为本地文件，因此 Linux 的缓冲区缓存已经在内存中保存频繁访问的数据。</p><h4 id="2-4-单个Master"><a href="#2-4-单个Master" class="headerlink" title="2.4 单个Master"></a>2.4 单个Master</h4><p>下面说一下client和master以及chunkserver通信的整个流程:</p><ul><li>首先，使用固定的块大小，客户端将应用程序指定的文件名和字节偏移量转换为文件中的块索引。</li><li>然后，它向Master发送包含文件名和块索引的请求。主服务器回复相应的块处理和位置副本。客户端使用文件名和块索引作为键缓存此信息。</li><li>然后客户端向其中一个副本发送请求，最有可能是最接近的一个。该请求指定该块内的块句柄和字节范围。（对同一块的进一步读取不需要额外的client-master交互，直到缓存的信息过期或文件重新打开。）</li><li>事实上，客户端通常要求同一请求中的多个块，并且主服务器还可以在请求之后立即包含块的信息。这种额外的信息几乎不需要额外的成本节省了几个未来的client-master交互。</li></ul><h4 id="2-5-Chunk-Size"><a href="#2-5-Chunk-Size" class="headerlink" title="2.5 Chunk Size"></a>2.5 Chunk Size</h4><p>64MB，比通常的文件系统的block size要大。</p><p>大的chunk size有一些优势:</p><ul><li>减少了客户端和master的交互：读和写在同一个chunk上只需要一次初始化的对master的请求，得到chunk的位置信息。这对我们的文件系统来说是很重要的，因为从上面的假设中我们可以知道应用程序通常会顺序读写大文件，就算有小文件操作，客户端也可以将这些小文件所在的chunk的位置信息给缓存下来。</li><li>因为是大chunk，所以可以在同一个chunk上做更多的操作，这样就可以减少网络开销（通过保持TCP长连接）。</li><li>因为大chunk，所以chunk的数量少了，这样master中metadata的数量也少了，所以有利于我们将metadata放在master的内存里（更快）。</li></ul><p>也有一些缺点：</p><ul><li>一个小文件可能只占用一个或几个chunk，如果许多client都访问同一个文件，那么那个chunk可能就成为了热点。在实际中，热点并不是一个主要问题，因为我们的应用程序大多按顺序读取大型多块文件。</li></ul><h4 id="2-6-Metadata"><a href="#2-6-Metadata" class="headerlink" title="2.6 Metadata"></a>2.6 Metadata</h4><p>master存储了三种类型的metadata:</p><ul><li>the file and chunk namespaces</li><li>the mapping from files to chunks</li><li>the locations of each chunk’s replicas</li></ul><p>所有metadata都保存在master的内存中。</p><p>master不会持续存储chunk的位置信息。相反，它在master启动后，当有chunk服务器加入集群时，询问每个chunk服务器关于它上面的每个chunk的信息。</p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.824</tag>
      
      <tag>分布式系统</tag>
      
      <tag>大型存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-Channel详解</title>
    <link href="/2023/09/25/Go-Channel%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/09/25/Go-Channel%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Channel详解"><a href="#Go-Channel详解" class="headerlink" title="Go Channel详解"></a>Go Channel详解</h1><p>Channel是GO中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。</p><p>它的操作符是箭头 &lt;- 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- v <span class="hljs-comment">// 发送值v到Channel ch中</span><br>v := &lt;-ch <span class="hljs-comment">// 从Channel ch中接受数据 并将数据赋值给v</span><br></code></pre></td></tr></table></figure><p>(箭头的指向就是数据的流向)</p><p>就像 map 和 slice 数据类型一样, channel必须先创建再使用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h3 id="Channel类型"><a href="#Channel类型" class="headerlink" title="Channel类型"></a>Channel类型</h3><p>Channel类型的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ChannelType = ( <span class="hljs-string">&quot;chan&quot;</span> | <span class="hljs-string">&quot;chan&quot;</span> <span class="hljs-string">&quot;&lt;-&quot;</span> | <span class="hljs-string">&quot;&lt;-&quot;</span> <span class="hljs-string">&quot;chan&quot;</span> ) ElementType .<br></code></pre></td></tr></table></figure><p>它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span> T          <span class="hljs-comment">// 可以接收和发送类型为 T 的数据</span><br><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">float64</span>  <span class="hljs-comment">// 只可以用来发送 float64 类型的数据</span><br>&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>      <span class="hljs-comment">// 只可以用来接收 int 类型的数据</span><br></code></pre></td></tr></table></figure><p>&lt;-总是优先和最左边的类型结合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>    <span class="hljs-comment">// 等价 chan&lt;- (chan int)</span><br><span class="hljs-keyword">chan</span>&lt;- &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>  <span class="hljs-comment">// 等价 chan&lt;- (&lt;-chan int)</span><br>&lt;-<span class="hljs-keyword">chan</span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>  <span class="hljs-comment">// 等价 &lt;-chan (&lt;-chan int)</span><br><span class="hljs-keyword">chan</span> (&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>使用make初始化Channel,并且可以设置容量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。<br>如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p><p>可以通过内建的close方法可以关闭Channel。</p><p>可以在多个goroutine从&#x2F;往 一个channel 中 receive&#x2F;send 数据, 不必考虑额外的同步措施。</p><p>Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。</p><p>channel的 receive支持 multi-valued assignment，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p>它可以用来检查Channel是否已经被关闭了。</p><ul><li>send语句</li></ul><p>send语句用来往Channel中发送数据， 如ch &lt;- 3。<br>它的定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">SendStmt = Channel <span class="hljs-string">&quot;&lt;-&quot;</span> Expression .<br>Channel  = Expression .<br></code></pre></td></tr></table></figure><p>在通讯(communication)开始前channel和expression必须先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(c)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- <span class="hljs-number">3</span> + <span class="hljs-number">4</span> &#125;()<br>i := &lt;-c<br>fmt.Println(i)<br></code></pre></td></tr></table></figure><p>send被执行前(proceed)通讯(communication)一直被阻塞着。无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且接收方的缓存未满，则send会被执行。</p><p>往一个已经被close的channel中继续发送数据会导致 run-time panic </p><ul><li>receive语句</li></ul><p> <code>&lt;-</code> 用来从Channel ch中接收数据，这个表达式会一直被block，直到有数据可以接收</p><p>从一个nil channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。</p><p>我们可以使用一个额外的返回参数来检查Channel是否关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-ch<br>x, ok = &lt;-ch<br><span class="hljs-keyword">var</span> x, ok = &lt;-ch<br></code></pre></td></tr></table></figure><p>如果OK是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。</p><h3 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h3><p>在缺省条件下，发送和接收会一直被阻塞，直到另外一方准备好。用这种方法可以在goroutines中进行同步，而不用使用显示的锁或者条件变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>sum += v<br>&#125;<br>c &lt;- sum <span class="hljs-comment">// send sum to c</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> sum(s[:<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>], c)<br><span class="hljs-keyword">go</span> sum(s[<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>:], c)<br>x, y := &lt;-c, &lt;-c <span class="hljs-comment">// receive from c</span><br>fmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述main函数中的这句<code>x, y := &lt;-c, &lt;-c // receive from c</code>会一直等待计算结果发送到channel中去。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>make的第二个参数指定缓存的大小，如: <code>ch := make(chan int, 100)</code></p><p>通过缓存的作用，可以尽量避免阻塞，提供应用的性能。</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mit6.824(1)——MapReduce</title>
    <link href="/2023/09/25/Mit6.824(1)%E2%80%94%E2%80%94MapReduce/"/>
    <url>/2023/09/25/Mit6.824(1)%E2%80%94%E2%80%94MapReduce/</url>
    
    <content type="html"><![CDATA[<h2 id="零、-前言"><a href="#零、-前言" class="headerlink" title="零、 前言"></a>零、 前言</h2><ul><li>此篇为MIT6.824的第一个Lab(MapReduce)，记录下来是为了让自己的学习不要走马观花的简单过一遍，而是要真正弄明白Lab中间运用到的有关go的东西和分布式系统的核心思想。</li></ul><h2 id="一、-Lab正文"><a href="#一、-Lab正文" class="headerlink" title="一、 Lab正文"></a>一、 Lab正文</h2><h3 id="1-一些重要的提示"><a href="#1-一些重要的提示" class="headerlink" title="1.一些重要的提示:"></a>1.一些重要的提示:</h3><ul><li><strong>对于调试用fmt直接在终端中打印出来更为方便，比使用golang调试要方便很多</strong></li><li>每次变更mr包下代码的时候最好重新编译wc.go，以防编译报找不到插件。</li><li>可以大量借鉴mrsequential.go中的代码</li><li>main&#x2F;mrcoordinator.go期望mr&#x2F;coordinator.go实现一个 Done()方法，该方法在 MapReduce 作业完全完成时返回 true；此时，mrcoordinator.go将退出。</li><li>worker的map方法用json存储中间kv对，reduce再读回来，因为真正分布式worker都不在一个机器上，涉及网络传输，所以用json编码解码走个过场。</li><li>worker的map可以用 worker.go里面的ihash(key)得到特定key的reduce任务号。</li><li>对于任务的并发可以实现chan，是个天然的并发安全队列。</li></ul><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p>首先来看Lab提供的论文中的图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924105147741.png" alt="image-20230924105147741"></p><ul><li>可以看出大致MapReduce的流程：启动一个Master(Coordinator协调者)分配多个任务给worker做Map任务。</li><li>然后Worker完成Map任务后返回中间值一组KV,接着协调者再将这些KV分发给后继的Worker根据KV进行Reduce任务，最后对Reduce进行一个总的处理进行返回。</li></ul><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><h4 id="3-1-完成Coordinator与Worker之间的交互"><a href="#3-1-完成Coordinator与Worker之间的交互" class="headerlink" title="3.1 完成Coordinator与Worker之间的交互"></a>3.1 完成Coordinator与Worker之间的交互</h4><p>Coordinator分配Map任务给Worker，所有的Map task都被Worker做完后，我们就将流程终止，这里先假设没有Reduce task。</p><p>在写自己的代码之前，我们先要弄清楚原本给的代码框架的函数调用流程。</p><p>在mrcoordinator.go的main函数中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) &lt; <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Usage: mrcoordinator inputfiles...\n&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>m := mr.MakeCoordinator(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> m.Done() == <span class="hljs-literal">false</span> &#123;<br>time.Sleep(time.Second)<br>&#125;<br><br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>调用mr文件夹下的MakeCoordinator函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;<br>c := Coordinator&#123;&#125;<br><span class="hljs-comment">// Your code here.</span><br>c.server()<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数创建一个Coordinator结构体，并调用server()函数，server函数start a thread that listens for RPCs from worker.go</p><p>在mrworker.go的main函数中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) != <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Usage: mrworker xxx.so\n&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>mapf, reducef := loadPlugin(os.Args[<span class="hljs-number">1</span>])<br><br>mr.Worker(mapf, reducef)<br>&#125;<br></code></pre></td></tr></table></figure><p>调用mr文件夹中的Worker函数，传入两个函数，mapf和reducef，这两个函数是使用loadPlugin加载得到的。</p><p>在Worker函数中调用CallExample()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,<br>reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br><br><span class="hljs-comment">// Your worker implementation here.</span><br><br><span class="hljs-comment">// uncomment to send the Example RPC to the coordinator.</span><br>CallExample()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallExample</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// declare an argument structure.</span><br>args := ExampleArgs&#123;&#125;<br><br><span class="hljs-comment">// fill in the argument(s).</span><br>args.X = <span class="hljs-number">99</span><br><br><span class="hljs-comment">// declare a reply structure.</span><br>reply := ExampleReply&#123;&#125;<br><br><span class="hljs-comment">// send the RPC request, wait for the reply.</span><br><span class="hljs-comment">// the &quot;Coordinator.Example&quot; tells the</span><br><span class="hljs-comment">// receiving server that we&#x27;d like to call</span><br><span class="hljs-comment">// the Example() method of struct Coordinator.</span><br>ok := call(<span class="hljs-string">&quot;Coordinator.Example&quot;</span>, &amp;args, &amp;reply)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-comment">// reply.Y should be 100.</span><br>fmt.Printf(<span class="hljs-string">&quot;reply.Y %v\n&quot;</span>, reply.Y)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;call failed!\n&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数将args定义为结构体ExampleArgs{}，并将ExampleArgs{}中的X赋初值为99，<code>ok := call(&quot;Coordinator.Example&quot;, &amp;args, &amp;reply)</code>这句调用Coordinator.go中的Example函数。这里有一个细节，<strong>函数名开头为大写的表示可以被外部所调用</strong>。（为什么传值是指针: <a href="Golang%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.md">Golang指针的应用场景</a>）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Example(args *ExampleArgs, reply *ExampleReply) <span class="hljs-type">error</span> &#123;<br>reply.Y = args.X + <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Example函数将传进来的args.X + 1赋值给reply.Y，调用返回之后，在Worker.go的CallExample函数中打印出reply.Y的值，然后worker结束工作。</p><p>清楚了以上流程，我们可以运行看一下结果是不是符合我们的分析。在一个项目的<code>src/main</code>目录下运行<code>go run mrcoordinator.go pg-*</code>，并在另一个终端中运行<code>go run mrwoker.go wc.so</code>，这里注意在run mrwoker.go之前需要先将.so文件加载进来，使用<code>go build -buildmode=plugin ../mrapps/wc.go</code>(在src&#x2F;main文件夹下)</p><p>然后我们就可以看到跑mrwoker.go的终端会有如下打印:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230926224810846.png" alt="image-20230926224810846"></p><p>但是mrcoordinator一直都不会退出，我们可以将Coordinator.go中的Done函数改为如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Done() <span class="hljs-type">bool</span> &#123;<br>ret := <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// Your code here.</span><br><br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>即将第2行改为true，这样在mrcoordinator.go的main函数中就不会一直在循环中(下面代码块的第8行):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) &lt; <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Usage: mrcoordinator inputfiles...\n&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>m := mr.MakeCoordinator(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> m.Done() == <span class="hljs-literal">false</span> &#123;<br>time.Sleep(time.Second)<br>&#125;<br><br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上我们看懂了项目中简单的RPC交互，现在我们可以自己实现一个RPC来做Map任务。</p><p>参考ExampleArgs和ExampleReply，我们自己实现一些结构体用来传递任务;</p><p>先进行一些思考:</p><p>对于一个任务来说，我们需要知道它的一些信息，比如任务类型，任务编号(唯一)，如果它是一个map task，我们需要知道它要将一个文件分成几个临时文件让reduce worker去做，最后文件的名称(对于map task来说 就是一个 对于reduce task来说 是好几个中间文件)</p><p>我们将任务分为四种，它们分别是MapTask, ReduceTask, WaitingTask, ExitTask</p><p>下面是代码实现，在worker.go中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>TaskType   TaskType <span class="hljs-comment">// 表示当前这个任务是干什么的 可选的任务类型有 MapTask ReduceTask WaitingTask ExitTask</span><br>TaskId     <span class="hljs-type">int</span>      <span class="hljs-comment">// 当前任务的id 所有任务的TaskId都是不同的</span><br>ReducerNum <span class="hljs-type">int</span>      <span class="hljs-comment">// 做reduce任务的woker数量 在hash的时候要用到 需要用它来%</span><br>FileNames  []<span class="hljs-type">string</span> <span class="hljs-comment">// 对于map task来说 传入的就是一个文件的名字 但是对于reduce task来说 传入的是多个文件的名称 所以对于map task 来说 我们处理第一个下标的就好</span><br>&#125;<br><br><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 四种task</span><br><span class="hljs-keyword">const</span> (<br>MapTask     TaskType = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 表示这个worker要去做Map task</span><br>ReduceTask                  <span class="hljs-comment">// 表示这个woker要去做Reduce task</span><br>WaitingTask                 <span class="hljs-comment">// 表示需要做的任务都分配出去了 但是这些任务还没有完成 当前这个worker等待就好</span><br>ExitTask                    <span class="hljs-comment">// 表示所有的任务都做完了 worker可以退出了</span><br>)<br></code></pre></td></tr></table></figure><p>首先我们来实现woker.go中的内容。运行mrworker.go时，它会调用Worker.go中的woker函数，我们知道，worker是用来做任务的，而它的任务是需要Coordinator分配给它的，所以首先需要调用RPC请求coordinator.go分配一个任务给当前这个woker，然后判断分配给这个worker的是什么类型的任务，根据不同的任务类型，我们需要做不同的事情，所以我们用一个switch-case语句并将要做的事情封装成函数更好地实现。</p><ul><li><p>调用getTask()函数让coordinator为当前这个worker分配一个任务:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTask</span><span class="hljs-params">()</span></span> Task &#123;<br>args := ExampleArgs&#123;&#125;<br>reply := Task&#123;&#125;<br><br>ok := call(<span class="hljs-string">&quot;Coordinator.AssignTask&quot;</span>, &amp;args, &amp;reply)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Coordinator assigned a task, and it is a %d task\n&quot;</span>, reply.TaskType)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;call failed!\n&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> reply<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们先考虑worker做map task: 将它封装成两个函数(1)doMapTask() (2)callDone()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> MapTask:<br>&#123;<br>    doMapTask(mapf, &amp;task) <span class="hljs-comment">// 如果是maptask 那么这个woker就去做map task</span><br>    callDone(&amp;task)        <span class="hljs-comment">// 做完了 需要将这个任务标记为做完了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>doMapTask()函数主要参考mrsequential.go中的代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 首先明确map task是在做什么</span><br><span class="hljs-comment">// 一个map task将一个传进来的文件分成ReducerNum个中间文件 这些中间文件里面的内容是一个一个的键值对 这个时候还没有排序</span><br><span class="hljs-comment">// 比如现在传进来一个文件 我们用一个woker去做这个任务(这个woker的编号是1)在做map task 定义了10个ReducerNum 那么它就会生成下面这些文件</span><br><span class="hljs-comment">// mr-tmp-0-0 mr-tmp-0-1 mr-tmp-0-2 ... mr-tmp-0-9</span><br><span class="hljs-comment">// 下面的代码主要参考mrsequential.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doMapTask</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, task *Task) &#123;<br>filename := task.FileNames[<span class="hljs-number">0</span>]<br><br>file, err := os.Open(filename) <span class="hljs-comment">// 对于map reduce来说 我们只关心FileSlice中的第一个file</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Cannot open %v&quot;</span>, filename)<br>&#125;<br>content, err := ioutil.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Cannot read %v&quot;</span>, filename)<br>&#125;<br>file.Close()<br><br><span class="hljs-comment">// 下面对从filename中取出来的content做map操作</span><br>intermediate := mapf(filename, <span class="hljs-type">string</span>(content))<br><br>reducerNum := task.ReducerNum<br><br>hashBuckets := <span class="hljs-built_in">make</span>([][]KeyValue, reducerNum) <span class="hljs-comment">// 构造一个hash桶 有reducerNum个 每个里面都是很多的KeyValue对</span><br><br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> intermediate &#123;<br>hashBuckets[ihash(kv.Key)%reducerNum] = <span class="hljs-built_in">append</span>(hashBuckets[ihash(kv.Key)%reducerNum], kv)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; reducerNum; i++ &#123;<br>oname := <span class="hljs-string">&quot;mr-tmp-&quot;</span> + strconv.Itoa(task.TaskId) + <span class="hljs-string">&quot;-&quot;</span> + strconv.Itoa(i)<br>ofile, _ := os.Create(oname)<br>enc := json.NewEncoder(ofile)<br><span class="hljs-comment">// 编码进这个文件中</span><br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> hashBuckets[i] &#123;<br>enc.Encode(kv)<br>&#125;<br>ofile.Close()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>callDone()函数调用RPC，将这个任务标记为做完了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// call RPC将这个任务标记为做完了</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">callDone</span><span class="hljs-params">(task *Task)</span></span> &#123;<br>args := task<br>reply := Task&#123;&#125;<br><br>ok := call(<span class="hljs-string">&quot;Coordinator.MarkFinished&quot;</span>, &amp;args, &amp;reply)<br><br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task %d finished.\n&quot;</span>, task.TaskId)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Call failed in callDone\n&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里先不管worker做reduce task的情况，整体流程能跑通，之后再进行补充。所以我们再考虑worker被分配到的任务类型是WaitingTask:</p><p>如果是WaitingTask，那就让它等待就好了，所以我们调用time.Sleep()函数让worker等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> WaitingTask:<br>&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;All tasks are in progress! Task %d is waiting.\n&quot;</span>, task.TaskId)<br>    time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后我们考虑worker被分配到的类型是ExitTask:</p><p>这里意味着所有的任务都做完了,Worker可以结束了，所以我们将workingFlag置为false，使得它能够跳出循环，并打印出当前这个任务已经结束了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> ExitTask:<br>&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Task %d is terminated...&quot;</span>, task.TaskId)<br>    workingFlag = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>所以目前的Worker函数是这样的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//</span><br><span class="hljs-comment">// main/mrworker.go calls this function.</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br>workingFlag := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> workingFlag &#123;<br>task := getTask() <span class="hljs-comment">// 请求Coordinator分配一个任务</span><br><span class="hljs-keyword">switch</span> task.TaskType &#123;<br><span class="hljs-keyword">case</span> MapTask:<br>&#123;<br>doMapTask(mapf, &amp;task) <span class="hljs-comment">// 如果是maptask 那么这个woker就去做map task</span><br>callDone(&amp;task)        <span class="hljs-comment">// 做完了 需要将这个任务标记为做完了</span><br>&#125;<br><span class="hljs-keyword">case</span> ReduceTask:<br>&#123;<br><br>&#125;<br><span class="hljs-keyword">case</span> WaitingTask:<br>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;All tasks are in progress! Task %d is waiting.\n&quot;</span>, task.TaskId)<br>time.Sleep(time.Second)<br>&#125;<br><span class="hljs-keyword">case</span> ExitTask:<br>&#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task %d is terminated...\n&quot;</span>, task.TaskId)<br>workingFlag = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">default</span>:<br>&#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;undefined TaskType!!!&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来去Coordinator.go中完善方法</strong></p><p>首先思考Coordinator结构体中需要哪些成员？</p><p>需要有一个变量记录Coordinator将会分配几个Worker去做reduce task，所以需要有一个变量ReducerNum记录；它需要为Worker分配任务，我们用Coordinator来决定它给Worker分配的TaskId是多少；我们需要用一个成员变量来记录当前的Coordinator进行到哪一个阶段了（会有三个阶段: 分发MapTask、分发ReduceTask、所有任务都已经完成）；用一个队列来存放已经被coordinator制作出来，还没有被worker执行的Map Task，再用一个队列存放已经被coordinator制作出来，还没有被worker执行的Reduce Task，由于要保证并发安全，所以我们使用channel来保证这件事。</p><p>考虑如何判断当前的阶段已经执行完毕？是否需要进入下一个阶段？这里用一个TaskHolder来实现。</p><p>什么是TaskHolder，简单来说就是一个装入所有task的一个队列。worker不会从这里面取用task，但是这里面记录着所有task的信息。</p><p>我们要判断是否要进入下一个阶段，只要判断TaskHolder中是不是所有属于当前阶段的task都已经是Done状态了，如果是的话，那就可以进入下一个阶段了。</p><p>初步想法是将结构体Coodinator定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br>ReducerNum        <span class="hljs-type">int</span>        <span class="hljs-comment">// 记录Coordinator准备分配几个Reducer</span><br>TaskId            <span class="hljs-type">int</span>        <span class="hljs-comment">// 记录下一个分配的任务的taskid</span><br>DistPhase         Phase      <span class="hljs-comment">// 记录当前分配任务的阶段</span><br>MapTaskChannel    <span class="hljs-keyword">chan</span> *Task <span class="hljs-comment">// 存放分配出去的Map task</span><br>ReduceTaskChannel <span class="hljs-keyword">chan</span> *Task <span class="hljs-comment">// 存放分配出去的Reduce task</span><br><br>TaskHolder TaskHolder <span class="hljs-comment">// 存放所有的task</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Phase <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapPhase Phase = <span class="hljs-literal">iota</span><br>ReducePhase<br>Alldone<br>)<br><br><span class="hljs-keyword">type</span> TaskHolder <span class="hljs-keyword">struct</span> &#123;<br>Meta <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*TaskInfo<br>&#125;<br><br><span class="hljs-keyword">type</span> TaskInfo <span class="hljs-keyword">struct</span> &#123;<br>TaskStatus TaskStatus <span class="hljs-comment">// 当前task的状态 有三种 正在执行 等待被执行 执行完毕</span><br>TaskAddr   *Task      <span class="hljs-comment">// 当前task的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还需要一些变量来表示一个任务的状态，对于一个任务来说，它可以有三种状态: 分别是(1)某一个worker正在做这个任务 (2)这个任务正在等待被某一个worker执行 (3)这个任务已经被某一个worker执行完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TaskStatus <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>Operating TaskStatus = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 表示这个任务正在被某一个worker执行</span><br>Waiting                     <span class="hljs-comment">// 表示这个任务等待被某一个worker执行</span><br>Done                        <span class="hljs-comment">// 表示这个任务已经被执行完毕</span><br>)<br></code></pre></td></tr></table></figure><p>接着去完善MakeCoordinator()函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;<br>c := Coordinator&#123;<br>ReducerNum:        nReduce,<br>TaskId:            <span class="hljs-number">0</span>,<br>DistPhase:         MapPhase,<br>MapTaskChannel:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, <span class="hljs-built_in">len</span>(files)),<br>ReduceTaskChannel: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, nReduce),<br><br>TaskHolder: TaskHolder&#123;<br>Meta: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*TaskInfo, <span class="hljs-built_in">len</span>(files)+nReduce), <span class="hljs-comment">// task的数量是所有map的数量 + reduce的数量</span><br>&#125;,<br>&#125;<br>    <br>c.makeMapTasks(files)<br>c.server()<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的函数中，我们将结构体中的变量初始化成我们刚刚思考的那样，然后调用makeMapTasks让Coordinator去创建MapTasks:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对传进来的files进行处理，将每一个文件名都初始化成一个map task</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> makeMapTasks(files []<span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>mapTaskId := c.genTaskId() <span class="hljs-comment">// coordinator分配唯一的任务编号</span><br>task := Task&#123;<br>TaskType:   MapTask,<br>TaskId:     mapTaskId,<br>ReducerNum: c.ReducerNum,<br>FileNames:  []<span class="hljs-type">string</span>&#123;file&#125;, <span class="hljs-comment">// 一个字符串数组 并将第一个初始化为file</span><br>&#125;<br><br>c.TaskHolder.AcceptTask(&amp;task)<br>fmt.Printf(<span class="hljs-string">&quot;The Coordinator makes a map task, which task id is %d\n&quot;</span>, task.TaskId)<br>c.MapTaskChannel &lt;- &amp;task<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> genTaskId() <span class="hljs-type">int</span> &#123;<br>ret := c.TaskId <span class="hljs-comment">// 将当前这个数字分配出去</span><br>c.TaskId++      <span class="hljs-comment">// 下一个任务的id</span><br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来实现Coordinator分配任务的方法</strong></p><p>首先将<code>makeMapTasks</code>中放进<code>MapTaskChannel</code>中的map task取出，如果取不出来，<strong>说明已经生成的map task都已经worker在做或者已经做完了</strong>。coordinator判断当前阶段的任务是不是已经都做完了，做完了的话，就让Coordinator进入下一阶段。因为我们需要检测所有任务的状态，所以我们用一个容器来装所有的task，这个容器我使用map实现。因为先处理Map操作，所以这里先不管Reduce，只考虑两个阶段: MapPhase和Alldone</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Coordinator分配任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> AssignTask(args *ExampleArgs, reply *Task) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 分配任务的时候应该上锁 防止多个worker竞争同一个task 并使用defer回退解锁</span><br><span class="hljs-comment">// mu.Lock()</span><br><span class="hljs-comment">// defer mu.Unlock()</span><br><br><span class="hljs-keyword">switch</span> c.DistPhase &#123;<br><span class="hljs-keyword">case</span> MapPhase: <span class="hljs-comment">// 如果是MapPhase 那么需要给这个worker分配map任务 需要从MapTaskChannel中取出来</span><br>&#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.MapTaskChannel) &gt; <span class="hljs-number">0</span> &#123;<br>*reply = *&lt;-c.MapTaskChannel <span class="hljs-comment">// 相当于从队头取出一个task给这个worker</span><br>taskId := reply.TaskId<br>taskStatus := c.getTaskStatus(taskId)<br><span class="hljs-keyword">if</span> taskStatus == Operating &#123; <span class="hljs-comment">// 这个任务正在执行</span><br>fmt.Printf(<span class="hljs-string">&quot;The task %d is already running.\n&quot;</span>, taskId)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskStatus == Waiting &#123; <span class="hljs-comment">// 这个任务正在等待被执行</span><br>c.setTaskStatus(taskId)<br>fmt.Printf(<span class="hljs-string">&quot;The task %d begin to run.\n&quot;</span>, taskId)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskStatus == Done &#123; <span class="hljs-comment">// 这个任务已经被执行完毕了</span><br>fmt.Printf(<span class="hljs-string">&quot;The task %d is done.\n&quot;</span>, taskId)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有任务了 说明任务都在被做 或者已经做完了 就把这个worker设置为Waiting</span><br>reply.TaskType = WaitingTask<br><span class="hljs-keyword">if</span> c.checkAllTaskDone() &#123;<br>c.toNextPhase()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> Alldone:<br>&#123;<br>reply.TaskType = ExitTask<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有任务还在等待被执行，那么我们就要看看分配出去的任务是不是都已经被做完了，如果都已经被做完了，那就可以进行到下一个阶段了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> checkAllTaskDone() <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 检查是不是所有当前阶段的任务都完成了 这里的任务只有两种状态 一种是正在执行 一种是已经做完了 不可能有等待执行的任务</span><br><span class="hljs-keyword">var</span> (<br>taskMapDoneCnt      = <span class="hljs-number">0</span><br>taskMapUnDoneCnt    = <span class="hljs-number">0</span><br>taskReduceDoneCnt   = <span class="hljs-number">0</span><br>taskReduceUnDoneCnt = <span class="hljs-number">0</span><br>)<br>taskHolder := c.TaskHolder<br><span class="hljs-keyword">for</span> _, taskInfo := <span class="hljs-keyword">range</span> taskHolder.Meta &#123;<br><span class="hljs-keyword">if</span> taskInfo.TaskAddr.TaskType == MapTask &#123;<br><span class="hljs-keyword">if</span> taskInfo.TaskStatus == Done &#123;<br>taskMapDoneCnt++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>taskMapUnDoneCnt++<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskInfo.TaskAddr.TaskType == ReduceTask &#123;<br><span class="hljs-keyword">if</span> taskInfo.TaskStatus == Done &#123;<br>taskReduceDoneCnt++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>taskReduceUnDoneCnt++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (taskMapDoneCnt &gt; <span class="hljs-number">0</span> &amp;&amp; taskMapUnDoneCnt == <span class="hljs-number">0</span>) &amp;&amp; (taskReduceDoneCnt == <span class="hljs-number">0</span> &amp;&amp; taskReduceUnDoneCnt == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// reduce任务还没有开始做</span><br><span class="hljs-comment">// map tasks all done</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskReduceDoneCnt &gt; <span class="hljs-number">0</span> &amp;&amp; taskReduceUnDoneCnt == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// reduce任务做完了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在checkAllTaskDone()函数中，我们将两个种类(MapTask和ReduceTask)的任务完成和未完成的情况计数，并在最后根据这个数量判断当前阶段的任务是不是都执行完毕了。如果都执行完毕了，就调用toNextPhase()去下一个阶段，但是为了先实现整体的流程，在MapPhase阶段之后，我们直接让Coordinator进入Alldone阶段:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> toNextPhase() &#123;<br><span class="hljs-keyword">switch</span> c.DistPhase &#123;<br><span class="hljs-keyword">case</span> MapPhase:<br>&#123;<br>c.DistPhase = Alldone<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">case</span> ReducePhase:<br>&#123;<br>c.DistPhase = Alldone<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">case</span> Alldone:<br>&#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">default</span>:<br>&#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Undefined Phase!\n&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于getTaskStatus()和setTaskStatus()这两个函数，前者通过唯一的taskId编号获取到在TaskHolder中的task，并得到这个task的状态，根据不同的task状态，这个task需要做不同的事情，如果这个task的状态是正在执行或者已经执行完毕了，那就终端打印出来提醒；如果这个task是在等待执行，那就将这个task的状态置为Operating，表示现在让这个task开始被执行。</p><p>最后还需要实现一下MarkFinished函数，在Coordinator.go中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> MarkFinished(args *Task, reply *Task) <span class="hljs-type">error</span> &#123;<br>taskId := args.TaskId<br>taskHolder := c.TaskHolder.Meta<br>taskInfo := taskHolder[taskId]<br><span class="hljs-keyword">if</span> taskInfo == <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The task %d is not exists.\n&quot;</span>, taskId)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskInfo.TaskStatus == Operating &#123;<br>taskInfo.TaskStatus = Done<br>fmt.Printf(<span class="hljs-string">&quot;The task %d is done.\n&quot;</span>, taskId)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskInfo.TaskStatus == Done &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The task %d is done before.\n&quot;</span>, taskId)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskInfo.TaskStatus == Waiting &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The task %d&#x27;s status should not be here.\n&quot;</span>, taskId)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过传入的args获取到唯一的TaskId，然后通过该Task的不同状态给出对应的措施。只有在当前task的状态是Operating的时候才将这个task的状态更改为Done，其他的情况都打印出对应的提示信息。</p><p>以上都完成以后，我们就可以在终端运行:</p><p>打开一个终端，输入:<code>go run mrcoordinator.go pg-being_ernest.txt pg-frankenstein.txt</code>先尝试使用两个文件，再在另一个终端输入<code>go run mrworker.go wc.so</code>，但是在那之前，我们需要先加载wc.so <code>go build -buildmode=plugin/mrapps/wc.go</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230930173412992.png" alt="image-20230930173412992"></p><p>然后我们可以去看一下生成的tmp文件是什么:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230930173453522.png" alt="image-20230930173453522"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230930173823191.png" alt="image-20230930173823191"></p><p>可以看到生成的文件就像我们分析的那样，因为有两个文件，所以第一个数字的下标是0、1，有10个Reducer，所以第二个数字的下标是0~9。</p><p>临时文件的内容是若干键值对。</p><h4 id="3-2-在上述基础上补充reduce阶段，并进行相应的处理"><a href="#3-2-在上述基础上补充reduce阶段，并进行相应的处理" class="headerlink" title="3.2 在上述基础上补充reduce阶段，并进行相应的处理"></a>3.2 在上述基础上补充reduce阶段，并进行相应的处理</h4><p>和makeMapTask类似，写一个函数makeReduceTasks:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> makeReduceTasks() &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; c.ReducerNum; i++ &#123;<br>id := c.genTaskId()<br>task := Task&#123;<br>TaskType:  ReduceTask,<br>TaskId:    id,<br>FileNames: selectReduceName(i), <span class="hljs-comment">// 选择这个reduce task需要传入的临时文件的名称</span><br>&#125;<br><br>c.TaskHolder.AcceptTask(&amp;task) <span class="hljs-comment">// 将task放进TaskHolder中</span><br>fmt.Printf(<span class="hljs-string">&quot;The coordinator makes a reduce task, which task id is %d\n&quot;</span>, task.TaskId)<br>c.ReduceTaskChannel &lt;- &amp;task<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现上述的selectReduceName，该函数以当前这个reducer的id为传入参数，返回的是当前这个路径下所有文件名称为”mr-tmp-*-reducerId”的文件名:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectReduceName</span><span class="hljs-params">(reducerId <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> ret []<span class="hljs-type">string</span><br>path, _ := os.Getwd()<br>fileInfos, _ := ioutil.ReadDir(path)<br><span class="hljs-keyword">for</span> _, fileInfo := <span class="hljs-keyword">range</span> fileInfos &#123;<br><span class="hljs-keyword">if</span> strings.HasPrefix(fileInfo.Name(), <span class="hljs-string">&quot;mr-tmp&quot;</span>) &amp;&amp; strings.HasSuffix(fileInfo.Name(), strconv.Itoa(reducerId)) &#123;<br>ret = <span class="hljs-built_in">append</span>(ret, fileInfo.Name())<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来补充AssignTask函数中ReducePhase的部分:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> ReducePhase:<br>&#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.ReduceTaskChannel) &gt; <span class="hljs-number">0</span> &#123;<br>        *reply = *&lt;-c.ReduceTaskChannel<br>        taskId := reply.TaskId<br>        taskStatus := c.getTaskStatus(taskId)<br>        <span class="hljs-keyword">if</span> taskStatus == Operating &#123; <span class="hljs-comment">// 这个任务正在执行</span><br>            fmt.Printf(<span class="hljs-string">&quot;The task %d is already running.\n&quot;</span>, taskId)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskStatus == Waiting &#123; <span class="hljs-comment">// 这个任务正在等待被执行</span><br>            c.setTaskStatus(taskId)<br>            fmt.Printf(<span class="hljs-string">&quot;The task %d begins to run.\n&quot;</span>, taskId)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskStatus == Done &#123; <span class="hljs-comment">// 这个任务已经被执行完毕了</span><br>            fmt.Printf(<span class="hljs-string">&quot;The task %d is done.\n&quot;</span>, taskId)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        reply.TaskType = WaitingTask<br>        <span class="hljs-keyword">if</span> c.checkAllTaskDone() &#123;<br>            c.toNextPhase()<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>补充worker.go中处理reduceTask的部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> ReduceTask:<br>&#123;<br>    doReduceTask(reducef, &amp;task)<br>    callDone(&amp;task)<br>&#125;<br></code></pre></td></tr></table></figure><p>参考mrsequential.go实现函数doReduceTask:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 参考mrsequence.go编写该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doReduceTask</span><span class="hljs-params">(reducef <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>, task *Task) &#123;<br>fileNames := task.FileNames<br>intermediate := sortContent(fileNames) <span class="hljs-comment">// 返回的是排好序的键值对</span><br>dir, _ := os.Getwd()<br>tempFile, err := ioutil.TempFile(dir, <span class="hljs-string">&quot;mr-tmp-*&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to create temp file&quot;</span>, err)<br>&#125;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(intermediate) &#123;<br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;<br>j++<br>&#125;<br>values := []<span class="hljs-type">string</span>&#123;&#125;<br><span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;<br>values = <span class="hljs-built_in">append</span>(values, intermediate[k].Value)<br>&#125;<br>output := reducef(intermediate[i].Key, values)<br><br><span class="hljs-comment">// this is the correct format for each line of Reduce output.</span><br>fmt.Fprintf(tempFile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)<br>i = j<br>&#125;<br>tempFile.Close()<br>fileName := fmt.Sprintf(<span class="hljs-string">&quot;mr-out-%d&quot;</span>, task.TaskId)<br>os.Rename(tempFile.Name(), fileName)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个reducer输出的文件为mr-out-reducerId</p><p>sortContent函数传入一系列文件的名称，将这些文件中的内容全部放进一个键值对序列中，并排好序（这些文件的内容也是键值对），</p><p>所以intermediate的内容就是一个排好序的键值对序列:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortContent</span><span class="hljs-params">(fileNames []<span class="hljs-type">string</span>)</span></span> []KeyValue &#123;<br><span class="hljs-keyword">var</span> ret []KeyValue<br><span class="hljs-keyword">for</span> _, fileName := <span class="hljs-keyword">range</span> fileNames &#123;<br>file, _ := os.Open(fileName)<br>dec := json.NewDecoder(file)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> kv KeyValue<br><span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ret = <span class="hljs-built_in">append</span>(ret, kv)<br>&#125;<br>file.Close()<br>&#125;<br>sort.Sort(ByKey(ret))<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，运行：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231001211152720.png" alt="image-20231001211152720"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231001211205054.png" alt="image-20231001211205054"></p><p>看一下文件中的内容:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231001211358272.png" alt="image-20231001211358272"></p><h4 id="3-3-尝试跑一下测试"><a href="#3-3-尝试跑一下测试" class="headerlink" title="3.3 尝试跑一下测试"></a>3.3 尝试跑一下测试</h4><p>在<code>/home/rong/Codespace/6.5840/src/main</code>目录下运行:</p><p><code>bash test-mr.sh &gt; output</code>将输出结果保存到output中去</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">--- crash output is not the same as mr-correct-crash.txt<br>--- crash test: FAIL<br>*** FAILED SOME TESTS<br></code></pre></td></tr></table></figure><p>测到crash的时候出错了T^T</p><p>然后去找是哪里出了问题</p><p>看看crash.go文件在干什么:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// a MapReduce pseudo-application that sometimes crashes,</span><br><span class="hljs-comment">// and sometimes takes a long time,</span><br><span class="hljs-comment">// to test MapReduce&#x27;s ability to recover.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// go build -buildmode=plugin crash.go</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;6.5840/mr&quot;</span><br><span class="hljs-keyword">import</span> crand <span class="hljs-string">&quot;crypto/rand&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math/big&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maybeCrash</span><span class="hljs-params">()</span></span> &#123;<br>max := big.NewInt(<span class="hljs-number">1000</span>)<br>rr, _ := crand.Int(crand.Reader, max)<br><span class="hljs-keyword">if</span> rr.Int64() &lt; <span class="hljs-number">330</span> &#123;<br><span class="hljs-comment">// crash!</span><br>os.Exit(<span class="hljs-number">1</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> rr.Int64() &lt; <span class="hljs-number">660</span> &#123;<br><span class="hljs-comment">// delay for a while.</span><br>maxms := big.NewInt(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>)<br>ms, _ := crand.Int(crand.Reader, maxms)<br>time.Sleep(time.Duration(ms.Int64()) * time.Millisecond)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, contents <span class="hljs-type">string</span>)</span></span> []mr.KeyValue &#123;<br>maybeCrash()<br><br>kva := []mr.KeyValue&#123;&#125;<br>kva = <span class="hljs-built_in">append</span>(kva, mr.KeyValue&#123;<span class="hljs-string">&quot;a&quot;</span>, filename&#125;)<br>kva = <span class="hljs-built_in">append</span>(kva, mr.KeyValue&#123;<span class="hljs-string">&quot;b&quot;</span>, strconv.Itoa(<span class="hljs-built_in">len</span>(filename))&#125;)<br>kva = <span class="hljs-built_in">append</span>(kva, mr.KeyValue&#123;<span class="hljs-string">&quot;c&quot;</span>, strconv.Itoa(<span class="hljs-built_in">len</span>(contents))&#125;)<br>kva = <span class="hljs-built_in">append</span>(kva, mr.KeyValue&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;xyzzy&quot;</span>&#125;)<br><span class="hljs-keyword">return</span> kva<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reduce</span><span class="hljs-params">(key <span class="hljs-type">string</span>, values []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>maybeCrash()<br><br><span class="hljs-comment">// sort values to ensure deterministic output.</span><br>vv := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(values))<br><span class="hljs-built_in">copy</span>(vv, values)<br>sort.Strings(vv)<br><br>val := strings.Join(vv, <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-keyword">return</span> val<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看代码我们可以发现，在每一次做Map函数和Reduce函数的时候都调用一个函数maybeCrash()，这个函数先生成一个随机数，如果这个随机数小于330，那么进程就会被终止。</p><p>在实现手册上也有这么一段:</p><ul><li>If you choose to implement Backup Tasks (Section 3.6), note that we test that your code doesn’t schedule extraneous tasks when workers execute tasks without crashing. Backup tasks should only be scheduled after some relatively long period of time (e.g., 10s).</li><li>To test crash recovery, you can use the mrapps&#x2F;crash.go application plugin. It randomly exits in the Map and Reduce functions.</li></ul><p>翻译一下:</p><ul><li>如果您选择实现备份任务（第 3.6 节），请注意，我们测试您的代码在工作线程执行任务而不崩溃时不会安排无关的任务。备份任务只能在相对较长的时间（例如 10 秒）后安排。</li><li>要测试崩溃恢复，您可以使用 mrapps&#x2F;crash.go 应用程序插件。它随机存在于Map和Reduce函数中。</li></ul><p>我们可以这样实现这个功能，在任务信息结构体中新加一个字段用于记录任务开始的时间，然后再初始化coordinator的时候同步开启一个crash探测协程，将超过10s的任务都返回channel中，等待任务重新被分配给worker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TaskInfo <span class="hljs-keyword">struct</span> &#123;<br>StartTime  time.Time  <span class="hljs-comment">// 任务开始的时间</span><br>TaskStatus TaskStatus <span class="hljs-comment">// 当前task的状态 有三种 正在执行 等待被执行 执行完毕</span><br>TaskAddr   *Task      <span class="hljs-comment">// 当前task的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们将某一个任务设置为Operating的时候，就设置它的开始时间:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> setTaskStatus(taskId <span class="hljs-type">int</span>) &#123;<br>c.TaskHolder.Meta[taskId].TaskStatus = Operating<br>c.TaskHolder.Meta[taskId].StartTime = time.Now() <span class="hljs-comment">// 初始化开始时间</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Coordinator.go中开启crash协程:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;<br>c := Coordinator&#123;<br>ReducerNum:        nReduce,<br>TaskId:            <span class="hljs-number">0</span>,<br>DistPhase:         MapPhase,<br>MapTaskChannel:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, <span class="hljs-built_in">len</span>(files)),<br>ReduceTaskChannel: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task, nReduce),<br><br>TaskHolder: TaskHolder&#123;<br>Meta: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*TaskInfo, <span class="hljs-built_in">len</span>(files)+nReduce), <span class="hljs-comment">// task的数量是所有map的数量 + reduce的数量</span><br>&#125;,<br>&#125;<br><br>c.makeMapTasks(files)<br>c.server()<br><br><span class="hljs-keyword">go</span> c.CrashDetector()<br><span class="hljs-keyword">return</span> &amp;c<br>&#125;<br></code></pre></td></tr></table></figure><p>实现CrashDetector:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> CrashDetector() &#123;<br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> c.DistPhase == Alldone &#123; <span class="hljs-comment">// 如果都做完了 那就结束</span><br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, taskInfo := <span class="hljs-keyword">range</span> c.TaskHolder.Meta &#123; <span class="hljs-comment">// 遍历每一个任务 看它们的启动时间距离现在多久</span><br><span class="hljs-keyword">if</span> taskInfo.TaskStatus == Operating &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task %d is working&quot;</span>, taskInfo.TaskAddr.TaskId)<br>&#125;<br><span class="hljs-keyword">if</span> taskInfo.TaskStatus == Operating &amp;&amp; time.Since(taskInfo.StartTime) &gt; time.Second*<span class="hljs-number">9</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Task %d crashed, and it is a %d task\n&quot;</span>, taskInfo.TaskAddr.TaskId, taskInfo.TaskAddr.TaskType)<br><br><span class="hljs-keyword">if</span> taskInfo.TaskAddr.TaskType == MapTask &#123;<br>taskInfo.TaskStatus = Waiting<br>c.MapTaskChannel &lt;- taskInfo.TaskAddr<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> taskInfo.TaskAddr.TaskType == ReduceTask &#123;<br>taskInfo.TaskStatus = Waiting<br>c.ReduceTaskChannel &lt;- taskInfo.TaskAddr<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、-完结撒花"><a href="#二、-完结撒花" class="headerlink" title="二、 完结撒花"></a>二、 完结撒花</h2><p>至此所有问题都得以解决，实现了Lab1MapReduce</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20231002013442316.png" alt="image-20231002013442316"></p><p>代码已放github:<a href="https://github.com/i-rong/MIT6.824">代码</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.824</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为实习内容整理</title>
    <link href="/2023/09/25/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
    <url>/2023/09/25/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>主要是一些问题的思考</strong></p><h3 id="1-为什么B-树会出现“刻舟求剑”-的BUG，而红黑树不会"><a href="#1-为什么B-树会出现“刻舟求剑”-的BUG，而红黑树不会" class="headerlink" title="1. 为什么B+树会出现“刻舟求剑” 的BUG，而红黑树不会"></a>1. 为什么B+树会出现“刻舟求剑” 的BUG，而红黑树不会</h3><p>BUG出现的背景:</p><p>在cache_index.c中有一个函数<code>tree_search_and_insert</code>，在淘汰的时候，会调用一个函数改变整棵树。总体流程如下:</p><ol><li><p>查找到当前这个数据可以插入到树上的哪个位置，把这个位置记录成A；</p></li><li><p>检查当前的资源够不够</p><p>若资源不够，就需要触发淘汰，需要删除节点，改变B+树的结构，这时，原本可以插入的B+树上的位置已经变成了A’；</p></li><li><p>淘汰完后，资源够了，接着完树上的A位置插入数据，这个位置是错误的插入位置</p></li></ol><p>解决方案:</p><ol><li><p>方案一</p><p>将上面的顺序换位2、1、3</p></li><li><p>方案二</p><p>在2淘汰的时候，维护一个变量has_evicted，如果被淘汰了，就把这个变量置为1，然后在3重新插入的时候，如果检测到那个位置已经被淘汰了，那就重新查找一下可以插入的位置</p></li></ol><p>那么为什么红黑树不会出现这样的问题呢？</p><p>因为红黑树上，一个节点对应一个数据，查找、插入都是以节点为单位的，而B+树上只有叶子节点有数据，并且叶子节点上有多个数据，这些数据在某一个叶子节点中用数据的位置index来区分，所以当改变一个树的结构的时候，index有被改变，这就导致了插入位置的错误。</p><h3 id="2-为什么在RAID1上，B-树的表现比红黑树的表现差？"><a href="#2-为什么在RAID1上，B-树的表现比红黑树的表现差？" class="headerlink" title="2.为什么在RAID1上，B+树的表现比红黑树的表现差？"></a>2.为什么在RAID1上，B+树的表现比红黑树的表现差？</h3><p>在真实的业务中，一个RAID卡由40个盘组成，下面先讨论组RAID1的情况:</p><p>RAID1有一半是冗余盘，我们将40个盘组成20个RAID1，每个RAID1用两个盘；20个RAID1组对应了20棵B+树</p><p>在实现代码的时候，单个B+树叶子节点不超过280字节（通过结构体的占用字节数量计算而来）</p><p>在Cache上有8K个Chunk(8192个Chunk)，一个Chunk的大小为256KB</p><p>假设这8192个平均分到20棵B+树上，每棵B+树平均能分到410个Chunk的地址（也就是Data），而我们在业务上用的B+树是9阶B+树，对于顺序插入来说，这个B+树通常都不是满B+树，一旦一个节点中的数据到达了9，它就会分裂，分裂成一个4个数据的节点和一个5个数据的节点，对于整棵B+树来说，它的大部分节点都是只有4个索引的（非叶子节点）。假设每个节点上都有4个索引（对于叶子节点来说是数据），叶子节点上需要覆盖所有的这些410个数据，那么就会有$\lceil$ $\frac{410}{4}$ $\rceil$ &#x3D; 103</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924211448457.png" alt="image-20230924211448457"></p><p>$5^n &gt;&#x3D; 103$求出$n &gt;&#x3D; 3$，故B+树至少有4层，这样对于RAID1来说，我们就有了20个B+树，每个B+树4层，这样每对一个RAID1下IO，平均每个B+树要纵向查找4次；一共有20个B+树，那么一共要查找4 * 20 &#x3D; 80个B+树节点（包括中间节点和叶子节点）。</p><p>在CPU和内存之间还有一层DCache，这个DCache的容量很小，只有256KB，我们将刚刚那80个B+树节点放到DCache中，一个节点是280字节，80个节点就是22400字节，也就是22400&#x2F;1024KB &#x3D; 21.875KB，DCache可以存放$\lfloor$ $\frac{256}{21.875}$ $\rfloor$ &#x3D; 11组这样的节点，换句话说，平均每做11次IO读写，就会让整个DCache中的数据轮换一遍；</p><p>而对于RAID6来说，一个RAID6需要8个盘，那么就有5个RAID6组，每个RAID6组对应一棵B+树，平均每个B+树上会有$\frac{8192}{5} &#x3D; 1639$个数据，这样每个B+树上会有$\lfloor$ $\frac{1639}{4}$ $\rfloor$ &#x3D; 410的叶子节点，$5^n &gt;&#x3D; 410$，求出n &gt;&#x3D; 4，也就是说，RAID6对应的B+树都是5层B+树；这样每对一个RAID6下IO，平均每个B+树在纵向上要查找5次；一共有5个B+树，那么一共要查找5 * 5 &#x3D; 25个B+树节点（包括中间节点和叶子节点）。</p><p>将这25个B+树节点放到DCache中，这25个节点占用的空间是$25 * 280 &#x3D; 7000B$即7KB，DCache可以存放$\lfloor$ $\frac{256}{21.875}$ $\rfloor$ &#x3D; 36组这样的节点，换句话说，平均做36次IO读写，才会让整个DCache中的数据全部换一遍，而DCache更换消耗的时间是比较大的，所以在B+树上，RAID6的性能更好一些。</p><p>对于DCache更换，每一次访问节点都是Cache miss，访问的时延会倍增，miss时延200ns，而Cache命中的话，几个Cycle就可以完成。</p><h3 id="3-为什么在中间使用B-树数据结构？为什么不用其他的数据结构？有没有考虑过用哈希表来做这一块？"><a href="#3-为什么在中间使用B-树数据结构？为什么不用其他的数据结构？有没有考虑过用哈希表来做这一块？" class="headerlink" title="3.为什么在中间使用B+树数据结构？为什么不用其他的数据结构？有没有考虑过用哈希表来做这一块？"></a>3.为什么在中间使用B+树数据结构？为什么不用其他的数据结构？有没有考虑过用哈希表来做这一块？</h3><ul><li>首先回答为什么不使用哈希表来做这一块:</li></ul><p>因为我们的模型是不可控的，极端情况可以构造出所有节点hash值一样的场景，都在同一个冲突链上，就退化成线性表了。</p><ul><li>考虑其他的数据结构，比如业务上使用的红黑树:</li></ul><p>树型结构能保证每次搜索访问次数都在可控范围内，最好和最差的差值不会太大（红黑树是1&#x2F;2，b+树是1），io时延的波动不大比较稳定。</p><p>这里的“红黑树是1&#x2F;2，B+树是1”的指的是树最高和最低的层级之比，对于红黑树，这个层级之比最差可以达到1&#x2F;2，而对于B+树来说，因为B+树的所有叶子节点都在最底层，都属于同一层，所以B+树的这个比值稳定为1。</p><p>每发送一个io命令，需要在树上进行查找，这个时间是会随着树的结构有波动的，树最低层和最高层层级比值越接近1，那么这个树的结构是越稳定的，io在树上查找的时延也是越稳定的。</p><p>B+树占的空间相对大，但是稳定性能高，而且在我们这种硬件设计上能有额外的优化（中间节点放在访问更快的缓存里），所以效果更好。对于某些空间敏感的业务可能红黑树更好。</p><ul><li>设计上来说可以使用线性表来做</li></ul><p>设计上来讲对于ssd buffer结构可以使用线性表或者hash表做索引，但是对于拆分比较碎的就是树了。其他的还没考虑过。</p><h3 id="4-在什么情况下会出现1中提到的淘汰的情况？"><a href="#4-在什么情况下会出现1中提到的淘汰的情况？" class="headerlink" title="4.在什么情况下会出现1中提到的淘汰的情况？"></a>4.在什么情况下会出现1中提到的淘汰的情况？</h3><p>资源不够就淘汰，为了尽可能的让数据长时间留存在cache内，平时不会主动触发，只会在申请的时候看资源够不够。</p><p>所以是 申请资源——资源不够——触发淘汰。</p><p>这里的资源指的是chunk（物理地址），在不考虑其他限制的情况下，只有在chunk不够才会淘汰chunk，树的节点是往足量给的。</p><p>树上的chunk不一定都是满数据，但是肯定都有数据，可能一个chunk内只有一点点空间是有效的。（比如在下小io的时候）</p><h3 id="5-B-树中的Data和Cache-Chunk中的数据的对应关系是什么？"><a href="#5-B-树中的Data和Cache-Chunk中的数据的对应关系是什么？" class="headerlink" title="5.B+树中的Data和Cache_Chunk中的数据的对应关系是什么？"></a>5.B+树中的Data和Cache_Chunk中的数据的对应关系是什么？</h3><p>B+树叶子节点上的一个data指向一个chunk的地址，chunk里面存放的是真实的物理地址</p><p>每个chunk固定对应一块在ddr中的地址(在RAID卡中)和一个virtual disk的lba，后者(lba)用来计算key并挂在树上。</p><p>RAID卡里面有一块很小的空间（ddr），然后这个cache就存放在这个空间里面；chunk对应的第二个地址，是在磁盘空间里的虚拟地址，它指向这个虚拟地址，这个虚拟地址可以通过自己的MMU机制得到磁盘空间里面的物理地址。</p><p>ddr的大小是2-8G，划出来一块做B+树的数据结构，剩下的空间当作Cache来用。</p><h3 id="6-B-树上的Key关键字是如何计算的？"><a href="#6-B-树上的Key关键字是如何计算的？" class="headerlink" title="6.B+树上的Key关键字是如何计算的？"></a>6.B+树上的Key关键字是如何计算的？</h3><p>Key就是线性计算，LBA除以一个树的大小再除以一个Block的大小。</p><p>B+树上不用除以一个树的大小了，直接除以一个chunk_size的大小就可以了。</p><p>树的大小是多大？Block的大小是多大？</p><p>B+树的大小没有做限制，Block就是指的chunk，一个chunk的大小就是256KB。</p><p>这里不保证lba与chunk_size对齐，lba的粒度更细，运算结果相同的lba会落到同一个chunk中。</p><h3 id="7-有没有限制节点的个数"><a href="#7-有没有限制节点的个数" class="headerlink" title="7.有没有限制节点的个数"></a>7.有没有限制节点的个数</h3><p>没有限制节点的个数，在红黑树上有限制红黑树的大小不能超过512G，而B+树上没有做限制，这是因为B+树是多路搜索树，就算数据很多，树的层级也不会很高，不会让它在内存中查找B+树上的下一个节点的次数很多。</p><h3 id="8-这里面有没有用到LRU的淘汰的思想，这个是怎么做的？"><a href="#8-这里面有没有用到LRU的淘汰的思想，这个是怎么做的？" class="headerlink" title="8.这里面有没有用到LRU的淘汰的思想，这个是怎么做的？"></a>8.这里面有没有用到LRU的淘汰的思想，这个是怎么做的？</h3><p>一个chunk对应两个地址，一个是cache的物理地址存数据的，在ddr，一个是vd的lba，后者用来计算key挂在树上。</p><p>lru找第一个物理地址对应的chunk，然后查出来对应的lba，再计算key，再操作树置空data。</p><p>LRU里面的每一行存放的是Cache中某一个chunk对应的物理地址，当需要使用LRU算法进行淘汰的时候，它找到最近不经常使用的那个chunk所在的物理地址，并取得这个物理地址里面的内容（内容有两个地址: 一个是在ddr中的Cache的物理地址，另一个是vd中的lba），通过lba来算key值，io保证执行时只会对齐lba。</p><p>LRU的思想并不能解决随机读和顺序读的性能问题，淘汰算法跟性能不是直接关联的，随机读的问题在于不淘汰的时候它也是没有办法直接命中的，这里是因为Cache可以做一些预读的处理。</p><p>LRU有一个链表，LRU和树通过chunk连接，每在树上挂载一块chunk的地址，就在LRU上更新一行表示有一个新的chunk可以被淘汰。</p><p>chunk的结构体大概长下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span> &#123;</span><br>    lru_list_head; <span class="hljs-comment">// lru链表</span><br>    dirty_list_head; <span class="hljs-comment">// 脏块链表</span><br>    lba; <span class="hljs-comment">// 对应vd的lba</span><br>    physical_addr; <span class="hljs-comment">// 当前chunk的物理地址</span><br>    status; <span class="hljs-comment">// 状态</span><br>    valid_bitmap;<br>    dirty_bitmap;<br>    quote_bitmap;<br>&#125; chunk;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>华为实习内容整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>华为实习内容整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nachos02</title>
    <link href="/2023/09/25/nachos02/"/>
    <url>/2023/09/25/nachos02/</url>
    
    <content type="html"><![CDATA[<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>实现Nachos的同步机制：锁和条件变量，并利用这些同步机制实现几个基础工具类。</p><h1 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h1><ol><li>使用Thread::Sleep实现锁机制和条件变量。</li><li>使用Semaphore实现锁机制和条件变量。</li><li>使用锁机制和条件变量将实验1里实现的双向链表修改成线程安全的，对第1点、第2点的实现应分别测试。</li><li>实现一个线程安全的表结构。</li><li>实现一个大小受限的缓冲区。</li></ol><h1 id="三、实验设计及关键代码实现"><a href="#三、实验设计及关键代码实现" class="headerlink" title="三、实验设计及关键代码实现"></a>三、实验设计及关键代码实现</h1><h2 id="0-实验准备"><a href="#0-实验准备" class="headerlink" title="0.  实验准备"></a>0.  实验准备</h2><ol><li><p>Mesa语义和Hoare语义</p><ul><li><p>本实验要求使用的是Mesa语义，这两者的区别在于：</p></li><li><p>假如有两个线程T1和T2，T1因为资源不满足正处于等待队列中，这时有线程释放了T1所需要的资源，那么这个时候会发生什么呢？T1会立即被唤醒还是等待T2运行结束后再被唤醒？这种情形下的两种不同操作区分了两种语义：</p><p>a) 对于Mesa语义来说，需要等到T2运行结束后，T1才会被唤醒。</p><p>b) 对于Hoare语义来说，T1会被立刻唤醒。</p></li><li><p>简单来说，也就想当于Mesa是非抢占式的，而Hoare是抢占式的。</p></li><li><p>本实验中，使用Mesa语义，所以signal之后需要等待线程结束。</p></li></ul></li><li><p>相关的函数机制</p><ul><li><p><code>Thread::Sleep()</code>: 将当前的线程设置为阻塞状态</p></li><li><p><code>Scheduler::ReadyToRun(Thread\* thread)</code>: 将传入函数的线程thread设置为就绪态后，添加到就绪队列中。</p></li><li><p>中断相关函数：</p><p>在使用Sleep之前，为了防止错误的中断，必须暂时关闭中断功能：</p><p><code>IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);</code> 用于关闭中断。</p><p><code>(void) interrupt-&gt;SetLevel(oldLevel);</code> 用于开启中断。</p></li></ul></li><li><p>理解信号的P、V操作</p><p>P和V函数实现的内容和课本上的semWait()和semSignal()一样。</p><ul><li><p>在P操作中，如果当前的value &#x3D;&#x3D; 0，说明信号量被占用，则用该线程加入到信号量的阻塞队列中，否则该线程拥有信号量，value–。</p></li><li><p>在V操作中，value++，若阻塞队列不为空则从队列中取出一个线程放入就绪队列中。</p></li></ul></li></ol><h2 id="1-使用Thread-Sleep实现锁机制和条件变量"><a href="#1-使用Thread-Sleep实现锁机制和条件变量" class="headerlink" title="1. 使用Thread::Sleep实现锁机制和条件变量"></a>1. 使用Thread::Sleep实现锁机制和条件变量</h2><ol><li><p>Lock类头文件定义</p><ul><li><p>bool state;</p><p>锁，即互斥量，可以用来保护临界区，有两种状态：上锁和解锁，因此Lock类中需要有一个bool类型的变量state记录当前锁的状态。当state为true时表示锁已经被占用，否则表示锁是空闲的。</p></li><li><p>List* queue;</p><p>如果锁处于解锁状态，那么当一个线程需要请求锁的时候，该线程可以得到锁，否则当锁被占用的时候，申请该锁的线程就会被阻塞，为了记录由于等待该锁而被阻塞的线程，Lock类中需要有一个List的链表存放阻塞的线程。</p></li><li><p>Thread* threadHoldLock;</p><p>只有拥有锁的线程才能释放锁，因此类中需要有Thread变量来记录当前拥有锁的是哪一个线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Lock</span>(<span class="hljs-type">char</span>* debugName);<br>    ~<span class="hljs-built_in">Lock</span>();<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acquire</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHeldByCurrentThread</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">bool</span> state;<br>    List* queue; <br>    Thread* threadHoldLock;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Lock类成员函数实现</p><ul><li><p><code>void Lock::Acquire();</code></p><p>线程尝试获取锁：首先需要关闭中断，如果锁的状态是true，表示它已经被其他线程获取了，则将该线程添加到该锁的阻塞队列上；否则修改锁的状态、记录获得该锁的线程，然后开启中断功能。</p></li><li><p><code>void Lock::Release();</code></p><p>锁被释放：和Acquire一样，在执行操作之前同样需要先关闭中断。当锁的阻塞队列非空时，将一个线程从阻塞队列中移出，将这个线程的状态改为就绪态后，放入就绪队列中，同时修改锁的状态为false，最后开启中断。</p></li><li><p><code>bool Lock::isHeldByCurrentThread();</code></p><p>判断该锁是否被当前线程所拥有，只需要判断currentThread和拥有该锁的线程是否相同即可。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Lock::<span class="hljs-built_in">Lock</span>(<span class="hljs-type">char</span>* debugName) &#123;<br>    name = debugName;<br>    queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>();<br>&#125;<br>Lock::~<span class="hljs-built_in">Lock</span>() &#123;<br>    <span class="hljs-keyword">delete</span> queue;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock::Acquire</span><span class="hljs-params">()</span> </span>&#123;<br>    IntStatus oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    <span class="hljs-keyword">if</span>(state == <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">/*block the current thread*/</span><br>        queue-&gt;<span class="hljs-built_in">Append</span>((<span class="hljs-type">void</span>*)currentThread);<br>        currentThread-&gt;<span class="hljs-built_in">Sleep</span>();<br>    &#125;<br>    state = <span class="hljs-literal">true</span>; <span class="hljs-comment">// lock the lock</span><br>    threadHoldLock = currentThread;<br>    (<span class="hljs-type">void</span>*) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock::Release</span><span class="hljs-params">()</span> </span>&#123;<br>    IntStatus oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    Thread* thread;<br>    thread = (Thread*)queue-&gt;<span class="hljs-built_in">Remove</span>(); <span class="hljs-comment">// get the first item and let it be ready</span><br>    <span class="hljs-keyword">if</span>(thread != <span class="hljs-literal">NULL</span>) &#123;<br>        scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(thread);<br>    &#125;<br>    state = <span class="hljs-literal">false</span>;<br>    threadHoldLock = <span class="hljs-literal">NULL</span>;<br>    (<span class="hljs-type">void</span>*) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Lock::isHeldByCurrentThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> currentThread == threadHoldLock;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Condition类头文件定义</p><ul><li><p>List* queue;</p><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，当条件变量的条件不成立时，线程需要被阻塞挂起，当等待的条件成立时，线程被重新唤醒，放入就绪队列中，因此需要一个队列来存放阻塞的线程。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Condition</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Condition</span>(<span class="hljs-type">char</span>* debugName);<br>    ~<span class="hljs-built_in">Condition</span>();<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (name); &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">(Lock *conditionLock)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Signal</span><span class="hljs-params">(Lock *conditionLock)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Broadcast</span><span class="hljs-params">(Lock *conditionLock)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* name;<br>    List* queue;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Condition类成员函数实现</p><ul><li><p><code>void Condition::Wait(Lock \*conditionLock);</code></p><p>该函数等待条件变量的条件成立，当条件不成立时，使用该函数让线程等待条件成立。同样需要先关闭中断，防止发生意想不到的错误，首先确保当前线程拥有该锁，否则可能造成临界资源的访问错误，将该线程添加到阻塞挂起队列中，然后释放锁，将当前线程的状态切换到阻塞态后，等待条件成立被唤醒而重新得到锁。</p></li><li><p><code>void Condition::Signal(Lock \*conditionLock);</code></p><p>在确保当前线程拥有锁的情况下，如果因条件变量而阻塞的线程不空，则从队列中唤醒一个线程，并将该线程添加到就绪队列中。</p></li><li><p><code>void Condition::Broadcast(Lock \*conditionLock);</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Condition::<span class="hljs-built_in">Condition</span>(<span class="hljs-type">char</span>* debugName) &#123;<br>    name = debugName;<br>    queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>();<br>&#125;<br>Condition::~<span class="hljs-built_in">Condition</span>() &#123;<br>    <span class="hljs-keyword">delete</span> queue;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Wait</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123;<br>    IntStatus oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    <span class="hljs-built_in">ASSERT</span>(conditionLock-&gt;<span class="hljs-built_in">isHeldByCurrentThread</span>()); <span class="hljs-comment">// make sure that the current thread hold the lock</span><br>    queue-&gt;<span class="hljs-built_in">Append</span>((<span class="hljs-type">void</span>*)currentThread);<br>    conditionLock-&gt;<span class="hljs-built_in">Release</span>(); <span class="hljs-comment">// release before change status</span><br>    currentThread-&gt;<span class="hljs-built_in">Sleep</span>();<br>    conditionLock-&gt;<span class="hljs-built_in">Acquire</span>(); <span class="hljs-comment">// get the lock after change</span><br>    (<span class="hljs-type">void</span>*) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Signal</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123; <span class="hljs-comment">// wakeup a thread in the blocked queue and let it added to the ready queue</span><br>    IntStatus oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    Thread *thread;<br>    thread = (Thread*)queue-&gt;<span class="hljs-built_in">Remove</span>();<br>    <span class="hljs-keyword">if</span>(thread != <span class="hljs-literal">NULL</span>) &#123;<br>        scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(thread);<br>    &#125;<br>    (<span class="hljs-type">void</span>*) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Broadcast</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123; <span class="hljs-comment">// wakeup all threads that are blocked</span><br>    IntStatus oldLevel = interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(IntOff);<br>    Thread *thread = (Thread*)queue-&gt;<span class="hljs-built_in">Remove</span>();<br>    <span class="hljs-keyword">while</span>(thread != <span class="hljs-literal">NULL</span>) &#123;<br>        scheduler-&gt;<span class="hljs-built_in">ReadyToRun</span>(thread);<br>        thread = (Thread*)queue-&gt;<span class="hljs-built_in">Remove</span>();<br>    &#125;<br>    (<span class="hljs-type">void</span>*) interrupt-&gt;<span class="hljs-built_in">SetLevel</span>(oldLevel);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试该锁是否正确实现</p><ul><li><p>创建一个测试函数SynchTest，其功能为：</p><p>当线程编号为偶数时，先从SynchList中移出元素，再向SynchList中添加元素；当线程编号为奇数时，先向SynchList中添加元素，再从SynchList中移出元素：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SyncTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(which % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// even first remove then add</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before remove\n&quot;</span>, which);<br>        <span class="hljs-type">int</span>* item = (<span class="hljs-type">int</span>*)slist-&gt;<span class="hljs-built_in">Remove</span>();<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after remove %d\n&quot;</span>, which, *item);<br>        *item = which;<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before append %d\n&quot;</span>, which, *item);<br>        slist-&gt;<span class="hljs-built_in">Append</span>((<span class="hljs-type">void</span>*)item);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after append %d\n&quot;</span>, which, *item);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// odd first add then remove</span><br>        <span class="hljs-type">int</span>* item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br>        *item = which;<br>        <span class="hljs-comment">/* Append */</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before append %d\n&quot;</span>, which, *item);<br>        slist-&gt;<span class="hljs-built_in">Append</span>((<span class="hljs-type">void</span>*)item);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after append %d\n&quot;</span>, which, *item);<br>        currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>        <span class="hljs-comment">/* Remove */</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before remove %d\n&quot;</span>, which, *item);<br>        slist-&gt;<span class="hljs-built_in">Remove</span>();<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after remove %d\n&quot;</span>, which, *item);<br>        <span class="hljs-keyword">delete</span> item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试方式：在锁定临界资源的时候，切换进程，以此来验证锁的正确性。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">SynchList::Append</span><span class="hljs-params">(<span class="hljs-type">void</span> *item)</span></span><br><span class="hljs-function"></span>&#123;<br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<span class="hljs-comment">// enforce mutual exclusive access to the list </span><br>    list-&gt;<span class="hljs-built_in">Append</span>(item);<br>    currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Back from scheduler\n&quot;</span>);<br>    listEmpty-&gt;<span class="hljs-built_in">Signal</span>(lock);<span class="hljs-comment">// wake up a waiter, if any</span><br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译运行：编译成功后，在终端输入.&#x2F;nachos -q 4 -t 4，-q 4表示进入第四个test函数（即SynchTest），-t 4表示使用4个线程。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925155300291.png" alt="image-20230925155300291"></p><ul><li><p>分析：</p><p><strong>锁的有效性</strong>：从上图中可以看到，在“Thread 1 before append 1”到“Thread 1 after append 1”的过程中，线程2、线程3在锁的作用下均被阻塞，最后回到线程1执行，输出“Back from scheduler”，说明了锁的有效性。</p><p><strong>条件变量</strong>：在线程1结束“Thread 1 append 1”后，成功唤醒线程0删除“Thread 0 after remove 1”（线程0最先执行，因为一开始链表无元素，而线程0想执行删除操作，故被阻塞）。</p></li></ul></li></ol><h2 id="2-使用Semaphore实现锁机制和条件变量"><a href="#2-使用Semaphore实现锁机制和条件变量" class="headerlink" title="2. 使用Semaphore实现锁机制和条件变量"></a>2. 使用Semaphore实现锁机制和条件变量</h2><p>使用信号量Semaphore实现锁机制和条件变量与使用Thread::Sleep实现的思路大致相同，只是需要把Sleep操作和ReadyToRun操作换为信号量的P和V操作。</p><ol><li><p>Lock类头文件定义</p><p>Lock类中需要的锁状态可以用信号量中的value来代替，阻塞队列可以用信号量中的queue代替，需要添加的是<strong>拥有锁的线程和信号量sema</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Lock</span>(<span class="hljs-type">char</span>* debugName);  <span class="hljs-comment">// initialize lock to be FREE</span><br>    ~<span class="hljs-built_in">Lock</span>();<span class="hljs-comment">// deallocate lock</span><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<span class="hljs-comment">// debugging assist</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acquire</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// these are the only operations on a lock</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// they are both *atomic*</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHeldByCurrentThread</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* name;<br>    Semaphore* Sema; <span class="hljs-comment">// use the semaphore to realize the lock</span><br>    Thread* threadHoldLock; <span class="hljs-comment">// the thread that hold the lock, only the thread can release the lock</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Lock类成员函数实现</p><ul><li><p><code>void Lock::Acquire();</code></p><p>由于Semaphore的P操作是原子操作，所以不必考虑中断的影响，线程使用Acquire申请锁时，调用Sema-&gt;P()操作，如果value &gt; 0，说明锁没有被占用，则修改threadHoldLock的值，将其改为申请的进程，否则将该进程添加到阻塞队列并Sleep。</p></li><li><p><code>void Lock::Release();</code></p><p>Semaphore的V操作也是原子操作，先将threadHoldLock的值置为NULL，然后调用Sema-&gt;V()操作即可。</p></li><li><p><code>bool Lock::isHeldByCurrentThread();</code></p><p>判断该锁是否被当前线程所拥有，只需要判断currentThread和拥有该锁的线程是否相同即可。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Lock::<span class="hljs-built_in">Lock</span>(<span class="hljs-type">char</span>* debugName) &#123;<br>    name = debugName;<br>    Sema = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(debugName, <span class="hljs-number">1</span>);<br>&#125;<br>Lock::~<span class="hljs-built_in">Lock</span>() &#123;<br>    <span class="hljs-keyword">delete</span> Sema;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock::Acquire</span><span class="hljs-params">()</span> </span>&#123;<br>    Sema-&gt;<span class="hljs-built_in">P</span>();<br>    threadHoldLock = currentThread;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Lock::Release</span><span class="hljs-params">()</span> </span>&#123;<br>    threadHoldLock = <span class="hljs-literal">NULL</span>;<br>    Sema-&gt;<span class="hljs-built_in">V</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Lock::isHeldByCurrentThread</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//  return true if the current thread hold the lock</span><br>    <span class="hljs-keyword">return</span> currentThread == threadHoldLock;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Condition类头文件定义</p><ul><li><p><code>List* queue;</code></p><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，当条件变量的条件不成立时，线程需要被阻塞挂起，当等待的条件成立时，线程被重新唤醒，放入就绪队列中，因此需要一个队列来存放阻塞的线程。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Condition</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Condition</span>(<span class="hljs-type">char</span>* debugName);<br>    ~<span class="hljs-built_in">Condition</span>();<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (name); &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Wait</span><span class="hljs-params">(Lock *conditionLock)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Signal</span><span class="hljs-params">(Lock *conditionLock)</span></span>;   <span class="hljs-comment">// conditionLock must be held by</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Broadcast</span><span class="hljs-params">(Lock *conditionLock)</span></span>;<span class="hljs-comment">// the currentThread for all of </span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* name;<br>    Semaphore* Sema;<br>    <span class="hljs-type">int</span> blockNum;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Condition类成员函数实现</p><ul><li><p><code>void Condition::Wait(Lock *conditionLock);</code></p><p>首先释放锁，调用Sema-&gt;P()函数将进程设置为阻塞态并放入阻塞队列中，同时阻塞线程数加1，最后等待条件成立，重新被唤醒。</p></li><li><p><code>void Condition::Signal(Lock *conditionLock);</code></p><p>如果当前被阻塞的线程数大于0，则调用Sema-&gt;V()释放一个线程，并将其加入到就绪队列中去。</p></li><li><p>void Condition::Broadcast(Lock *conditionLock);</p><p>当阻塞线程数大于0时，重复调用Sema-&gt;V()，直到所有的阻塞线程都被重载到就绪队列中去。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Condition::<span class="hljs-built_in">Condition</span>(<span class="hljs-type">char</span>* debugName) &#123;<br>    name = debugName;<br>    Sema = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(debugName, <span class="hljs-number">0</span>);<br>    blockNum = <span class="hljs-number">0</span>;<br>&#125;<br>Condition::~<span class="hljs-built_in">Condition</span>() &#123;<br>    <span class="hljs-keyword">delete</span> Sema;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Wait</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123;<br>    conditionLock-&gt;<span class="hljs-built_in">Release</span>();<br>    Sema-&gt;<span class="hljs-built_in">P</span>();<br>    blockNum++;<br>    conditionLock-&gt;<span class="hljs-built_in">Acquire</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Signal</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123; <span class="hljs-comment">// wakeup a thread in the blocked queue and let it added to the ready queue</span><br>    <span class="hljs-keyword">if</span>(blockNum &gt; <span class="hljs-number">0</span>) &#123;<br>        Sema-&gt;<span class="hljs-built_in">V</span>();<br>        blockNum--;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Condition::Broadcast</span><span class="hljs-params">(Lock* conditionLock)</span> </span>&#123; <span class="hljs-comment">// wakeup all threads that are blocked</span><br>    <span class="hljs-keyword">while</span>(blocksum) &#123;<br>        Sema-&gt;<span class="hljs-built_in">V</span>();<br>        blockNum--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-使用锁机制和条件变量将实验1里实现的双向链表修改成线程安全的"><a href="#3-使用锁机制和条件变量将实验1里实现的双向链表修改成线程安全的" class="headerlink" title="3. 使用锁机制和条件变量将实验1里实现的双向链表修改成线程安全的"></a>3. 使用锁机制和条件变量将实验1里实现的双向链表修改成线程安全的</h2><ol><li><p>测试以“sleep+中断禁止与启用”实现的条件变量是否正确</p><ul><li>测试代码：奇数编号线程先添加后删除，偶数编号线程先删除后添加。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLListTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(which % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// even first remove then add</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before remove\n&quot;</span>, which);<br>        dllist-&gt;<span class="hljs-built_in">Remove</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after remove\n&quot;</span>, which);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before append\n&quot;</span>, which);<br>        dllist-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after append\n&quot;</span>, which);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// odd first add then remove</span><br>        <span class="hljs-comment">/* Append */</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before append\n&quot;</span>, which);<br>        dllist-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after append\n&quot;</span>, which);<br>        currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>        <span class="hljs-comment">/* Remove */</span><br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d before remove\n&quot;</span>, which);<br>        dllist-&gt;<span class="hljs-built_in">Remove</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d after remove\n&quot;</span>, which);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925155846049.png" alt="image-20230925155846049"></p><p>一开始线程0进入，先删除，但是此时链表中一个元素也没有，于是发生了段错误。</p><ul><li>加入条件变量：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLList::Append</span><span class="hljs-params">(<span class="hljs-type">void</span> *item)</span> </span>&#123;<br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    DLLElement *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLLElement</span>(item, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>        first = newnode;<br>        last = newnode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        last-&gt;next = newnode;<br>        newnode-&gt;prev = last;<br>        last = newnode;<br>    &#125;<br>    dllistEmpty-&gt;<span class="hljs-built_in">Signal</span>(lock);<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">DLList::Remove</span><span class="hljs-params">(<span class="hljs-type">int</span> *keyPtr)</span> </span>&#123; <span class="hljs-comment">// remove from head</span><br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">IsEmpty</span>()) dllistEmpty-&gt;<span class="hljs-built_in">Wait</span>(lock); <span class="hljs-comment">// condition</span><br>    DLLElement *element = first;<br>    <span class="hljs-type">void</span> *thing;<br>    thing = first-&gt;item;<br>    <span class="hljs-keyword">if</span>(first == last &amp;&amp; first-&gt;next == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// only one</span><br>        first = <span class="hljs-literal">NULL</span>;<br>        last = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        first = element-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(keyPtr != <span class="hljs-literal">NULL</span>) *keyPtr = element-&gt;key;<br>    <span class="hljs-keyword">delete</span> element;<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>    <span class="hljs-keyword">return</span> thing;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次测试：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925155935016.png" alt="image-20230925155935016"></p><p>可以看到，线程0进入，链表中没有元素，于是被条件变量阻塞，等待条件成立，之后线程1向链表中加入元素，唤醒线程0，线程0删除元素，此后程序正确执行。</p></li><li><p>测试以“信号量”实现的锁机制和条件变量是否正确</p><p>测试方法和前面测试“Sleep”实现的相同。下面直接给出测试结果。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925160008697.png" alt="image-20230925160008697"></p><p>​可以看到，程序同样正确执行。</p><p>​至此，锁和条件变量的正确性测试完毕，且用锁和条件变量实现了双向链表的线程安全性。</p><h2 id="4-实现一个线程安全的表结构"><a href="#4-实现一个线程安全的表结构" class="headerlink" title="4. 实现一个线程安全的表结构"></a>4. 实现一个线程安全的表结构</h2><ol><li><p>Table类头文件定义</p><ul><li>void** table; 定义表头指针，线性表的主体是一个指针数组。</li><li>int tsize; 记录表的大小。</li><li>int cnt; 记录表中的元素个数。</li><li>Lock* lock; 锁。</li><li>Condition* tableEmpty; 用来阻塞表为空的情况。</li></ul><p>这里锁和条件变量的实现使用的是第二部分信号量的方法。</p><p>table.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __TABLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __TABLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;synch.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Table</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Table</span>(<span class="hljs-type">int</span> size);<br>    ~<span class="hljs-built_in">Table</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Alloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *object)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Release</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// print all item in tableBase</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// get the current table size</span><br>    <span class="hljs-type">int</span> cnt;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> TableSize;<br>    <span class="hljs-type">void</span>** tableBase;<br>    Lock* lock;<br>    Condition* tableEmpty;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __TABLE_H</span></span><br></code></pre></td></tr></table></figure></li><li><p>Table类中主要的成员函数</p><ul><li><p>在Table类中最主要的两个函数是Alloc和Release函数，它们的作用分别是在表中添加元素和删除元素。</p></li><li><p>int Alloc(void *object);&#x20;</p><p>操作前先请求锁，然后遍历线性表直到找到线性表中第一个空位的索引index，若index超过了表界限则返回-1，否则将object添加到此位置。添加完毕后Signal，唤醒由于线性表中index位置为空而被阻塞的线程，函数的返回值为插入位置的索引index。</p></li><li><p>void Release(int index);</p><p>对于Release函数，在请求锁后首先需要判断线性表当前位置是否为空，如果为空，则线程被tableEmpty阻塞，直到另一个线程向线性表中该位置添加元素后重新被唤醒。</p></li></ul><p>table.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;table.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;synch.h&quot;</span></span><br><br>Table::<span class="hljs-built_in">Table</span>(<span class="hljs-type">int</span> size) &#123;<br>    TableSize = size;<br>    cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// initailize</span><br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Lock</span>(<span class="hljs-string">&quot;table lock&quot;</span>);<br>    tableEmpty = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Condition</span>(<span class="hljs-string">&quot;tableEmpty condition&quot;</span>);<br>    tableBase = <span class="hljs-keyword">new</span> <span class="hljs-type">void</span>*[size];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        tableBase[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br>Table::~<span class="hljs-built_in">Table</span>() &#123;<br>    TableSize = <span class="hljs-number">0</span>;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">delete</span> tableBase;<br>    <span class="hljs-keyword">delete</span> lock;<br>    <span class="hljs-keyword">delete</span> tableEmpty;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Table::Alloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *object)</span> </span>&#123; <span class="hljs-comment">// add object to tableBase</span><br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(tableBase[index] != <span class="hljs-literal">NULL</span> &amp;&amp; index &lt; TableSize) &#123;<br>        index++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(index &gt;= TableSize) &#123;<br>        ret = <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tableBase[index] = object;<br>        ret = index;<br>    &#125;<br>    <span class="hljs-built_in">ASSERT</span>(ret != <span class="hljs-number">-1</span>);<br>    cnt += <span class="hljs-number">1</span>;<br>    tableEmpty-&gt;<span class="hljs-built_in">Signal</span>(lock);<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Table::Release</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123; <span class="hljs-comment">// release item from tableBase</span><br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-keyword">while</span>(tableBase[index] == <span class="hljs-literal">NULL</span>) tableEmpty-&gt;<span class="hljs-built_in">Wait</span>(lock);<br>    tableBase[index] = <span class="hljs-literal">NULL</span>;<br>    cnt -= <span class="hljs-number">1</span>;<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">Table::Get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123; <span class="hljs-comment">// return item on tableBase[index]</span><br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-type">void</span> *ret;<br>    <span class="hljs-keyword">if</span>(index &gt;= TableSize) &#123;<br>        ret = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ret = tableBase[index];<br>    &#125;<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Table::getSize</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> TableSize;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Table::Print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; TableSize; i++) &#123;<br>        <span class="hljs-keyword">if</span>(tableBase[i] == <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tableBase[%d] : 0\n&quot;</span>, i);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tableBase[%d] : %d\n&quot;</span>, i, (<span class="hljs-type">int</span>)tableBase[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><p>为了检测表的安全性，让Thread0先对表进行删除操作，Thread1进行增加操作，测试前使用ASSERT函数确保操作数oprnum不大于表的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadnum; i++) testData[i] = i;<br>    <span class="hljs-built_in">ASSERT</span>(oprnum &lt;= table-&gt;<span class="hljs-built_in">getSize</span>());<br>    <span class="hljs-type">int</span> *object = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(which % <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; oprnum; i++) &#123;<br>            *object = testData[which + i];<br>            index = table-&gt;<span class="hljs-built_in">Alloc</span>((<span class="hljs-type">void</span>*)object);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d : Added object to table[%d]\n&quot;</span>, which, index);<br>        &#125;<br>        table-&gt;<span class="hljs-built_in">Print</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the number of objects is %d\n&quot;</span>, table-&gt;cnt);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; oprnum; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d ask for delete object\n&quot;</span>, which);<br>            table-&gt;<span class="hljs-built_in">Release</span>(index);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d : delete object from table[%d]\n&quot;</span>, which, index);<br>            index += <span class="hljs-number">1</span>;<br>        &#125;<br>        table-&gt;<span class="hljs-built_in">Print</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the number of objects is %d\n&quot;</span>, table-&gt;cnt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试结果</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925160239748.png" alt="image-20230925160239748"></p><p>​从图中可以看到，实现了线程安全的表结构。</p></li></ol><h2 id="5-实现一个大小受限的缓冲区"><a href="#5-实现一个大小受限的缓冲区" class="headerlink" title="5. 实现一个大小受限的缓冲区"></a>5. 实现一个大小受限的缓冲区</h2><ol><li><p>BoundedBuffer类头文件定义</p><p>与Table不同，BoundedBuffer需要两个索引head和tail，head存放的是已经使用了的Buffer中的第一个位置的下标，tail存放的是已经使用的Buffer中的最后一个位置的下标。buffer是缓冲区。maxSize为buffer最多能存放的大小，usedSize为当前已经使用的buffer的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BoundedBuffer</span>(<span class="hljs-type">int</span> maxSize);<br>    ~<span class="hljs-built_in">BoundedBuffer</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> size)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxSize; <span class="hljs-comment">// size of buffer</span><br>    <span class="hljs-type">int</span> head; <span class="hljs-comment">// pointer to the first place of buffer used</span><br>    <span class="hljs-type">int</span> tail; <span class="hljs-comment">// pointer to the last place of buffer used</span><br>    <span class="hljs-type">int</span> usedSize;<br>    uchar *buffer;<br><span class="hljs-keyword">private</span>:<br>    Lock *lock;<br>    Condition *full; <span class="hljs-comment">// ensure buffer not full</span><br>    Condition *empty; <span class="hljs-comment">// ensure buffer not empty</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>BoundedBuffer类成员函数</p><ul><li><p>void BoundedBuffer::Write(void* data, int size);</p><p>实现了向缓冲区中写入数据的功能。首先确保要写入的数据大小不大于buffer的最大容量。然后获取锁，保证操作的原子性，当要写的数据量超过了剩余容量，则将这个线程阻塞，使用条件变量，等待buffer中的数据被其他线程读取。若不超过剩余容量，则将size个数据依次写入buffer中：从tail &#x3D; 0开始，依次往后写，这里将buffer看出是一个循环队列，用取模的运算，当到达buffer的末尾时，就再从头写。写完后让usedSize增加size大小，然后Signal()，唤醒由于缓冲区中元素不够而阻塞的线程，最后释放锁。</p></li><li><p>void BoundedBuffer::Read(void* data, int size);</p><p>实现了从缓冲区中读取数据的功能。首先获取锁，保证操作的原子性。当要从缓冲区中读取的数据个数超过了缓冲区中已使用的大小时，线程被阻塞，使用条件变量，等待其他线程将数据写入缓冲区。若不超过已用大小，则从head开始，将从head开始的后size个数据都放入传入的data变量中，之后再将head增加size个，之后再读取位置就变了，然后将已使用缓冲区的大小usedSize减少size个，最后Signal()，唤醒由于缓冲区中元素太多而被阻塞的进程，再释放锁。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BoundedBuffer::<span class="hljs-built_in">BoundedBuffer</span>(<span class="hljs-type">int</span> maxSize) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;maxSize = maxSize;                                                                                               <br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Lock</span>(<span class="hljs-string">&quot;Buffer lock&quot;</span>);<br>    full = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Condition</span>(<span class="hljs-string">&quot;Buffer not full cond&quot;</span>);<br>    empty = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Condition</span>(<span class="hljs-string">&quot;Buffer not empty cond&quot;</span>);<br>    usedSize = <span class="hljs-number">0</span>;<br>    head = <span class="hljs-number">0</span>;<br>    tail = <span class="hljs-number">0</span>;<br>    buffer = <span class="hljs-keyword">new</span> uchar[maxSize];<br>&#125;<br>BoundedBuffer::~<span class="hljs-built_in">BoundedBuffer</span>() &#123;<br>    <span class="hljs-keyword">delete</span> lock;<br>    <span class="hljs-keyword">delete</span> full;<br>    <span class="hljs-keyword">delete</span> empty;<br>    <span class="hljs-keyword">delete</span> buffer;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BoundedBuffer::Write</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">int</span> size)</span> </span>&#123; <span class="hljs-comment">// write data to buffer and the data size is size</span><br>    <span class="hljs-built_in">ASSERT</span>(size &lt;= maxSize);<br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-keyword">while</span>(maxSize - usedSize &lt; size) &#123; <span class="hljs-comment">// remain size not enough</span><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&quot;\tRemain size is not enough.\n&quot;</span>);<br>        full-&gt;<span class="hljs-built_in">Wait</span>(lock);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        *((uchar*)buffer + (tail + i) % maxSize) = *((uchar*)data + i);<br>    &#125;<br>    tail = (tail + size) % maxSize;<br>    usedSize += size;<br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&quot;\tFinish Write Buffer. Buffer size : %d\n&quot;</span>, usedSize);<br>    empty-&gt;<span class="hljs-built_in">Signal</span>(lock);<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BoundedBuffer::Read</span><span class="hljs-params">(<span class="hljs-type">void</span>* data, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    lock-&gt;<span class="hljs-built_in">Acquire</span>();<br>    <span class="hljs-keyword">while</span>(usedSize - size &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&quot;\tNot enough to read\n&quot;</span>);<br>        empty-&gt;<span class="hljs-built_in">Wait</span>(lock);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        *((uchar*)data + i) = *((uchar*)buffer + (head + i) % maxSize);<br>    &#125;<br>    head = (head + size) % maxSize;<br>    usedSize -= size;<br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&quot;\tFinish Read buffer. Buffer size : %d\n&quot;</span>, usedSize);<br>    full-&gt;<span class="hljs-built_in">Signal</span>(lock);<br>    lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BoundedBuffer::Print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head; i != tail; i = (i + <span class="hljs-number">1</span>) % maxSize) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, buffer[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p><p>测试逻辑与Table测试逻辑相似，编号为偶数的线程从缓冲区中读取，而编号为奇数的线程向缓冲区中写入，这样由于先fork线程0，会构成一个先读取后写入的顺序，以此来检验buffer的安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BoundedBufferTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(which % <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;This is a test\n&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The length of str is %d\n&quot;</span>, <span class="hljs-built_in">strlen</span>(str));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">char</span> temp = str[i];<br>            bb-&gt;<span class="hljs-built_in">Write</span>(&amp;temp, <span class="hljs-number">1</span>);<br>            bb-&gt;<span class="hljs-built_in">Print</span>();<br>            <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">char</span> *temp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">3</span>];<br>            temp[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            bb-&gt;<span class="hljs-built_in">Read</span>(temp, <span class="hljs-number">2</span>);<br>            bb-&gt;<span class="hljs-built_in">Print</span>();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temp : %s\n&quot;</span>, temp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试结果</p><ul><li>常规测试</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925160515936.png" alt="image-20230925160515936"></p></li></ol><ul><li><p>手动切换线程</p><p>加了一行currentThread-&gt;Yield()，Thread1会放弃CPU，Thread0会接管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BoundedBufferTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(which % <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;This is a test\n&quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The length of str is %d\n&quot;</span>, <span class="hljs-built_in">strlen</span>(str));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">char</span> temp = str[i];<br>            bb-&gt;<span class="hljs-built_in">Write</span>(&amp;temp, <span class="hljs-number">1</span>);<br>            bb-&gt;<span class="hljs-built_in">Print</span>();<br>            <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&quot;Thread %d Yield\n&quot;</span>, which);<br>            currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>            <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-type">char</span> *temp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">3</span>];<br>            temp[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            bb-&gt;<span class="hljs-built_in">Read</span>(temp, <span class="hljs-number">2</span>);<br>            bb-&gt;<span class="hljs-built_in">Print</span>();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;temp : %s\n&quot;</span>, temp);<br>            <span class="hljs-keyword">if</span>(bb-&gt;<span class="hljs-built_in">getUsed</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925160547376.png" alt="image-20230925160547376"></p></li><li><p>buffer full</p><p>测试这一部分，我只将buffer的maxSize改为了10。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925160606254.png" alt="image-20230925160606254"></p></li></ul><h1 id="四、遇到的问题"><a href="#四、遇到的问题" class="headerlink" title="四、遇到的问题"></a>四、遇到的问题</h1><ul><li>在构造线性表时，一开始未定义索引index而是想直接删除表中最后一个元素，使用了tableBase[cnt-1]。但是cnt只是记录表中元素个数的变量，由于表中的元素可能不连续，所以有可能出现阻塞，直到恰好该位置被添加元素。但是一旦该位置一直为空，就有可能出现饥饿。</li><li>在做最后一个部分实现线程安全的缓冲区时，用一般的方法不太能很好看出线程的切换过程，于是我使用了DEBUG的方法来看线程是如何切换的，可以看到切换的流程可以很清晰的看出来。</li><li>考虑多个线程同时访问同一个BoundedBuffer的情况，可能出现线程A写入，线程B和线程C都去读取，我们只能让一个线程去读取。所以在实现缓冲区的时候，不仅仅有同步的问题，互斥的问题也同样存在。</li></ul><h1 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h1><ul><li>在本次操作系统实验中，我学习了两种实现锁机制和条件变量的方式：Sleep加中断和信号量。在使用Sleep加中断的方式时，我使用了一个标志位来表示锁的状态，当锁被占用时，其他线程需要等待直到锁被释放。在释放锁的时候，我使用了中断的方式，以保证操作的原子性。</li><li>另一种方式是使用信号量。信号量是一种计数器，用于控制多个线程对共享资源的访问。在本次实验中，我使用了信号量来实现锁机制和条件变量。当信号量的值大于0时，表示锁是可用的；当信号量的值为0时，表示锁被占用。</li><li>在实际的事件中，实现锁的方式的多样的，可以利用信号量去实现一个锁的机制，也可以简单的使用一个状态去记录所得状态。</li><li>在这个过程之中，都需要保证操作的原子性，也就是说在改变锁的状态时，不能被打断，所以需要使用关闭中断的方式去保证操作的原子性。这样做也有一定的弊端，关闭中断会使得系统变成一个无法被抢占的状态，可以在某些情况下导致死锁。</li><li>除了实现锁机制和条件变量，我还将双向链表改成了线程安全的形式，并且实现了一个线程安全的表结构。在这个过程中，我使用了锁机制和条件变量来保证多个线程同时访问数据结构时不会出现数据竞争和其他问题。最后，我还实现了一个大小受限的缓冲区，通过使用锁机制和条件变量来保证多个线程同时访问缓冲区时不会出现问题。</li><li>总的来说，本次操作系统实验让我更加深入地了解了多线程编程和操作系统底层原理。通过实践，我掌握了多种实现锁机制和条件变量的方式，并且学会了如何将数据结构改造成线程安全的形式。这些经验将对我的未来学习和工作产生积极的影响。</li></ul><h1 id="六、附"><a href="#六、附" class="headerlink" title="六、附"></a>六、附</h1><p>所有代码均已上传至github</p><p><a href="https://github.com/i-rong/rongrong/tree/main/nachos">实验代码</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nachos01</title>
    <link href="/2023/09/25/nachos01/"/>
    <url>/2023/09/25/nachos01/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h1><ol><li><p>熟悉Nachos系统。了解Nachos的目录结构，最主要的部分是 Nachos 的code部分。</p></li><li><p>初步了解Makefile的构成和相互关系。</p></li><li><p>修改Nachos 线程管理部分源代码体会多线程并发会导致的问题。</p></li></ol><h1 id="二、-实验要求"><a href="#二、-实验要求" class="headerlink" title="二、 实验要求"></a>二、 实验要求</h1><ol><li><p>安装 、编译nachos</p></li><li><p>实现双向有序链表</p><p>撰写dllist.cc、dllist.h、dllist-driver.cc文件。文件中要包括类的定义和实现，以及有序插入N个随机数函数和删除函数的实现，同时打印出删除的项目。</p></li><li><p>体验 nachos 线程系统</p></li></ol><p>需要做的更改有:</p><ol><li><p>将dllist.cc、dllist.h、dllist-driver.cc、dllist-driver.h等文件拷贝到 nachos-3.4&#x2F;code&#x2F;threads&#x2F;目录下。</p></li><li><p>修改 Makefile.common 中的 THREAD_H、THREAD_C、THREAD_O 以保证新的文件可以被正确编译。</p></li><li><p>根据实验内容，修改main.cc，threadtest.cc等文件，通过操作双向链表展现多线程并发所引发的问题。</p></li></ol><h1 id="三、-实验设计及关键代码实现"><a href="#三、-实验设计及关键代码实现" class="headerlink" title="三、 实验设计及关键代码实现"></a>三、 实验设计及关键代码实现</h1><h2 id="1-多线程执行可能出现的问题"><a href="#1-多线程执行可能出现的问题" class="headerlink" title="1.  多线程执行可能出现的问题"></a>1.  多线程执行可能出现的问题</h2><p>1）线程安全问题</p><ul><li><strong>原子性</strong>：即一个操作或多个操作，要么全部执行并且执行过程中不会被任何的因素打断，要么就都不执行</li><li><strong>原子操作</strong>：即不会被线程调度机制打断的操作，没有上下文切换</li></ul><p>在并发编程中很多的操作都不是原子操作，如：</p><p>操作1: i &#x3D; 0; 对基本数据类型变量的赋值操作是原子操作</p><p>操作2: i++; 包含3个操作，读取i的值，将i加1，将值赋给i</p><p>操作3: i &#x3D; j; 包含2个操作，读取j的值，将j的值赋给i</p><p>操作4 : i &#x3D; i + 1; 包含3个操作，读取i的值，将i加1，将值赋给i</p><p>所以非原子操作的每个操作都可能被线程调度机制打断，引发问题</p><ul><li><strong>可见性</strong>：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到这个修改的值。每个线程都有自己的工作内存，工作内存和主存间要通过store和load进行交互。假如有两个线程：线程1在自己的工作内存中完成赋值操作，却没有及时将新值刷新到主内存中。而线程2会从主内存中读取i的值，然后加载到自己的工作内存中，但赋值工作还没有完成，就进行了读取。这就是可见性问题。</li></ul><p>2）活跃性问题：可分为死锁、活锁和饥饿。</p><p>3）性能问题</p><ul><li>在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源。操作系统为此所付出的开销，明显大于创建或撤销线程时的开销。</li><li>在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li></ul><p>本次实验主要涉及<strong>线程安全问题</strong>。</p><h2 id="2-正确编译Nachos"><a href="#2-正确编译Nachos" class="headerlink" title="2.  正确编译Nachos"></a>2.  正确编译Nachos</h2><p>Makefile.common文件定义了编译链接生成一个完整的Nachos可执行文件所需要的所有规则。我们需要把要添加的.h和.cc文件放到_H、_C还有_O的列表中。将新编写的dllist.cc、dllist.h、dllist-driver.cc文件加入列表中，使make可以正常编译链接出目标文件。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145410137.png" alt="image-20230925145410137"> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145421806.png" alt="image-20230925145421806"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145452949.png" alt="image-20230925145452949"> </p><h2 id="3-代码涉及的参数"><a href="#3-代码涉及的参数" class="headerlink" title="3.  代码涉及的参数"></a>3.  代码涉及的参数</h2><center>表1 可传入的参数</center><table><thead><tr><th>参数标记</th><th>对应变量名</th><th>参数含义</th></tr></thead><tbody><tr><td>-q</td><td>int testnum</td><td>测试编号，用于进入不同的测试分支(默认为1)</td></tr><tr><td>-t</td><td>int threadnum</td><td>需要创建的并行线程数量(默认为2)</td></tr><tr><td>-n</td><td>int oprnum</td><td>链表操作的元素个数(默认为2)</td></tr><tr><td>-y</td><td>bool yield_flag</td><td>标志是否能进行线程切换(1表示可以，0表示不可以，默认为0)</td></tr></tbody></table><center>表 2 不同testnum的不同功能</center><table><thead><tr><th>testnum</th><th>功能</th><th>指令</th></tr></thead><tbody><tr><td>1</td><td>测试双向链表</td><td>-q 1 -t 1</td></tr><tr><td>2</td><td>复现进程共享问题</td><td>-q 1 -t 2 -n  5 -y 1</td></tr><tr><td>3</td><td>复现覆盖问题</td><td>-q 2 -t 2 -n  5 -y 1</td></tr><tr><td>4</td><td>复现乱序问题</td><td>-q 3 -y 1</td></tr></tbody></table><h2 id="4-实现双向链表"><a href="#4-实现双向链表" class="headerlink" title="4.  实现双向链表"></a>4.  实现双向链表</h2><ol><li>按照Nachos实验指导的3.1部分将双向链表的定义写入dllist.h文件中，并作适当的添加和修改:</li></ol><p>DLLElement类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DLLElement</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">DLLElement</span>(<span class="hljs-type">void</span> *itemPtr, <span class="hljs-type">int</span> sortKey); <span class="hljs-comment">// initialize a list element</span><br>        DLLElement *next; <span class="hljs-comment">// next element on list</span><br>        <span class="hljs-comment">// NULL if this is the last</span><br>        DLLElement *prev; <span class="hljs-comment">// previous element on list</span><br>        <span class="hljs-comment">// NULL if this is the first</span><br>        <span class="hljs-type">int</span> key; <span class="hljs-comment">// priority, for a sorted list</span><br>        <span class="hljs-type">void</span> *item; <span class="hljs-comment">// pointer to item on the list</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>DLList类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DLList</span> &#123; <br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">DLList</span>(); <span class="hljs-comment">// initialize the list</span><br>        ~<span class="hljs-built_in">DLList</span>(); <span class="hljs-comment">// de-allocate the list</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prepend</span><span class="hljs-params">(<span class="hljs-type">void</span> *item)</span></span>; <span class="hljs-comment">// add to head of list (set key = min_key-1)</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Append</span><span class="hljs-params">(<span class="hljs-type">void</span> *item)</span></span>; <span class="hljs-comment">// add to tail of list (set key = max_key+1)</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">int</span> *keyPtr)</span></span>; <span class="hljs-comment">// remove from head of list</span><br>        <span class="hljs-comment">// set *keyPtr to key of the removed item</span><br>        <span class="hljs-comment">// return item (or NULL if list is empty)</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// return true if list has no elements</span><br>        <span class="hljs-comment">// routines to put/get items on/off list in order (sorted by key)</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SortedInsert</span><span class="hljs-params">(<span class="hljs-type">void</span> *item, <span class="hljs-type">int</span> sortKey)</span></span>; <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SortedInsert2</span><span class="hljs-params">(<span class="hljs-type">void</span> *item, <span class="hljs-type">int</span> sortKey)</span></span>; <br>        <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">SortedRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> sortKey)</span></span>; <span class="hljs-comment">// remove first item with key==sortKey</span><br>        <span class="hljs-comment">// return NULL if no such item exists</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowList</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span></span>;<br>        <span class="hljs-function">DLLElement * <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> first; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFirst</span><span class="hljs-params">(DLLElement *p)</span> </span>&#123; first = p; &#125;<br>    <span class="hljs-keyword">private</span>: <br>        DLLElement *first; <span class="hljs-comment">// head of the list, NULL if empty</span><br>        DLLElement *last; <span class="hljs-comment">// last element of the list, NULL if empty</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>在dllist.cc文件中根据定义写出具体的函数实现（这里只展示重要代码）</li></ol><p>SortedInsert函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLList::SortedInsert</span><span class="hljs-params">(<span class="hljs-type">void</span> *item, <span class="hljs-type">int</span> sortKey)</span> </span>&#123;<br>    DLLElement *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLLElement</span>(item, sortKey);<br>    DLLElement *ptr;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsEmpty</span>()) &#123; <span class="hljs-comment">// if is empty, newone is the only one</span><br>        first = newnode;<br>        last = newnode;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sortKey &lt; first-&gt;key) &#123;<br>        newnode-&gt;next = first;<br>        <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>        first-&gt;prev = newnode;<br>        first = newnode;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(ptr = first; ptr-&gt;next != <span class="hljs-literal">NULL</span>; ptr = ptr-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span>(sortKey &lt; ptr-&gt;next-&gt;key) &#123;<br>                newnode-&gt;next = ptr-&gt;next;<br>                newnode-&gt;prev = ptr;<br>                <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>                ptr-&gt;next-&gt;prev = newnode;<br>                ptr-&gt;next = newnode;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// insert to the tail</span><br>        newnode-&gt;prev = last;<br>        <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>        last-&gt;next = newnode;<br>        last = newnode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SortedRemove函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">DLList::SortedRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> sortKey)</span> </span>&#123; <span class="hljs-comment">// find the first elem that the key is equal to sortKey and remove it</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>    DLLElement *ptr;<br>    <span class="hljs-type">void</span> *TB_return;<br>    <span class="hljs-keyword">if</span>(first-&gt;key == sortKey) &#123; <span class="hljs-comment">// if the first is equal to the sortKey, then delete it</span><br>        first = <span class="hljs-literal">NULL</span>;<br>        last = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(ptr = first-&gt;next; ptr-&gt;next != <span class="hljs-literal">NULL</span>; ptr = ptr-&gt;next) &#123;<br>            TB_return = ptr-&gt;item;<br>            <span class="hljs-keyword">if</span>(ptr-&gt;key == sortKey) &#123;<br>                ptr-&gt;prev-&gt;next = ptr-&gt;next;<br>                ptr-&gt;next-&gt;prev = ptr-&gt;prev;<br>                <span class="hljs-keyword">delete</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;key == sortKey) &#123;<br>            ptr-&gt;prev-&gt;next = <span class="hljs-literal">NULL</span>;<br>            last = ptr-&gt;prev;<br>            TB_return = ptr-&gt;item;<br>            <span class="hljs-keyword">delete</span> ptr;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TB_return;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在dllist-driver.cc中实现两个函数，其中一个函数需要插入N个元素，另外一个函数需要从双向链表的头部删除N个元素并将它们打印到终端。这两个函数的参数都是一个int整形N和一个指向双向链表的指针。</li></ol><p>genItem2List函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">genItem2List</span><span class="hljs-params">(<span class="hljs-type">int</span> n, DLList *dllist)</span> </span>&#123; <span class="hljs-comment">// generate n random keys and the dllist points to the list</span><br>    <span class="hljs-type">int</span> *item, key;<br>    <span class="hljs-keyword">if</span>(!seed) &#123;<br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">unsigned</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>)));<br>        seed = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        item = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>        *item = <span class="hljs-built_in">rand</span>();<br>        key = <span class="hljs-built_in">rand</span>() % NUM_RANGE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insert %d into the list\n&quot;</span>, key);<br>        dllist-&gt;<span class="hljs-built_in">SortedInsert</span>((<span class="hljs-type">void</span> *)item, key);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insert %d into the list complete\n&quot;</span>, key);<br>    &#125;<br>    dllist-&gt;<span class="hljs-built_in">ShowList1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>delItemFromList函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delItemFromList</span><span class="hljs-params">(<span class="hljs-type">int</span> n, DLList *dllist)</span> </span>&#123; <span class="hljs-comment">// removes N items starting from the head of the list</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!dllist-&gt;<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Delete from the head\n&quot;</span>);<br>            <span class="hljs-type">int</span> keyval;<br>            dllist-&gt;<span class="hljs-built_in">Remove</span>(&amp;keyval);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Delete %d from the list\n&quot;</span>, keyval);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The list is empty\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    dllist-&gt;<span class="hljs-built_in">ShowList2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在threadtest.cc中另写一个函数，调用上述两个函数，验证代码的正确性，展示双向链表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLListTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Insert items in thread %d\n&quot;</span>, which);<br>    <span class="hljs-built_in">genItem2List</span>(oprnum, dllist);<br>    <span class="hljs-keyword">if</span>(yield_flag == <span class="hljs-literal">true</span>) currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Remove items in thread %d\n&quot;</span>, which);<br>    <span class="hljs-built_in">delItemFromList</span>(oprnum, dllist);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>运行结果</li></ol><p>在终端输入.&#x2F;nachos -q 1 -t 1得到结果：</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145748825.png" alt="image-20230925145748825"></p><h2 id="5-线程并发以及并发可能引起的问题"><a href="#5-线程并发以及并发可能引起的问题" class="headerlink" title="5.  线程并发以及并发可能引起的问题"></a>5.  线程并发以及并发可能引起的问题</h2><ul><li>首先，我们需要先了解线程切换的方法，强制的线程切换使用currentThread-&gt;Yield()，这里需要注意的是需要引用 system.h 文件。</li></ul><p>currentThread定义在system.cc中，表示当前正在运行的线程：</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145804529.png" alt="image-20230925145804529"></p><p>调用Thread类中的Yield方法可以使得当前线程立即放弃所占用的CPU，使得其他可以运行的线程获得所需要的CPU资源从而执行其他线程下的任务：</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145813280.png" alt="image-20230925145813280"></p><ul><li><p>修改 threads&#x2F;main.cc 和 threads&#x2F;theadtest.cc 文件，实现可以创建 T 个线程（不同步），每个线程先插入 N 个元素，再依次移除并打印。所有线程共用一个链表。</p></li><li><p>设计可能发生的线程冲突问题，并探究其发生的原因。</p></li></ul><h3 id="问题1：内存共享"><a href="#问题1：内存共享" class="headerlink" title="问题1：内存共享"></a>问题1：内存共享</h3><p>并行执行时一个线程可能会修改其他线程正在进行操作的双向链表，比如一个线程还没有完成它全部应该完成的任务时调用了Yield将资源让给其他线程，其他线程就再次对这个链表进行操作，使得链表还没有被删除就再次被插入。</p><p>我们可以在代码中加入这样一行代码来模拟该种情况（第4行为加入的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLListTest</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Insert items in thread %d\n&quot;</span>, which);<br>    <span class="hljs-built_in">genItem2List</span>(oprnum, dllist);<br>    <span class="hljs-keyword">if</span>(yield_flag == <span class="hljs-literal">true</span>) currentThread-&gt;<span class="hljs-built_in">Yield</span>();<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Remove items in thread %d\n&quot;</span>, which);<br>    <span class="hljs-built_in">delItemFromList</span>(oprnum, dllist);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中yield_flag是在threadtest.cc中定义的一个变量，表示是否可以强制切换线程，若值为1则可以，反之则不可以。通过在命令行中加入-y 1的参数可以改yield_flag的值为1。</p><p>但这种情况比较“善良”，并不会出现报错信息，只是会删除掉别的线程所生成的随机节点。运行如下指令，可看到结果：</p><p>.&#x2F;nachos -q 1 -t 2 -y 1</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925145910794.png">可以看到，第一个线程先插入然后紧接着第二个线程进行插入，最后是两个线程接连删除链表中的内容，最后链表中的内容会删空。</p><h3 id="问题2：覆盖"><a href="#问题2：覆盖" class="headerlink" title="问题2：覆盖"></a>问题2：覆盖</h3><p>并发的线程在链表的同一个地方插入不同的元素，导致其中那个先插入的元素被覆盖。</p><p>DLListTest2函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLListTest2</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Insert items in thread %d\n&quot;</span>, which);                                                               <br>    <span class="hljs-built_in">genItem2List</span>(oprnum, dllist);<br>&#125;<br></code></pre></td></tr></table></figure><p>与问题1的区别在于，问题1是在整个插入操作执行完毕后进行线程的强制切换，而要复现出问题2的情况就需要在插入的过程中（即在新生成的节点与其他节点建立链接时）进行线程切换。</p><p>修改SortInsert函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLList::SortedInsert</span><span class="hljs-params">(<span class="hljs-type">void</span> *item, <span class="hljs-type">int</span> sortKey)</span> </span>&#123;<br>    DLLElement *newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLLElement</span>(item, sortKey);<br>    DLLElement *ptr;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsEmpty</span>()) &#123; <span class="hljs-comment">// if is empty, newone is the only one</span><br>        first = newnode;<br>        last = newnode;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sortKey &lt; first-&gt;key) &#123;<br>        newnode-&gt;next = first;<br>        <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>(); <span class="hljs-comment">// 起主要作用的代码</span><br>        first-&gt;prev = newnode;<br>        first = newnode;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(ptr = first; ptr-&gt;next != <span class="hljs-literal">NULL</span>; ptr = ptr-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span>(sortKey &lt; ptr-&gt;next-&gt;key) &#123;<br>                newnode-&gt;next = ptr-&gt;next;<br>                newnode-&gt;prev = ptr;<br>                <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>(); <span class="hljs-comment">// 起主要作用的代码</span><br>                ptr-&gt;next-&gt;prev = newnode;<br>                ptr-&gt;next = newnode;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// insert to the tail</span><br>        newnode-&gt;prev = last;<br>        <span class="hljs-keyword">if</span>(yield_flag &amp;&amp; (testnum == <span class="hljs-number">2</span> ||  testnum == <span class="hljs-number">3</span>)) currentThread-&gt;<span class="hljs-built_in">Yield</span>(); <span class="hljs-comment">// 起主要作用的代码</span><br>        last-&gt;next = newnode;<br>        last = newnode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在终端执行.&#x2F;nachos -q 2 -t 2 -y 1 -n 5表示执行DLListTest2()函数并开启两个线程同时往双向链表中插入5个随机数，设置线程可切换，运行结果如下：</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150329321.png" alt="image-20230925150329321"></p><p>可以看到，两个线程共往链表中插入了10个元素，但是最终打印出来的结果只有6个，从而复现了元素覆盖的情况。</p><h3 id="问题3：乱序"><a href="#问题3：乱序" class="headerlink" title="问题3：乱序"></a>问题3：乱序</h3><p>两个线程在同一位置插入元素，可能导致顺序颠倒。</p><p>DllistTest3函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DLListTest3</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span> </span>&#123; <span class="hljs-comment">// out of order</span><br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;In thread %d\n&quot;</span>, which);<br>    <span class="hljs-keyword">if</span>(which == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">10</span>); <span class="hljs-comment">// Here to switch thread</span><br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">PrintList</span>(which, dllist);<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">7</span>);<br>        <span class="hljs-built_in">PrintList</span>(which, dllist);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// which == 1</span><br>        <span class="hljs-built_in">PrintList</span>(which, dllist);<br>        <span class="hljs-built_in">InsertItem</span>(which, dllist, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">PrintList</span>(which, dllist);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InsertItem函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertItem</span><span class="hljs-params">(<span class="hljs-type">int</span> which, DLList *dllist, <span class="hljs-type">int</span> keyv)</span> </span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stdout, <span class="hljs-string">&quot;Thread %d : Insert %d to the dllist\n&quot;</span>, which, keyv);<br>    dllist-&gt;<span class="hljs-built_in">SortedInsert</span>(<span class="hljs-literal">NULL</span>, keyv);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了能够保证乱序情况的出现，DLListTest3中的代码使用了固定参数的节点，同样线程切换的位置发生了变化，即新插入的节点的前驱指针和后继指针都已连接完毕，而指向新插入的节点的指针还未连接时进行线程转换。</p><p>运行结果：</p><p>在终端输入.&#x2F;nachos -q 3 -y 1可以看到</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150427124.png" alt="image-20230925150427124"></p><ul><li>线程1 想将元素3插入双向链表时，线程0还未将元素10完全插入双向链表，只是将元素10 的前驱指针和后继指针都指向了正确的地方，但是还没有指针指向元素10。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150440975.png"></p><ul><li>线程1插入元素3时发现元素3应该插在元素1的后面，并且和元素10一样，插了一半就换到了线程0。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150515872.png" alt="image-20230925150515872"></p><ul><li>换回线程0后，线程0继续完成未做完的工作（将该指向元素10的指针修改正确），于是把元素1的后继指向10。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150523908.png"></p><ul><li>在线程0插入下一个元素插入到一半的时候，又切换回线程1，线程1继续将没插完的元素3插入双向链表，它会将元素10的后继指向元素3。于是造成了乱序的现象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230925150541713.png" alt="image-20230925150541713"></p><h1 id="四、-遇到的问题"><a href="#四、-遇到的问题" class="headerlink" title="四、 遇到的问题"></a>四、 遇到的问题</h1><ul><li>一开始不太理解实验要求，像无头苍蝇一样不知道该如何进行实验。</li><li>双向链表不熟悉，刚开始建立和将双向链表打印出来的函数写得都有问题，于是我上网查阅资料，并简单地学习了gdb地用法，成功找出了BUG，顺利完成了本次实验。</li><li>看网上有资料说还有可能出现断链地情况，但是我一直没有办法复现出来，或者说其实已经出现了这种情况，但是我并没有发现它出现了，于是就没有在报告中体现这一部分地内容了。</li></ul><h1 id="五、-实验总结"><a href="#五、-实验总结" class="headerlink" title="五、 实验总结"></a>五、 实验总结</h1><ul><li>本次实验我学习到了简单使用nachos系统的方法，本次实验只涉及到线程，所以通过修改threads里的文件编写实现目标功能的函数，并运行，观察结果并分析。</li><li>简单了解了编写Makefile的语言规则。Makefile可以将编译众多文件的命令汇集到一个文件了，使用make命令执行Makefile，十分方便。</li><li>对于线程方面，主要想说的就是currentThread-&gt;Yield()，这个函数实际上就是让当前线程暂时放弃资源，去执行另一个线程的任务，当另一个线程完成操作之后，原线程再继续执行后续的操作。</li><li>本次实验中的线程并发本质上还是几个线程之间的切换，因此代码的执行顺序就非常重要，对于测试情况的设置就是基于对执行顺序的考虑，测试在不同位置切换线程可能造成的后果。</li></ul><h1 id="六、附"><a href="#六、附" class="headerlink" title="六、附"></a>六、附</h1><p>所有代码均已上传至github</p><p><a href="https://github.com/i-rong/rongrong/tree/main/nachos">实验代码</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>nachos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验(2)</title>
    <link href="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-2/"/>
    <url>/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-2/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络实验报告"><a href="#计算机网络实验报告" class="headerlink" title="计算机网络实验报告"></a>计算机网络实验报告</h1><h2 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h2><ul><li>一、 实验目的</li><li>二、 实验内容<ul><li>任务1: 捕获和分析有线以太网数据包<ul><li>1.1分析MAC帧</li><li>1.2分析IP数据报首部</li><li>1.3观察IP分片</li><li>1.4 ICMP协议分析（以ping指令为例）</li><li>1.5 tracert工作原理分析</li><li>1.6 ARP协议分析</li></ul></li><li>任务2: 捕获和分析802.11数据<ul><li>2.1搭建实验环境</li><li>2.2构建无线环境，捕获无线数据包、分析802.11数据</li></ul></li><li>任务3: 探索Wireshark更多功能和其它抓包工具(选做)<ul><li>探索Wireshark更多功能</li></ul></li></ul></li><li>三、 实验小结</li></ul><h2 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h2><p>• 学习捕获和分析网络数据包</p><p>• 掌握以太网MAC帧、802.11数据帧和IPv4数据包的构成，了解各字段的含义</p><p>• 掌握ICMP协议，ping和tracert指令的工作原理</p><p>• 掌握ARP协议的请求&#x2F;响应机理</p><h2 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 实验内容"></a>二、 实验内容</h2><h3 id="任务1-捕获和分析有线以太网数据包"><a href="#任务1-捕获和分析有线以太网数据包" class="headerlink" title="任务1: 捕获和分析有线以太网数据包"></a>任务1: 捕获和分析有线以太网数据包</h3><p>准备步骤:学习WireShark基本操作</p><h4 id="1-1分析MAC帧"><a href="#1-1分析MAC帧" class="headerlink" title="1.1分析MAC帧"></a>1.1分析MAC帧</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001227193.png" alt="image-20230924001227193"></p><p>开头六个字节是以太网MAC帧的目的地址，以该MAC帧为例，其目的地址为NewH3CTe_fe :80:01(40:fe:95:fe:80:01)。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001312786.png" alt="image-20230924001312786"></p><p>接下来六个字节是以太网MAC帧的源地址，以该MAC帧为例，其源地址为rongrongLEGION.local(48:89:e7:62:af:8e)，也即该电脑的本地地址。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001347115.png" alt="image-20230924001347115"></p><p>再接下来的两个字节标志了上一层使用的协议类型，如该类型字段的值为0x0800，表示上层使用的是IP数据报。</p><p>剩余的所有字节均是IP数据报。</p><p>值得一提的是，Wireshark展现给我们的帧中并没有帧检验序列FCS，这是因为</p><ul><li><p>Wireshark抓到的帧，是FCS校验通过的帧，而帧尾的FCS会被硬件去掉，所以没有FCS；</p></li><li><p>Wireshark不会抓取到FCS校验失败的帧。</p></li></ul><h4 id="1-2分析IP数据报首部"><a href="#1-2分析IP数据报首部" class="headerlink" title="1.2分析IP数据报首部"></a>1.2分析IP数据报首部</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001512955.png" alt="image-20230924001512955"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001551728.png" alt="image-20230924001551728"></p><p>IP数据报的首部是4bit的版本号，以该IP数据报为例，其版本号为 4 。</p><p>接下来4bit是首部长度，以该IP数据报为例，其首部长度是 20 字节。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924001934138.png" alt="image-20230924001934138"></p><p>然后是 1 字节的服务类型，以该IP数据报为例，其服务类型为 0 。</p><p>然后是 2 字节长的总长度，以该IP数据报为例，其总长度为 72 字节（4 * 16 + 8 &#x3D; 72），除去首部固定部分长度 20 字节，表明可变部分长度有 52 字节。上图显示了可变部分长度为 52 字节。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924002352174.png" alt="image-20230924002352174"></p><p>接下来 2 个字节是标识，以该IP数据报为例，其标识为0xf03b。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924002711041.png" alt="image-20230924002711041"></p><p>之后3bit是标志位，以该IP数据报为例，其标志位为 000 。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924002749933.png" alt="image-20230924002749933"></p><p>接下来13bit为片偏移，以该IP数据报为例，其片偏移为 0 。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924002904492.png" alt="image-20230924002904492"></p><p>接下来 1 字节为生存时间(TTL )，以该 IP数据报为例，其生存时间(TTL)为128s。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924002948928.png" alt="image-20230924002948928"></p><p>接下来 1 字节为协议，以该IP数据报为例，其协议为UDP(17)。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924003047815.png" alt="image-20230924003047815"></p><p>之后的 2 字节为首部检验和，以该IP数据报为例，其首部检验和为0 ，保留这个数据报。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924003148655.png" alt="image-20230924003148655"></p><p>接下来 4 字节为源 IP地址，以该 IP数据报为例，其源 IP 地址为192.168.31.229。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924003223002.png" alt="image-20230924003223002"></p><p>首部固定部分的最后 4 个字节为目的IP地址，以该IP数据报为例，其目的IP地址为192.168.10.2。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924003245058.png" alt="image-20230924003245058"></p><p>剩余字节均为可变部分。</p><h4 id="1-3观察IP分片"><a href="#1-3观察IP分片" class="headerlink" title="1.3观察IP分片"></a>1.3观察IP分片</h4><ol><li>ping -4 <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a></li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924013338498.png" alt="image-20230924013338498"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924013317234.png" alt="image-20230924013317234"></p><p>如上图所示，Wireshark抓包数据显示发送了 4 个数据包、接受了 4个数据包；终端窗口显示已发送的数据包个数为4,、已接受的数据包个数为 4 。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924015121303.png" alt="image-20230924015121303"></p><p>终端窗口显示接收到的字节数为 32 ，ICMP报文数据部分长度为 32 字节。</p><p>b) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1472 -f -n 1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924015201445.png" alt="image-20230924015201445"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924015319148.png" alt="image-20230924015319148"></p><p>如上图所示，Wireshark抓包数据显示发送了 1 个数据包、接收了 1个数据包；终端窗口显示已发送的数据包个数为 1 、已接受的数据包个数为 1 。</p><p>终端窗口显示接收到的字节数为 1472 ，ICMP 报文数据部分长度为1472 字节。</p><p>c) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1473 -f -n 1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924022722006.png" alt="image-20230924022722006"></p><p>终端显示“需要拆分数据包但是设置DF”，指的是数据包大小超过了网络限定MTU大小，即不分片对超过MTU的长报文无法传输。</p><p>d) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1473 -n 1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924022739298.png" alt="image-20230924022739298"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924022753020.png" alt="image-20230924022753020"></p><p>终端输入“ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1473 -n 1”从<a href="http://www.xmu.edu.cn请求字节长度为/">www.xmu.edu.cn请求字节长度为</a> 1473 字节的报文，并分片传输。Wireshark 抓包数据接收到两组报文，报文数据长度为 1473 字节。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095146000.png" alt="image-20230924095146000"></p><p>综上，对比以上四条命令：</p><p>(a) ping -4 <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> 表示从目的IP地址请求默认 32 字节的报文数据，共 4 次。</p><p>(b) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1472 -f -n 1 表示从目的IP地址请求 1472 字节的报文数据，且设置为不分片，请求 1 次。</p><p>(c) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1473 -f -n 1 表示从目的IP地址请求 1473 字节的报文数据，且设置为不分片，请求 1 次。</p><p>(d) ping <a href="http://www.xmu.edu.cn/">http://www.xmu.edu.cn</a> -l 1473 -n 1 表示从目的IP地址请求1473 字节的报文数据，且设置为分片，请求 1 次。</p><h4 id="1-4-ICMP协议分析（以ping指令为例）"><a href="#1-4-ICMP协议分析（以ping指令为例）" class="headerlink" title="1.4 ICMP协议分析（以ping指令为例）"></a>1.4 ICMP协议分析（以ping指令为例）</h4><p>执行一次ping命令会得到一组ICMP请求帧和回应帧。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095321704.png" alt="image-20230924095321704"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095343673.png" alt="image-20230924095343673"></p><p>例如，执行上述ping命令，得到一组ICMP请求帧和回应帧。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095410106.png" alt="image-20230924095410106"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095431257.png" alt="image-20230924095431257"></p><p>请求帧和回应帧的差别：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095449103.png" alt="image-20230924095449103"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095504663.png" alt="image-20230924095504663"></p><p>(1) 请求帧的Type为：Echo (ping) request (128)；回应帧的Type为：Echo (ping) reply (129)</p><p>(2) Checksum检验和不同</p><p>(3) 请求帧[Response In: 4]表示回应帧在分组 4 ；回应帧[Response To: 2]表示请求帧在分组 2</p><p>(4) 回应帧有回应时间</p><p>(5) 对应IP头部的差别：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095649172.png" alt="image-20230924095649172"></p><ul><li><p>二者的Hop Limit不同，请求帧IP头部的Hop Limit为 59 ；<br>回应帧IP头部的Hop Limit为 64</p></li><li><p>二者的源地址和目的地址对调</p></li><li><p>二者Fragment Header for IPv6中的Identifacation不同</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095726610.png" alt="image-20230924095726610"></p><h4 id="1-5-tracert工作原理分析"><a href="#1-5-tracert工作原理分析" class="headerlink" title="1.5 tracert工作原理分析"></a>1.5 tracert工作原理分析</h4><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095748228.png" alt="image-20230924095748228"></p><p>Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095936350.png" alt="image-20230924095936350"></p><p>首先，tracert发送出一个TTL是 1 的IP数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将TTL减 1 。此时，TTL变为 0 ，所以该路由器会将此据包丢掉，并送回一个[ICMP timeexceeded]消息（包括发 IP包的源地址，IP包的所有内容及路由器的IP地址）,如上图中的前 3 个TTL是 1 的IP数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924095951124.png" alt="image-20230924095951124"></p><p>tracert收到这个消息后，便知道这个路由器存在于这个路径上，接着tracert再送出另一个TTL是 2 的数据包，发现第 2 个路由器，如上图中红色框出的 3 个TTL是 2 的IP数据包。</p><p>tracert每次将送出的数据包的TTL加 1 来发现另一个路由器，这个重复的动作一直持续到某个数据包抵达目的地。当数据包到达目的地后，该主机则不会送回ICMP time exceeded消息，一旦到达目的地，由于 tracert 通过 UDP 数据包向不常见端口(30000 以上)发送数据包，因此会收到[ICMP port unreachable]消息，故可判断到达目的地。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100004080.png" alt="image-20230924100004080"></p><p>tracert有一个固定的时间等待响应(ICMP TTL到期消息)。如果这个时间过了，它将打印出一系列的*号表明：在这个路径上，这个设备不能在给定的时间内发出ICMP TTL到期消息的响应。然后，Tracert给TTL记数器加 1 ，继续进行。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100037527.png" alt="image-20230924100037527"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100053116.png" alt="image-20230924100053116"></p><p>Tracert工作原理示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100118057.png" alt="image-20230924100118057"></p><h4 id="1-6-ARP协议分析"><a href="#1-6-ARP协议分析" class="headerlink" title="1.6 ARP协议分析"></a>1.6 ARP协议分析</h4><p>(1)以管理员身份运行终端窗口，运行<code>arp -d</code>命令，清空本机已有的ARP缓存</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100214847.png" alt="image-20230924100214847"></p><p>(2)抓包，ping旁边同学的ip</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100232191.png" alt="image-20230924100232191"></p><p>同学的ip为172.20.10.</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100249040.png" alt="image-20230924100249040"></p><p>解释ARP报文(请求)字段的含义：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100302006.png" alt="image-20230924100302006"></p><p>开头 2 个字节为Hardware type，该ARP报文的Hardware type为Ethernet(1)</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100333392.png" alt="image-20230924100333392"></p><p>接下来 2 个字节为Protocol type，该 ARP报文为例 的Protocol type为IPv4</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100347330.png" alt="image-20230924100347330"></p><p>接下来 1 个字节为Hardware size，该ARP报文 的Hardware size为6</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100413263.png" alt="image-20230924100413263"></p><p>接下来 1 个字节为Protocol size，该ARP报文 的Protocol size为4</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100429166.png" alt="image-20230924100429166"></p><p>接下来 2 个字节为Opcode，该ARP报文的Opcode为request(1)</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100524792.png" alt="image-20230924100524792"></p><p>接下来 6 个字节为Sender MAC address，该ARP报文的Sender MAC address为48:89:e7:62:af:8e</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100536293.png" alt="image-20230924100536293"></p><p>接下来 4 个字节为Sender IP address，该ARP报文的Sender IPaddress为172.20.10. 5</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100550285.png" alt="image-20230924100550285"></p><p>接下来 6 个字节为Target MAC address，该ARP报文的Sender MAC address为f8:e4:e3:ac:73:5d</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100617143.png" alt="image-20230924100617143"></p><p>接下来 4 个字节为Target IP address，该ARP报文的Target IP address为172.20.10.2</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100629632.png" alt="image-20230924100629632"></p><p>解释ARP报文(响应)字段的含义：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100644005.png" alt="image-20230924100644005"></p><p>开头 2 个字节为Hardware type，该ARP报文的Hardware type为Ethernet(1)</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100702600.png" alt="image-20230924100702600"></p><p>接下来 2 个字节为Protocol type，该ARP报文Protocol type为IPv4</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100713384.png" alt="image-20230924100713384"></p><p>接下来 1 个字节为Hardware size，该ARP报文Hardware size为 6</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100722560.png" alt="image-20230924100722560"></p><p>接下来 1 个字节为Protocol size，该ARP报文Protocol size为 4</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100734788.png" alt="image-20230924100734788"></p><p>接下来 2 个字节为Opcode，该ARP报文的Opcode为request(1)</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100746621.png" alt="image-20230924100746621"></p><p>接下来 6 个字节为Sender MAC address，该ARP报文的Sender MAC address为f8:e4:e3:ac:73:5d</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100758846.png" alt="image-20230924100758846"></p><p>接下来 4 个字节为Sender IP address，该ARP报文的Sender IP address为172.20.10.2</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100813446.png" alt="image-20230924100813446"></p><p>接下来 6 个字节为Target MAC address，该ARP报文的Sender MAC address为48:89:e7:62:af:8e</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100831053.png" alt="image-20230924100831053"></p><p>接下来 4 个字节为Target IP address，该ARP报文的Target IP address为172.20.10.5</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100843269.png" alt="image-20230924100843269"></p><p>(3)ping <a href="http://www.baidu.com/">http://www.baidu.com</a></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100859709.png" alt="image-20230924100859709"></p><p>此处，我们发现这里并没有arp报文，但是此处会显示出ICMP类型的IP数据包以及TCP类型的IP数据包，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100906599.png" alt="image-20230924100906599"></p><p><a href="http://www.baidu.com/">http://www.baidu.com</a> 并不处于与本地主机的同一个局域网内，我们需要ping网关</p><p>默认网关如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100921644.png" alt="image-20230924100921644"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100930006.png" alt="image-20230924100930006"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924100938104.png" alt="image-20230924100938104"></p><p>但是也没有任何ARP报文。</p><p>我们可以结合课本上的工作原理对ping同一局域网下的计算机和局域网外的计算机产生的不同影响进行说明：<br>对于同一局域网下的计算机：</p><ul><li>我们首先清空自己的arp缓存，不知道其他任何一个主机的MAC地址；</li><li>我们ping同一局域网下的一台主机，会在本局域网上请求发送一个ARP请求分组；</li><li>得到目的主机的MAC地址后，本主机的ARP高速缓存得以更新，将目的主机的IP地址和MAC地址对应上加入ARP高速缓存。</li></ul><p>而对于局域网外的计算机：</p><p>ARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题，如果要找的主机和源主机不在同一个局域网上，源主机就无法解析出另一个局域网上的主机的MAC地址。</p><h3 id="任务2-捕获和分析802-11数据"><a href="#任务2-捕获和分析802-11数据" class="headerlink" title="任务2: 捕获和分析802.11数据"></a>任务2: 捕获和分析802.11数据</h3><h4 id="2-1搭建实验环境"><a href="#2-1搭建实验环境" class="headerlink" title="2.1搭建实验环境"></a>2.1搭建实验环境</h4><p>实验环境：Ubuntu 64位虚拟机环境 + USB无线网卡</p><p>(1) 打开终端，安装Wireshark软件：</p><p><code>sudo apt install wireshark</code></p><p><code>sudo apt install wireshark-gtk</code></p><p>(2) 查询网卡状态：</p><p><code>iwconfig</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101158100.png" alt="image-20230924101158100"></p><p>捕获802.11帧需要设置网卡为监控模式（即monitor mode，非混杂模式），但是构建的虚拟机里显示的如上两个网卡都是虚拟机内设的，都不可以设置为监控模式（但是可以设置为混杂模式），所以需要将本地win10中的网卡连接到虚拟机中。</p><h4 id="2-2构建无线环境，捕获无线数据包、分析802-11数据"><a href="#2-2构建无线环境，捕获无线数据包、分析802-11数据" class="headerlink" title="2.2构建无线环境，捕获无线数据包、分析802.11数据"></a>2.2构建无线环境，捕获无线数据包、分析802.11数据</h4><p>构建无线环境：</p><ol><li>将USB无线网卡插到电脑机箱上</li><li>打开虚拟机里的Ubuntu 64-bit系统</li><li>更改设置，使网卡连接到虚拟机上</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101348475.png" alt="image-20230924101348475"></p><p>打开终端，输入ifconfig，看到多了一个<code>wlx0c826831a174</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101418817.png" alt="image-20230924101418817"></p><p>无线网卡配置：</p><ol><li>新建一个虚拟网卡，并将其修改为监听模式</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101450453.png" alt="image-20230924101450453"></p><ol start="2"><li>终端输入“wireshark”，打开Wireshark软件</li></ol><p>可以看到“mon0”，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101509229.png" alt="image-20230924101509229"></p><p>但是这里我们可以并没有看到有上下起伏的折线，应该是哪里有问题，双击尝试一下能否捕捉，果然不行，显示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101534176.png" alt="image-20230924101534176"></p><p>在终端输入以下指令：</p><p><code>sudo dpkg-reconfigure wireshark-common</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101553923.png" alt="image-20230924101553923"></p><p>选择yes</p><p>再次打开wireshark</p><p>发现什么端口都没有了，只剩下蓝牙端口，于是重新安装Wireshark。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101609652.png" alt="image-20230924101609652"></p><p>使用sudo命令打开Wireshark</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101710654.png" alt="image-20230924101710654"></p><p>可以看到mon0有上下起伏的波形，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101816299.png" alt="image-20230924101816299"></p><p>捕获和分析802.11数据：</p><p>双击mon0开始捕获，即可捕获到802.11数据</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101751966.png" alt="image-20230924101751966"></p><p>捕获到的802.11数据如上图所示。</p><h3 id="任务3-探索Wireshark更多功能和其它抓包工具-选做"><a href="#任务3-探索Wireshark更多功能和其它抓包工具-选做" class="headerlink" title="任务3: 探索Wireshark更多功能和其它抓包工具(选做)"></a>任务3: 探索Wireshark更多功能和其它抓包工具(选做)</h3><p>探索Wireshark更多功能</p><ol><li>数据流追踪</li></ol><p>先登录一个免费的图床，我们这里以“postimage”为例 ，其域名为“postimages.org”</p><p>将Wireshark的显示过滤器设置为“ip.addr eq postimages.org”，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101914472.png" alt="image-20230924101914472"></p><p>我们选择一张图片上传，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101927122.png" alt="image-20230924101927122"></p><p>Wireshark抓包结果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924101939715.png" alt="image-20230924101939715"></p><p>这里我们尝试追踪TCP流，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102057237.png" alt="image-20230924102057237"></p><p>如下图，红色流为源到目的地址，蓝色为目的地址到源：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102048085.png" alt="image-20230924102048085"></p><p>但是我的这里显示乱码，仍未解决……</p><ol start="2"><li>协议分层统计</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102121178.png" alt="image-20230924102121178"></p><p>协议分级统计如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102134272.png" alt="image-20230924102134272"></p><p>可以看到按分组百分比有34.2%的数据包是TSL协议。</p><ol start="3"><li>网络节点和会话统计功能</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102332763.png" alt="image-20230924102332763"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102340627.png" alt="image-20230924102340627"></p><ol start="4"><li>IO图表</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102353878.png" alt="image-20230924102353878"></p><ol start="5"><li>吞吐量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102440771.png" alt="image-20230924102440771"></p><ol start="6"><li>往返时间</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924102452767.png" alt="image-20230924102452767"></p><h2 id="三、-实验小结"><a href="#三、-实验小结" class="headerlink" title="三、 实验小结"></a>三、 实验小结</h2><p>通过本次实验，我学会了一些使用wireshark抓包的基本操作，并自行探索了wireshark更强大的功能。对一些报文如IPv4、IPv6、ARP等有了 更深层 、更直观的理解。</p><h2 id="四、附"><a href="#四、附" class="headerlink" title="四、附"></a>四、附</h2><p>所有文件已上传至github)</p><p><a href="https://github.com/i-rong/rongrong/tree/main/cn/homework/2">实验2文件</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验(3)</title>
    <link href="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-3/"/>
    <url>/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-3/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h1><ol><li><p>掌握TCP和UDP协议主要特点</p></li><li><p>理解socket的基本概念和工作原理，编程实现socket通信</p></li></ol><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 实验内容"></a>二、 实验内容</h1><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.  准备工作"></a>0.  准备工作</h2><ol><li><p>使用终端命令行安装本地echo服务，监听TCP 7号端口</p><ol><li><p><code>sudo apt update</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124524980.png" alt="image-20230924124524980"></p></li><li><p><code>sudo apt install xinetd</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124535077.png" alt="image-20230924124535077"></p></li><li><p>修改&#x2F;etc&#x2F;xinetd.d&#x2F;echo文件中的内容，将disable设置为no</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124544052.png" alt="image-20230924124544052"></p><ol start="4"><li><p><code>sudo service xinetd reload</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124553394.png" alt="image-20230924124553394"></p></li><li><p><code>netstat -an|grep :7</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124607177.png" alt="image-20230924124607177"></p></li></ol></li><li><p>输入<code>telnet localhost 7</code>，连接本机echo服务器，输入任意文本，观察响应</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124621082.png" alt="image-20230924124621082"></p></li><li><p>输入<code>Ctrl+]</code>结束echo服务，输入<code>close</code>或<code>quit</code>退出telnet</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124633410.png" alt="image-20230924124633410"></p></li></ol><h2 id="1-完善socket客户机"><a href="#1-完善socket客户机" class="headerlink" title="1.  完善socket客户机"></a>1.  完善socket客户机</h2><ol><li><p>开启两个终端窗口，分别编译、运行server_example.c和client_example.c，观察它们实现的功能</p><ol><li><p>编译、运行server_example.c和client_example.c</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124646506.png" alt="image-20230924124646506"></p></li><li><p>观察它们实现的功能</p><p>首先运行server_example，终端不会显示任何内容，处于server端处于监听状态</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124657749.png" alt="image-20230924124657749"></p><p>然后再运行client_example，client端会向server端发送一个字符串 “Hello Network!”，并在终端上显示出该条发送的信息</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124704866.png" alt="image-20230924124704866"></p><p>server端接到该条信息后在终端上显示接收到这条信息</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124712298.png" alt="image-20230924124712298"></p><p>server端同时向client端发送一条字符串 “Hello Network!”，并在终端上显示发送了这条字符串的信息</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124723925.png" alt="image-20230924124723925"></p><p>client端收到server端发送过来的字符串，在终端上输出接收到该条字符串的信息</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124731234.png" alt="image-20230924124731234"></p><p>倘若将运行这两个程序的顺序颠倒一下，就会产生以下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124740270.png" alt="image-20230924124740270"></p><p>可以看到，client端发送一个字符串后无法收到来自server端的回复；而如果之后再打开server端，也无法将二者建立起连接，无论client端再发送多少次，server端也无法接收到来自client端的信息。</p></li></ol></li><li><p>按以下要求，修改范例client_example.c，实现类似telnet连接echo服务器的效果</p><ol><li>为所有socket函数调用添加错误处理代码</li><li>范例中服务器地址和端口是固定值，请将它们改成允许用户以命令行参数形式输入</li><li>范例中客户机发送的是固定文本“Hello Network!”，请改成允许用户输入字符串，按回车发送</li><li>实现循环，直至客户机输入“bye”退出</li></ol><p>实验结果：</p><p>终端使用命令<code>./server 12345</code>指定端口号12345运行服务端：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124809501.png" alt="image-20230924124809501"></p><p>使用命令<code>./client localhost 12345</code>指定地址和端口号运行客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124814700.png" alt="image-20230924124814700"></p><p>可以看到，server端变为接收状态：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124820500.png" alt="image-20230924124820500"></p><p>向客户机输入字符串：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124823764.png" alt="image-20230924124823764"></p><p>几乎同一时刻，可以看到server端接收到信息并向终端输出信息</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124834342.png" alt="image-20230924124834342"></p><p>在client端输入“bye”后，进程终止，并向终端输出“Bye!”以示结束：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924124900787.png" alt="image-20230924124900787"></p></li></ol><h2 id="2-字符串回送服务器（TCP迭代）"><a href="#2-字符串回送服务器（TCP迭代）" class="headerlink" title="2.  字符串回送服务器（TCP迭代）"></a>2.  字符串回送服务器（TCP迭代）</h2><ol><li><p>客户机和服务器的运行情况</p><p>第一个客户机正常收发：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125217753.png" alt="image-20230924125217753"></p><p>第2个客户机输入后，无响应：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125222938.png" alt="image-20230924125222938"></p><p>第1个客户机bye之后，第2个客户机马上收到回复并进入循环：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125231873.png" alt="image-20230924125231873"></p><p>按Ctrl+c终止服务器程序：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125240196.png" alt="image-20230924125240196"></p></li><li><p>设置服务器listen( )的backlog为0或1，同时打开多个终端窗口、让4个客户机连接服务器，使用netstat命令观察socket状态变化，对照TCP连接状态图(5-28&#x2F;5-29&#x2F;5-30)，说明变化过程以及backlog与客户机完成队列的数量关系</p><ol><li><p>backlog设置为0：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125258286.png" alt="image-20230924125258286"></p><p>让4个客户机连接服务器，使用netstat命令观察socket状态变化：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -anp | grep 12345<br></code></pre></td></tr></table></figure><ol><li><p>只打开server端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125307232.png" alt="image-20230924125307232"></p></li><li><p>打开1个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125312209.png"></p></li><li><p>打开2个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125333220.png" alt="image-20230924125333220"></p></li><li><p>打开3个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125341650.png" alt="image-20230924125341650"> </p></li><li><p>打开4个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125348507.png" alt="image-20230924125348507"></p></li></ol><p>同时打开4个客户端，有2个可以被建立并正常运行</p></li><li><p>backlog设置为1：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125356225.png" alt="image-20230924125356225"></p><p>让4个客户机连接服务器，使用netstat命令观察socket状态变化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">netstat -anp | grep <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><ol><li><p>只打开server端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125401475.png" alt="image-20230924125401475"></p></li><li><p>打开1个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125408201.png" alt="image-20230924125408201"></p></li><li><p>打开2个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125412392.png" alt="image-20230924125412392"></p></li><li><p>打开3个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125418356.png" alt="image-20230924125418356"></p></li><li><p>打开4个client端</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125421962.png" alt="image-20230924125421962"></p></li></ol><p>同时打开4个客户端，有3个可以被建立并正常运行</p></li></ol></li><li><p>端口为什么要进行字节顺序转换，不转换会有什么情况？</p><p>代码改为不进行字节顺序转换：</p><p>注意，这里想要看到效果，只能修改server端和client端其中一个的代码，如果两个都修改的话，相当于两个都错了，从结果来看反而是对的了。</p><p>这里我修改了server.c代码：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125453527.png" alt="image-20230924125453527"></p><p>编译、运行修改后的代码，观察结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125459389.png" alt="image-20230924125459389"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125502651.png" alt="image-20230924125502651"></p><p>可以看到，client端被拒绝连接了。</p><p>我们可以通过netstat找到答案：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125509946.png" alt="image-20230924125509946"></p><p>检测不到任何2000的端口运行。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125516056.png" alt="image-20230924125516056"></p><p>使用<code>netstat -anplt</code>命令，我们可以看到并不是我们想要监听的2000端口，而是53255，这也是为什么client端想要向2000端口发送被拒绝的原因了。</p><p>原因：在进行网络编程时，由于网络的字节顺序和主机的字节顺序可能存在不同，我们需要对它们进行转换以统一“格式”。如果没有正确对两者进行转换，从而导致两方产生了不同的解释，就会出现bug。</p></li><li><p>试验客户机也像服务器一样bind固定端口,看看结果如何。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125528798.png" alt="image-20230924125528798"></p><p>先在终端运行命令：<code>sudo sysctl net.ipv4.tcp_timestamps=0</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125535229.png" alt="image-20230924125535229"></p><p>运行客户机，连接服务器：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125542473.png" alt="image-20230924125542473"></p><p>观察到运行正常。</p><p>客户机主动退出、再次运行客户机，netstat观察:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125549722.png" alt="image-20230924125549722"></p><p>使用<code>sudo sysctl net.ipv4.tcp_timestamps=0</code>命令的作用是关闭端口复用；当3000端口处于TIME_WAIT状态时，再次绑定该端口打开client端，系统不会将3000端口分配给client端使用，而会随机分配一个空闲状态的端口供client端使用。</p></li></ol><h2 id="3-字符串回送服务器（TCP并发）"><a href="#3-字符串回送服务器（TCP并发）" class="headerlink" title="3.  字符串回送服务器（TCP并发）"></a>3.  字符串回送服务器（TCP并发）</h2><ol><li><p>客户机和服务器运行时的截图</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125558821.png" alt="image-20230924125558821"></p></li><li><p>服务器accept之后会返回一个用于传输数据的socket，调用fork()会使父子进程同时拥有此socket描述符，父进程分支中是否需要关闭该socket？</p><p>答：需要关闭。如果不关闭，在退出客户端后，还有多个网络处于CLOSE_WAIT状态。</p><p>代码测试：</p><ol><li><p>关闭</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125606032.png" alt="image-20230924125606032"></p><ol><li><p>查看运行是否正常</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125609910.png" alt="image-20230924125609910"></p><p>可以看到，运行正常。</p></li><li><p>netstat观察多个客户机退出后的连接状态</p><p>使用<code>netstat -anp|grep 12345</code>命令：</p><p>连接三个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125615593.png" alt="image-20230924125615593"></p><p>关闭第一个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125618957.png" alt="image-20230924125618957"></p><p>关闭第二个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125623458.png" alt="image-20230924125623458"></p><p>关闭最后一个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125627065.png" alt="image-20230924125627065"></p></li></ol></li><li><p>不关闭</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125630832.png" alt="image-20230924125630832"></p><p>然后重新编译。</p><ol><li><p>查看运行是否正常</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125656247.png" alt="image-20230924125656247"></p><p>可以看到，不关闭此socket描述符，仍可以正常运行。</p></li><li><p>netstat观察多个客户机退出后的连接状态</p><p>使用<code>netstat -anp|grep 12345</code>命令：</p><p>连接三个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125707218.png" alt="image-20230924125707218"></p><p>关闭第一个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125711412.png" alt="image-20230924125711412"></p><p>关闭第二个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125715144.png" alt="image-20230924125715144"></p><p>关闭最后一个client端后使用该命令可以查看到如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125719009.png" alt="image-20230924125719009"></p><p>若此时，再打开一个client端，使用该命令可以看到如下内容： </p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924125731562.png"></p><p>之前因为和三个client端连接的server子进程，在三个client端关闭了之后，一直处于CLOSE_WAIT状态，如果之后再次有client端接入进来，处于CLOSE_WAIT状态的网络也不会自动和client端连接，而是会新开一个ESTABLISHED。由于端口数量是有限的，可以预见，随着时间的推移，client端的开关次数增多，总会到达一个时候，表面上没有多余的端口可供client端连接了，实际上所有的端口都处于CLOSE_WAIT状态，这会极大程度地造成资源利用不充分。</p><p>综上，父进程分支中应该关闭这个用于传输数据的socket。</p></li></ol></li></ol></li></ol><p>BUG修复：</p><p>一开始完成这个程序的时候其实还有一个bug，在第一次获取client端的ip时总是会获取到0.0.0.0，而之后连接进来的client端却都是正确的。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924130032932.png" alt="image-20230924130032932"></p><p>为了修复这个bug我花费了不少工夫。原因其实是在定义变量client_len的时候，没有给它赋初始值，我翻阅man手册查看accept的函数原型发现，如果要使用addrlen就必须要给它赋一个初始大小：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924130040549.png" alt="image-20230924130040549"></p><p>于是对代码进行修改，对client_len赋初始值：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924130049153.png" alt="image-20230924130049153"></p><p>然后再编译、运行，发现BUG得到了解决，可以正确得到第一个client端的地址和端口号：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924130103698.png" alt="image-20230924130103698"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924130110083.png" alt="image-20230924130110083"></p><h1 id="三、-实验结果分析"><a href="#三、-实验结果分析" class="headerlink" title="三、 实验结果分析"></a>三、 实验结果分析</h1><p>本次实验我顺利地完成了实验内容的必须要求，并且在不懈的努力下成功修复了一个很隐蔽的bug，并完成了选做的内容。</p><p>运行.&#x2F;server 2000 和 .&#x2F;client localhost 2000可以顺利观察到TCP的迭代情况，当第一个client端输入 “bye”终止后，server端才能接受到第二个client端发送过来的数据。</p><p>运行.&#x2F;server1 2000 和 .&#x2F;client localhost 2000可以顺利观察到TCP的并发情况，多个client端可以几乎同时向server端发送数据，无需等待排在前面的client端终止。</p><h1 id="四、-实验小结与感想"><a href="#四、-实验小结与感想" class="headerlink" title="四、 实验小结与感想"></a>四、 实验小结与感想</h1><p>本次实验完成较为顺利。</p><p>因为我提前预习了，所以在实验课前就已经将程序大致完成了。在实验课上，我着重做了选做的内容，并在洪老师的指导下，大致明白了转换字节顺序的重要性以及bind函数能实现的功能。</p><h1 id="五、附"><a href="#五、附" class="headerlink" title="五、附"></a>五、附</h1><p>完整代码已上传至github</p><p><a href="https://github.com/i-rong/rongrong/tree/main/cn/homework/3">实验三完整代码</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验(4)</title>
    <link href="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-4/"/>
    <url>/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h1><ol><li><p>理解动态路由协议RIP的工作原理；掌握采用动态路由协议RIP进行网络设计的基本原则和方法</p></li><li><p>理解动态路由协议OSPF的工作原理；掌握采用动态路由协议OSPF进行网络设计的基本原则和方法</p></li></ol><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 实验内容"></a>二、 实验内容</h1><h2 id="1-任务1-配置指定网络拓扑，分析RIP路由协议收敛具体过程。"><a href="#1-任务1-配置指定网络拓扑，分析RIP路由协议收敛具体过程。" class="headerlink" title="1.  任务1:配置指定网络拓扑，分析RIP路由协议收敛具体过程。"></a>1.  任务1:配置指定网络拓扑，分析RIP路由协议收敛具体过程。</h2><p>1.1.  在eNSP中搭建如下图拓扑，配置IP地址，配置RIPv2。完成后观察链路是否连通。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131051166.png" alt="image-20230924131051166"></p><p>1.1.1.  从R1到R5，为路由器的两个接口配置IP地址。</p><p>R1:  </p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131059960.png"></p><p>R2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131125721.png" alt="image-20230924131125721"></p><p>R3:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131139254.png" alt="image-20230924131139254"></p><p>R4:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131147586.png" alt="image-20230924131147586"></p><p>R5:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924131155520.png" alt="image-20230924131155520"></p><p>1.1.2.  从R1到R5为五个路由器分别配置动态路由协议(RIPv2)。配置后使用disp ip routing-table检查路由表。</p><p>R1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132104928.png" alt="image-20230924132104928"></p><p>R2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132114341.png" alt="image-20230924132114341"></p><p>R3:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132121987.png" alt="image-20230924132121987"></p><p>R4:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132130190.png" alt="image-20230924132130190"></p><p>R5:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132137517.png" alt="image-20230924132137517"></p><p>使用disp ip routing-table检查路由表</p><p>R1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132147870.png" alt="image-20230924132147870"></p><p>R2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132157825.png" alt="image-20230924132157825"></p><p>R3:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132208792.png" alt="image-20230924132208792"></p><p>R4:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132219097.png" alt="image-20230924132219097"></p><p>R5:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132228374.png" alt="image-20230924132228374"></p><p>1.2.  通过Wireshark和各种路由器RIP命令观察路由动态更新，将关键信息分析并截图。</p><p>1.2.1.  在打开路由器的同时对路由器端口抓包，可以观察到路由器Request报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132238312.png" alt="image-20230924132238312"></p><p>1.2.2.  检查连通性</p><p>在路由器R3上ping 192.168.5.1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132244551.png" alt="image-20230924132244551"> </p><p>wireshark抓包</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132249194.png" alt="image-20230924132249194"></p><p>网络已连通</p><p>1.2.3.  观察RIP交换报文的信息</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132254455.png" alt="image-20230924132254455"></p><p>可以看到RIP报文封装在UDP中，每隔30s向周边的邻居结点交换自己的路由表信息</p><p>我对IP地址为192.168.2.1和IP地址为192.168.2.2的端口进行了数据抓包，观察到在网络收敛后，两个端口抓包得到的RIP报文如下:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132300236.png" alt="image-20230924132300236"></p><p>这是IP地址为192.168.2.1的端口抓到的RIP报文，可以看到，到达192.168.1.0网段需要metric为1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132307184.png" alt="image-20230924132307184"></p><p>到达192.168.4.0网段需要metric为2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132314558.png" alt="image-20230924132314558"></p><p>到达192.168.5.0网段需要metric为2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132322590.png" alt="image-20230924132322590"></p><p>到达192.168.6.0网段需要metric为1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132331543.png" alt="image-20230924132331543"></p><p>1.2.4.  使用rip metricout 10</p><p>对R5的端口0&#x2F;0&#x2F;1使用rip metricout 10命令</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132339754.png" alt="image-20230924132339754"></p><p>可以观察到到达网段192.168.4.0、192.168.5.0和192.168.6.0的metric均变为10:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132345140.png" alt="image-20230924132345140"></p><p>1.2.5.  改变RIP链路开销:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132355149.png" alt="image-20230924132355149"></p><p>  以开销为7的这条链路为例，设置路由器R2和R5</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132417571.png" alt="image-20230924132417571"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132431579.png" alt="image-20230924132431579"></p><p>同理设置其他路由器；</p><p>全部设置完毕后，观察Wireshark抓包得到的RIP报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132444884.png" alt="image-20230924132444884"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132454237.png" alt="image-20230924132454237"></p><p>观察链路开销的改变造成的影响:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132501677.png" alt="image-20230924132501677"></p><p>配置完最后一条链路的开销之前，观察路由器R2的路由表:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132509341.png" alt="image-20230924132509341"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132517027.png" alt="image-20230924132517027"></p><p>将最后一条链路的开销增大为6后:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132527340.png" alt="image-20230924132527340"></p><h2 id="2-任务2-在任务1基础上断开某段链路，观察并分析各节点路由的变化。"><a href="#2-任务2-在任务1基础上断开某段链路，观察并分析各节点路由的变化。" class="headerlink" title="2.  任务2:在任务1基础上断开某段链路，观察并分析各节点路由的变化。"></a>2.  任务2:在任务1基础上断开某段链路，观察并分析各节点路由的变化。</h2><p>在任务1的网络收敛后，将AR2和AR3断开（坏消息！），分析该变化导致的重新收敛过程。</p><p>2.1.  将AR2和AR3断开</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132534396.png" alt="image-20230924132534396"></p><p>2.2.  分析该变化导致的重新收敛过程</p><p>断开之前，192.168.4.2的RIP路由表如下:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132539971.png" alt="image-20230924132539971"></p><p>与拓扑图相符；</p><p>观察Wireshark抓到的数据包:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132559428.png" alt="image-20230924132559428"></p><p>与网络拓扑相符;</p><p>断开AR2和AR3的连接后,观察到如下结果:</p><p>观察路由器R5的路由表:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132605837.png" alt="image-20230924132605837"></p><p>观察到“坏消息传得慢”的现象。</p><p>IP192.168.3.1到网段192.168.2.0原本metric为1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132613861.png" alt="image-20230924132613861"></p><p>断开后，metric变为16:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132620255.png" alt="image-20230924132620255"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132627972.png" alt="image-20230924132627972"></p><p>观察路由器R2的路由表:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132633567.png" alt="image-20230924132633567"></p><p>可以看到,Cost并没有立刻变为16，这符合RIP“坏消息传得慢”的特点。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132644622.png" alt="image-20230924132644622"></p><p> 最后收敛，RIP路由发现网段192.168.2.0不可达。</p><h2 id="3-任务3-配置指定网络拓扑，分析OSPF路由协议收敛具体过程。"><a href="#3-任务3-配置指定网络拓扑，分析OSPF路由协议收敛具体过程。" class="headerlink" title="3.  任务3: 配置指定网络拓扑，分析OSPF路由协议收敛具体过程。"></a>3.  任务3: 配置指定网络拓扑，分析OSPF路由协议收敛具体过程。</h2><p>3.1.  在eNSP中搭建如下图拓扑，配置IP地址，配置OSPFv2。完成后观察链路是否连通。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132659780.png" alt="image-20230924132659780"></p><p>3.1.1.  搭建网络拓扑</p><p>搭建网络拓扑与任务1操作相同，这里不再赘述。</p><p>3.1.2.  配置OSPF动态路由</p><p>R1:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132709575.png" alt="image-20230924132709575"></p><p>R2:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132716237.png" alt="image-20230924132716237"></p><p>R3:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132723005.png" alt="image-20230924132723005"></p><p>R4:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132731318.png" alt="image-20230924132731318"></p><p>R5:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132738183.png" alt="image-20230924132738183"></p><p>3.1.3.  观察链路是否连通</p><p>用路由器R1去ping 192.168.3.1，观察到可以ping通:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132748954.png" alt="image-20230924132748954"></p><p>用路由器R2去ping 192.168.4.1，观察到可以ping通:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132754308.png" alt="image-20230924132754308"></p><p>R1路由表截图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132802030.png" alt="image-20230924132802030"></p><p>R2路由表截图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132808219.png" alt="image-20230924132808219"></p><p>R3路由表截图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132813512.png" alt="image-20230924132813512"></p><p>R4路由表截图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132819221.png" alt="image-20230924132819221"></p><p>R5路由表截图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132824592.png" alt="image-20230924132824592"></p><p>3.2.  通过Wireshark和各种路由器OSPF命令观察路由动态更新，将关键信息分析并截图。</p><p>建立阶段，观察到DB Description报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132831360.png" alt="image-20230924132831360"></p><p>OSPF向邻居结点发送的是Hello Packet:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132837956.png" alt="image-20230924132837956"></p><p>当前情况下，经过R1发送出来的报文想要到达192.168.3.0网段的下一跳是192.168.5.1，使用命令增大链路192.168.4.1 &lt;-&gt; 192.168.4.2的开销:</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132853163.png" alt="image-20230924132853163"></p><p>Wireshark观察到OSPF的LS Update报文和LS Acknowledge报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132906210.png" alt="image-20230924132906210"></p><p>观察到路由器R1的路由表发生了开销的变化:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132911941.png" alt="image-20230924132911941"></p><p>将该链路的开销增大到1000:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132919426.png" alt="image-20230924132919426"></p><p>观察路由表:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132926004.png" alt="image-20230924132926004"></p><p>观察到R1的路由表仍然会选择192.168.5.1作为下一跳，我觉得很奇怪，它为什么会固执地选择192.168.5.1作为它的下一跳，而不选择192.168.1.2作为它的下一跳呢？</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132932109.png" alt="image-20230924132932109"></p><p>问题的解决:</p><p>最后在老师的帮助下，发现原来是因为这个地方没有配置IP地址:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132940820.png" alt="image-20230924132940820"></p><p>配置IP地址后:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924132947018.png" alt="image-20230924132947018"></p><p>再观察:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924133000284.png" alt="image-20230924133000284"></p><p>发现路由表正确，注意这个时候我还没有改变其他链路上的Cost。</p><p>3.3.  将各链路开销配置成如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924133006413.png" alt="image-20230924133006413"></p><p>可以看到LS Update报文:</p><p> <img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924133012258.png" alt="image-20230924133012258"></p><p>观察R1的路由表:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924133018882.png" alt="image-20230924133018882"></p><p>路由表与最短路径匹配，正确。</p><h1 id="三、-实验结果分析"><a href="#三、-实验结果分析" class="headerlink" title="三、 实验结果分析"></a>三、 实验结果分析</h1><p>  对于RIP协议，本次实验完成得比较顺利，也能较好地解释Wireshark抓包得到的报文信息，可以观察到“坏消息传得慢”这样的现象。</p><p>  但是对于OSPF协议，在做实验时，我发现了一个很奇怪的点，OSPF一开始选择的那条路径，无论我将这条链路的开销设置成多大，它始终会固执地选择这条路径。后来在老师的帮助下，找到了问题所在：原来是少配置了一个IP地址，将该IP地址配置上去后，问题就顺利解决了。</p><p>  若想要观察到动态路由协议一开始建立时候的信息，就需要先抓包，再去设置动态路由协议，这是从助教老师那里学到的小Tips。</p><h1 id="四、-实验小结与感想"><a href="#四、-实验小结与感想" class="headerlink" title="四、 实验小结与感想"></a>四、 实验小结与感想</h1><p>  通过本次实验，我体会到了不同的动态路由算法RIP和OSPF的区别。RIP使用DV算法，OSPF使用LS算法。RIP更倾向于“人云亦云”，它无条件的相信自己邻居发过来的信息，也就是别人怎么说，我就怎么信；而OSPF则是“兼听则明”，它会得到整个网络的所有情况，至于究竟怎么走，由我自己计算来决定。</p><h1 id="五、附"><a href="#五、附" class="headerlink" title="五、附"></a>五、附</h1><p>所有文件已上传至github</p><p><a href="https://github.com/i-rong/rongrong/tree/main/cn/homework/4">实验四文件</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验(5)</title>
    <link href="/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-5/"/>
    <url>/2023/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C-5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-实验目的"><a href="#一、-实验目的" class="headerlink" title="一、 实验目的"></a>一、 实验目的</h1><p>  本实验通过运用Wireshark对网络活动进行分析，观察TCP协议报文，分析通信时序，理解TCP的工作过程，掌握TCP工作原理与实现；学会运用Wireshark分析TCP连接管理、流量控制和拥塞控制的过程，发现TCP的性能问题。</p><h1 id="二、-实验内容"><a href="#二、-实验内容" class="headerlink" title="二、 实验内容"></a>二、 实验内容</h1><h2 id="任务1：TCP正常连接观察"><a href="#任务1：TCP正常连接观察" class="headerlink" title="任务1：TCP正常连接观察"></a>任务1：TCP正常连接观察</h2><p>实验准备:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image002.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140503579.png" alt="image-20230924140503579"></p><p>用PC1 ping 一下PC2，看是否能ping通，观察到两主机能联通:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image006.jpg" alt="img"></p><ol><li>利用 python 自带的 SimpleHTTPServer 模块，在 PC2 上启动一个简易的 web 服务器。终端上运行 echo “TCP lab test” &gt; index.html 创建 index.html 文件为测试站首页，运行 sudo python -m SimpleHTTPServer 80 启动一个简易 web 服务器；打开新终端，键入 ss -tln查看当前主机打开的 TCP 连接，确认 80 端口处于监听状态。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140521895.png" alt="image-20230924140521895"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image008.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140615247.png" alt="image-20230924140615247"></p><ol start="2"><li>在 PC1 上打开一个终端，键入 sudo wireshark 启动抓包软件；再打开一个新终端，键入curl &lt;PC2 的 IP&gt; ；停止抓包，在 wireshark 过滤出 TCP 类型报文。观察首个 TCP 报文头，并分析各段值代表的意义。如果想要关闭相对序号&#x2F;确认号，可以选择 Wireshark 菜单栏中的Edit<em>→</em>Preference<em>→</em>protocols<em>→</em>TCP，去掉 Relative sequence number 勾选项。使用 Wireshark 内置的绘制流功能，选择菜单栏中的 Statistics<em>→</em>Flow Graph， Flow Type 选择 TCP flows 可以直观地显示 TCP 序号和确认号是如何工作的。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140626556.png" alt="image-20230924140626556"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image013.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image015.jpg" alt="img"></p><p>实验要求:</p><ol start="3"><li>利用Wireshark，抓包分析并截图，分析该报文TCP首部各字段的定义、值及其含义</li></ol><p>(1)   利用Wireshark抓包并截图(保存在tcp1.pcapng中):</p><p>在Wireshark软件中设置display filter如下，进行报文过滤:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image016.jpg" alt="img"></p><p>抓取到整个TCP报文流:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140723852.png" alt="image-20230924140723852"></p><p>使用Statistics-&gt;Flow Graph工具，可以清楚地看到三次握手过程:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140731194.png" alt="image-20230924140731194"></p><p>四次挥手过程:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140740709.png" alt="image-20230924140740709"></p><p>可是，这里我观察到了一个“奇怪”的现象。不是说好了四次挥手吗？怎么只看到两次挥手。为了解决这个问题，我上网查找了很多资料。首先连接释放的时候不一定需要四次挥手，事实上，很多情况下都只有三次挥手。而满足三次挥手需要两个条件，当被动关闭方(上图的客户端)在TCP挥手过程中，[没有数据要发送]并且[开启了TCP延迟确认机制]，那么第二次和第三次挥手就会合并传输，这样就出现了三次挥手。这里的合并传输也就是<img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image024.jpg" alt="img">这个FIN包和ACK包合并传输了。</p><p>那么，分析完了四次挥手变成三次挥手的原因，可是我这里观察到的只有两次挥手啊，这是为什么呢？</p><p>这个问题困惑了我一整天，查阅资料发现，并不一定是客户端会主动断开连接，服务器端也有这个功能。于是我就去看了[FIN,ACK]之前的那个由服务器发给客户端的HTTP包，果然找到了答案:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image026.jpg" alt="img"></p><p>我发现这个报文里的FIN标志位竟然是1，说明这是服务器向客户端发送的第一个FIN包，也就是第一次挥手。于是，四次挥手便再次显现出来。</p><p>(2)   分析报文TCP首部各字段的定义、值及其含义</p><p>这里，我选择了三次握手的第一个报文:SYN报文进行分析</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140815295.png" alt="image-20230924140815295"></p><p>下面依据TCP报文的首部格式分析该TCP报文首部各字段:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image030.gif" alt="第一个报文—— SYN 报文"></p><p>前两个字节是16位源端口号，该报文的源端口号为34318</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140831809.png" alt="image-20230924140831809"></p><p>接下来两个字节是16位目标端口号，该报文的目标端口号为80</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image034.jpg" alt="img"></p><p>接下来四个字节是32位客户端随机初始化的序列号，该报文的序列号为1551970934</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140845589.png" alt="image-20230924140845589"></p><p>接下来四个字节是32位的确认应答号，该报文是三次握手的第一个SYN报文，没有设置确认应答号，故该报文确认应答号为0</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140852276.png" alt="image-20230924140852276"></p><p>接下来4位bit是首部长度，该报文的首部长度为40Bytes</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140903213.png" alt="image-20230924140903213"></p><p>接下来6位标志位保留，报文中都为0</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image042.jpg" alt="img"></p><p>接下来6位标志位，该报文中只有SYN被置1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image044.jpg" alt="img"></p><p>接下来两个字节是窗口大小，该报文的窗口大小为64240</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140917444.png" alt="image-20230924140917444"></p><p>接下来两个字节是校验和</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image048.jpg" alt="img"></p><p>接下来两个字节是紧急指针字段，该报文URG标志位为0，故这里的紧急指针字段也为0</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image050.jpg" alt="img"></p><p>最后的20字节是选项字段，这里不多分析</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140927101.png" alt="image-20230924140927101"></p><p>至此，该报文的首部各字段分析完毕。</p><ol start="4"><li>画出该TCP流的流图</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140932199.png" alt="image-20230924140932199"></p><h2 id="任务2：TCP异常传输观察分析"><a href="#任务2：TCP异常传输观察分析" class="headerlink" title="任务2：TCP异常传输观察分析"></a>任务2：TCP异常传输观察分析</h2><ol><li>尝试连接未存活的主机或未监听端口</li></ol><p>(1)   用 curl 访问一个不存在的主机 IP，抓包观察共发送了几次 SYN 报文。根据每次时间间隔变化，估算 RTO（重传超时）。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image056.jpg" alt="img"></p><p>抓包观察到共发送了两次SYN报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924140941961.png" alt="image-20230924140941961"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image060.jpg" alt="img"></p><p>估算RTO:</p><p>由上图可以大致估算出，RTO ≈ 9.514 – 6.443 &#x3D; 3.071s</p><p>(2)   查看 Linux 主机的系统的 TCP 参数 SYN 重传设定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/tcp_syn_retries<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image062.jpg" alt="img"></p><p>(3)   更改 SYN 重传次数为 3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;3&quot;</span> &gt; /proc/sys/net/ipv4/tcp_syn_retries<br></code></pre></td></tr></table></figure><p>注意，这里要切换到root用户下才能更改，否则会“Permission Denied”</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image064.jpg" alt="img"></p><p>(4)   再次 curl 访问，观察抓包内容。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image066.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image068.jpg" alt="img"></p><p>(5)   关闭服务器端的 SimpleHTTPServer(ctrl+C 中断，或关闭所在终端)，客户端 curl 访问服务器 80 端口，观察应答报文。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image070.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141005452.png" alt="image-20230924141005452"></p><p>(6)   运行 nmap -sS &lt;PC2 的 IP&gt; 扫描服务器，并抓包。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image074.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image076.jpg" alt="img"></p><p>(7)   在报告中总结以上观察结果，解释 SYN 扫描原理。</p><ol start="2"><li>观察客户端发送了第一个SYN连接请求，服务器无响应的情景</li></ol><p>(1)   服务器开启 telnet 或 ssh 服务，客户端先尝试连接服务器，连接成功后，在双方键入 ss -tan 查看所有 TCP 连接状态。我们看到的 TCP 连接建立过程同 1 中的 HTTP 访问类似。在客户端，利用 iptables 拦截服务器回应的 SYN ACK 包，命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo iptables -<span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">INPUT</span> -s <span class="hljs-number">192.168</span>.<span class="hljs-number">13.128</span> -<span class="hljs-selector-tag">p</span> tcp -m tcp <span class="hljs-attr">--tcp-flags</span> <span class="hljs-attribute">ALL</span> SYN,ACK -j DROP <br></code></pre></td></tr></table></figure><p>为了让服务器能够开启ssh服务，需要先<code>sudo apt install openssh-server</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image077.jpg" alt="img"></p><p>输入<code>sudo service ssh start</code>启动ssh服务</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141025548.png" alt="image-20230924141025548"></p><p>输入<code>sudo ps -e |grep ssh</code>查看ssh服务是否启动，观察到服务器已启动:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image079.jpg" alt="img"></p><p>接下来尝试使用客户端连接服务器，服务器的ip为192.168.13.128</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image081.jpg" alt="img"></p><p>在客户机上使用<code>sudo ssh [rongrong@192.168.13.128</code>](mailto:<a href="mailto:&#x72;&#111;&#x6e;&#103;&#x72;&#111;&#110;&#103;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x31;&#x33;&#x2e;&#x31;&#x32;&#56;">&#x72;&#111;&#x6e;&#103;&#x72;&#111;&#110;&#103;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#x31;&#x33;&#x2e;&#x31;&#x32;&#56;</a>&#96;)远程连接服务器(注意这里需要root权限，否则会Permission Denied):</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141038687.png" alt="image-20230924141038687"></p><p>看到如上界面说明成功远程连接到了服务器。</p><p>连接成功后，在双方键入<code>ss -tan</code>查看所有TCP连接状态:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image085.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141048860.png" alt="image-20230924141048860"></p><p>在客户端输入命令<code>sudo iptables -I INPUT -s 192.168.13.128 -p tcp -m tcp --tcp-flags ALL SYN,ACK -j DROP</code>利用iptables拦截服务器回应的SYN ACK包:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image089.jpg" alt="img"></p><p>(2)   再次尝试连接并启动 wireshark 抓包，并在双方多次用 ss -tan 观察 TCP 状态。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image091.jpg" alt="img"></p><p>服务器:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141104617.png" alt="image-20230924141104617"></p><p>客户机:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image095.jpg" alt="img"></p><p>(3)   观察 TCP 的状态变化，分析 wireshark 捕获的 TCP 异常报文。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141121198.png" alt="image-20230924141121198"></p><p>会产生这样的异常报文的原因是，由于我们设置了防火墙，阻塞了从服务器端发过来的SYN&amp;ACK包，这样客户机发第一个SYN包后，就始终不会收到服务器端的SYN&amp;ACK包，它就会以为是传输过程中丢包了，于是重新传输SYN包；而服务器那边也就不会收到客户机发来的三次挥手中的最后一个ACK包，超时后就会重传SYN&amp;ACK包。这就是产生图中异常报文的原因。</p><p>(4)   服务端的 SYN-RECV 状态何时释放？</p><p>当终端显示”Connection timed out”时释放</p><p>(5)   SYN ACK 重传了几次，时间间隔有何变化？</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141130593.png" alt="image-20230924141130593"></p><p>可以观察到SYN ACK重传了11次</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image099.jpg" alt="img"></p><p>可以观察到时间间隔一开始呈指数级别增大，最后稳定在16s左右</p><p>(6)   参考 1 中的操作，在服务端修改 SYN ACK 重传次数 (tcp_synack_retries)，再次观察，此任务结束后清空防火墙规则 (iptables -F)。</p><p>在服务端改重传次数为3次:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image101.jpg" alt="img"></p><p>再次观察（注意这里我连续尝试连接了两次）:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image103.jpg" alt="img"></p><p>清空防火墙规则:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141155586.png" alt="image-20230924141155586"></p><p>之后就可以顺利连接了:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141200757.png" alt="image-20230924141200757"></p><h2 id="任务3：拥塞控制"><a href="#任务3：拥塞控制" class="headerlink" title="任务3：拥塞控制"></a>任务3：拥塞控制</h2><ol><li>配置虚拟机设置:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image108.jpg" alt="img"></p><ol start="2"><li>使用ftp传输大文件:</li></ol><p>首先，我自己编写了一个程序gen_ran.c，使用命令<code>./gen_ran &lt;filename&gt; [size(MB)]</code></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image110.jpg" alt="img"></p><p>该程序可生成一个大小为size的文件，名称为filename，size可选，默认为100MB</p><p>使用<code>./gen_ran scpfile</code>生成一个大小为50MB的大文件scpfile:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image112.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141225043.png" alt="image-20230924141225043"></p><p>使用ftp传输该文件，同时使用wireshark抓包:</p><p>首先在终端输入命令<code>ftp 192.168.13.128</code>与服务端连接:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image115.jpg" alt="img"></p><p>连接成功后显示如上。</p><p>然后使用命令<code>put ftpfile</code>传输大文件，同时wireshark抓包:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141249110.png" alt="image-20230924141249110"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image119.jpg" alt="img"></p><ol start="3"><li>传输完毕，进行结果分析(该结果存放在ftp.pcapng中):</li></ol><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141258456.png" alt="image-20230924141258456"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image119.jpg" alt="img"></p><p>刚开始时，执行慢开始算法，说是慢开始，其实它并不慢，因为它是呈指数增长的。</p><p>超时，网络发生拥塞，这时可能连续收到三个重复确认，执行快恢复算法，拥塞窗口变为原来的一半。</p><p>然后拥塞避免算法，加法增大拥塞窗口。</p><h2 id="任务4：HTTP协议分析"><a href="#任务4：HTTP协议分析" class="headerlink" title="任务4：HTTP协议分析"></a>任务4：HTTP协议分析</h2><ol><li>搭建HTTP1.0服务器</li></ol><p>任务1搭建的即为HTTP1.0服务器。使用命令<code> sudo python -m SimpleHTTPServer 80</code>在虚拟机UbuntuV2上搭建服务器，在虚拟机Ubuntu 64bit上使用命令<code>curl 192.168.13.128</code>向服务器请求数据，</p><p>即可抓到HTTP1.0报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141315352.png" alt="image-20230924141315352"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image124.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141320651.png" alt="image-20230924141320651"></p><p>data的内容即为网页中的内容。</p><ol start="2"><li>搭建HTTP1.1服务器</li></ol><p>在Ubuntu 64bit中编写python脚本（源代码文本见附件），将协议的版本类型修改为HTTP&#x2F;1.1，即可搭建HTTP1.1服务:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image127.jpg" alt="img"></p><p>终端输入命令运行服务器，并打开wireshark进行抓包:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141341864.png" alt="image-20230924141341864"></p><p>输入后，终端会自动打开一个网页，该网页是我在该目录下写的一个html文件（源码见附件）:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image130.jpg" alt="img"></p><p>可以使用wireshark捕捉到HTTP1.1的报文:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image132.jpg" alt="img"></p><ol start="3"><li>搭建HTTP2.0服务器</li></ol><p>在搭建HTTP1.1的基础上，将协议的类型修改为HTTP2.0即可:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141354131.png" alt="image-20230924141354131"></p><p>与上一步类似，使用wireshark抓包，可以抓到TLS1.2的报文，该报文是HTTP2.0报文加密后的结果:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image135.jpg" alt="img"></p><p>若想要分析HTTP2.0报文，需要对wireshark进行解密，步骤如下:</p><p>(1)   配置系统环境变量:</p><p>在~&#x2F;.profile文件下加入<code>export SSLKEYLOFFILE=/home/rongrong/Desktop/sslkey.log</code></p><p>终端输入命令:<code>source ~/.profile</code></p><p>重启Ubuntu。</p><p>然后打开一个浏览器，会看到密钥已经写入到sslkey.log文件中了:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141406597.png" alt="image-20230924141406597"></p><p>(2)   配置Wireshark:</p><p>Wireshark-&gt;Edit-&gt;Protocols-&gt;TLS下，将(Pre)-Master-Secret log filename设置为刚刚设置的环境变量值:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141415551.png" alt="image-20230924141415551"></p><p>然后就可以看到HTTP2.0报文</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image141.gif" alt="img"></p><p>点开该报文可以看到，内容与index.html中的一致:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image143.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141428944.png" alt="image-20230924141428944"></p><ol start="4"><li>接下来对三种HTTP版本的报文进行分析</li></ol><p>(1)   HTTP1.0</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image147.jpg" alt="img"></p><p>右键点击该报文，选择Follow-&gt;HTTP Stream可以追踪HTTP流:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141439611.png" alt="image-20230924141439611"></p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141445128.png" alt="image-20230924141445128"></p><p>其中，红色的部分是请求格式，蓝色的部分是响应格式，可以很清楚地看到该HTTP流的请求响应流程。</p><p>可以分析一下HTTP1.0的报文结构:</p><p>起始行是状态行:HTTP&#x2F;1.0 200 OK</p><p>可以看到版本为HTTP1.0；状态码为200，表示成功；短语为OK。</p><p>(2)   HTTP1.1</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image153.jpg" alt="img"></p><p>与上一步的(1)相同，可以肯定看到HTTP stream:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image155.jpg" alt="img"></p><p>可以对HTTP1.1的请求报文结构和响应报文结构进行分析:</p><p>起始行除了版本，其他与HTTP1.0相同</p><p>可以看到Server与HTTP&#x2F;1.0不同，HTTP&#x2F;1.1的Server为nginx；</p><p>HTTP&#x2F;1.1报文还会将使用的是什么浏览器显示出来:Via: 1.1 google</p><p>HTTP&#x2F;1.1相比于HTTP&#x2F;1.0做了如下几点优化:</p><p>·    使用长连接的方式改善了HTTP&#x2F;1.0短连接造成的性能开销</p><p>·    支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>(3)   HTTP2.0</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image157.jpg" alt="img"></p><p>与前面两步相同，我们同样可以在这里看到HTTP2.0的HTTP stream:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image159.jpg" alt="img"></p><p>HTTP&#x2F;2.0协议与HTTP&#x2F;1.1协议有很大的不同，前者把后者存在的性能问题全部一一攻破了。</p><p>HTTP&#x2F;2.0相比于HTTP&#x2F;1.1在性能上的改进有如下几点:</p><ul><li>头部压缩</li></ul><p>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。</p><p>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><ul><li>二进制格式</li></ul><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame）。</p><p>这一点观察报文也能稍微看出一些区别。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141508085.png" alt="image-20230924141508085"></p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率</p><p>比如状态码 200 ，在 HTTP&#x2F;1.1 是用 ‘2’’0’’0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141548292.png" alt="image-20230924141548292"></p><p>在 HTTP&#x2F;2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP&#x2F;1.1 节省了 2 个字节，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image165.jpg" alt="img"></p><ul><li><p>并发传输</p></li><li><p>服务器主动推送资源</p></li></ul><h1 id="三、-实验结果分析"><a href="#三、-实验结果分析" class="headerlink" title="三、 实验结果分析"></a>三、 实验结果分析</h1><p>本次实验遇到了很多奇怪的现象，比如对于任务1，始终无法观察到连接释放时候的四次挥手，只能观察到两次挥手：由客户机向服务器发送一个FIN包，然后服务器再向客户机发送一个ACK包，然后就结束了，并没有观察到服务器向客户机发送的FIN包，如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image167.jpg" alt="img"></p><p>可以看到只有两次。</p><p>多次尝试好不容易抓到了一个四次挥手的报文，可是奇怪的事情又发生了。按理来说第一次的FIN包应该由客户机发给服务器才对，但是我观察到的却是服务器先发送非客户机:</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/image-20230924141616404.png" alt="image-20230924141616404"></p><p>发生这个现象的原因可能是HTTP&#x2F;1.0是短连接的，每发起一个请求都要新建一次TCP连接，这样服务端就会先发FIN包；若是使用HTTP&#x2F;1.1则不会是这样的现象。</p><p><img src="https://cdn.jsdelivr.net/gh/i-rong/BlogImages@main/img/clip_image171.jpg" alt="短连接与长连接"></p><p>经过我的不懈努力，搜索了大量的有关TCP抓包的资料，终于解决了上述两个问题。</p><p>以及在做观察快恢复现象的时候无法观察到与教材上相同的现象，只能根据包的数量大致分析这个阶段是在执行哪个算法。</p><p>除此以外，本次实验都完成地比较顺利。</p><h1 id="四、-实验小结与感想"><a href="#四、-实验小结与感想" class="headerlink" title="四、 实验小结与感想"></a>四、 实验小结与感想</h1><p>据老师所说，本次实验是最后一个需要写实验报告的实验。太好啦！终于不用写实验报告啦！！！</p><p>不过，和wireshark打了快一个学期的交道了，我深深感受到了wireshark这个抓包工具的强大。它除了可以抓包外，还提供了可视化分析网络包的图形界面，还内置了一系列的汇总分析工具。就拿本次实验来说，我就用到了许多除了抓包以外的工具，比如Flow Graph以及IO Graph里面的HTTP Stream等工具。通过这些工具分析流，可比光看报文方便多了。</p><h1 id="五、-思考题"><a href="#五、-思考题" class="headerlink" title="五、 思考题"></a>五、 思考题</h1><ol><li>在 TCP 状态机中，有些状态停留时间较长，易观察到，有些状态很短暂不易观察到。试列出不易观察到的状态，并考虑观察到它们的可能方法。</li></ol><p>不易观察到的状态有: FIN_WAIT_1、FIN_WAIT_2、CLOSE_WAIT、LAST_ACK。可以阻断中间的某个报文，以观察到接下来预计达到的状态。</p><ol start="2"><li>TCP 在不可靠的 IP 层上建立了可靠的端对端连接，如果要在不可靠的 UDP 上建立可靠的端对端传输系统，需要考虑哪些方面？</li></ol><p>现在市面上已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，已经应用在了 HTTP&#x2F;3。</p><p>要基于 UDP 实现的可靠传输协议，那么就要在应用层下功夫，也就是要设计好协议的头部字段。</p><p>需要把TCP 可靠传输的特性（序列号、确认应答、超时重传、流量控制、拥塞控制）在应用层全部实现一遍。</p><h1 id="六、附"><a href="#六、附" class="headerlink" title="六、附"></a>六、附</h1><p>实验5的所有文件已上传至github</p><p><a href="https://github.com/i-rong/rongrong/tree/main/cn/homework/5">实验6文件</a></p><p>部分重要代码:</p><p>gen_ran.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ONE_MB_SIZE 262144</span><br><span class="hljs-type">int32_t</span> out[ONE_MB_SIZE];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span> || argc &gt; <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: ./gen_ran &lt;filename&gt; [size(MB)]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>) size = <span class="hljs-number">100</span>; <span class="hljs-comment">// 如果只有两个参数 即只有一个文件名称 默认生成100MB的文件</span><br>    <span class="hljs-keyword">else</span> size = atoi(argv[<span class="hljs-number">2</span>]);<br>    FILE* outfile;<br>    <span class="hljs-keyword">if</span>((outfile = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;wb&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;open error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    srand((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)time(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; ONE_MB_SIZE; j++) &#123;<br>            out[j] = rand();<br>        &#125;<br>        fwrite(out, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int32_t</span>), ONE_MB_SIZE, outfile);<br>    &#125;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;random input file %s was generated successfully\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>HTTPserver.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> http.server <span class="hljs-keyword">import</span> HTTPServer, SimpleHTTPRequestHandler<br><span class="hljs-keyword">import</span> webbrowser<br><br>ip = <span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-comment"># 监听IP，配置项</span><br>port = <span class="hljs-number">8800</span>  <span class="hljs-comment"># 监听端口，配置项</span><br>index_url = <span class="hljs-string">&quot;http://%s:%d/index.html&quot;</span> % (ip, port)  <span class="hljs-comment"># 监听主页url，配置项</span><br><br><span class="hljs-comment"># 创建http server</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetHttpServer</span>(<span class="hljs-title class_ inherited__">SimpleHTTPRequestHandler</span>):<br>    protocol_version = <span class="hljs-string">&quot;HTTP/1.0&quot;</span><br>    server_version = <span class="hljs-string">&quot;PSHS/0.1&quot;</span><br>    sys_version = <span class="hljs-string">&quot;Python/3.9.x&quot;</span><br>    target = <span class="hljs-string">&quot;./&quot;</span>  <span class="hljs-comment"># 监听目录，配置项</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.path.find(<span class="hljs-string">&quot;/json/&quot;</span>) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(self.path)<br>            self.send_response(<span class="hljs-number">200</span>)<br>            self.send_header(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;json&quot;</span>)<br>            self.end_headers()<br>            req = &#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-string">&quot;ok&quot;</span>&#125;<br>            self.wfile.write(req.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>        <span class="hljs-keyword">else</span>:<br>            SimpleHTTPRequestHandler.do_GET(self)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_post</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.path == <span class="hljs-string">&quot;/signin&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;postmsg recv, path right&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;postmsg recv, path error&quot;</span>)<br>            data = <span class="hljs-string">&quot;&quot;</span><br>            data = json.loads(data)<br>            self.send_response(<span class="hljs-number">200</span>)<br>            self.send_header(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)<br>            self.end_headers()<br>            rspstr = <span class="hljs-string">&quot;recv ok, data = &quot;</span><br>            rspstr += json.dumps(data, ensure_ascii=<span class="hljs-literal">False</span>)<br>            self.wfile.write(rspstr.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">http_server</span>():<br>    server = HTTPServer((ip, port), GetHttpServer)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 弹出窗口</span><br>        webbrowser.<span class="hljs-built_in">open</span>(index_url)<br>        <span class="hljs-comment"># 输出信息</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务器监听地址： &quot;</span>, index_url)<br>        server.serve_forever()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        server.socket.close()<br><br><span class="hljs-comment"># 执行服务器脚本</span><br>http_server()<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    hello world<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
